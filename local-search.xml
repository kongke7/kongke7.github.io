<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2024/01/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/01/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java-并发编程"></a>Java-并发编程</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><ul><li>进程、线程</li><li>并发、并行</li><li>同步、异步</li></ul><p><strong>进程线程</strong></p><ul><li><p><strong>进程</strong>：程序是静止的，<strong>程序实体的运行过程就是进程</strong>，是操作系统进行<strong>资源分配</strong>的基本单位</p><img src="https://s2.loli.net/2024/01/03/4OYgozfySkrTmBp.webp" alt="jc" style="zoom: 50%;" /></li><li><p><strong>线程</strong>：线程属于进程，是一个基本的 CPU 执行单元，线程是进程中的一个实体，是系统<strong>独立调度</strong>的基本单位<br>       线程本身只拥有少量在运行中必不可少的资源，与同属一个进程的其他线程<strong>共享</strong>进程所拥有的全部资源</p></li><li><p><strong>关系</strong>：一个进程可以包含多个线程</p></li><li><p><strong>线程的作用</strong>：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p></li></ul><img src="https://s2.loli.net/2024/01/03/B4ZftIdOA8mMULh.png" alt="jcxc" style="zoom:50%;" /><p><strong>并发并行</strong></p><ul><li><strong>并行</strong>：在同一时刻，有多个指令在多个 CPU 上同时执行</li><li><strong>并发</strong>：在同一时刻，有多个指令在单个 CPU 上交替执行</li></ul><p><strong>同步异步</strong></p><ul><li><strong>同步</strong>：需要等待结果返回，才能继续运行就是同步</li><li><strong>异步</strong>：不需要等待结果返回，就能继续运行就是异步</li></ul><h2 id="二、线程-Thread"><a href="#二、线程-Thread" class="headerlink" title="二、线程-Thread"></a>二、线程-Thread</h2><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-comment">// main 方法属于Java程序中的一个默认线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;t-running...&quot;</span>));<br><br>        <span class="hljs-comment">// 设置线程名称</span><br>        t.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-comment">// 启动线程 (将线程交给线程调度器)</span><br>        t.start();<br><br>        <span class="hljs-comment">// 主线程的日志</span><br>        log.debug(<span class="hljs-string">&quot;m-running...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>main</code> 方法启动后也是一个线程</p></li><li><p><code>t.start()</code> 启动线程，将线程交给CPU进行调度</p><ul><li>线程在启动后会执行其 <code>run()</code> 方法</li></ul></li><li><p>如果是多核CPU则此时 main线程与t1线程并行执行</p></li></ul><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t2</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 使用 runnable 编写需要执行的代码（任务）</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br><br>        <span class="hljs-comment">// 创建线程 并将 runnable 作为参数传递</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用Runnable编写需要执行的代码（任务），再将其作为参数创建线程</li></ul><p><strong>Thread源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Thread底层也是实现了Runnable接口，并调用Runnable的 <code>run()</code>方法<ul><li>当Thread本身的 <code>run()</code>方法没有被重写时，先检查传入的Runnable对象，如不为空则调用该对象的 <code>run()</code></li></ul></li></ul><p><strong>优点</strong></p><ol><li>同一个任务对象可以被包装成多个线程对象</li><li>适合多个线程去共享同一个资源</li><li>实现解耦操作，任务代码和线程独立</li></ol><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><ul><li><code>Callable</code> 属于只有一个方法属于函数式接口，其方法有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：在线程执行结束后可以获得执行结果</p><p><img src="https://s2.loli.net/2024/01/03/KNaHBb2Lh3otzD9.png" alt="ft"></p></li><li><p><code>FutureTask</code> 实现了Runnable接口，属于Runnable对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 能够有返回值</span><br>        FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-comment">// 主线程阻塞，等待t1线程执行完毕</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> task.get();<br>        log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将Callable包装成 <code>FutureTask</code> 对象，创建线程则可以取得线程任务的结果返回值</li><li><code>get()</code> 方法会阻塞当前线程，等待目标线程任务执行完成后取得返回值</li></ul><h3 id="2-线程运行原理"><a href="#2-线程运行原理" class="headerlink" title="2. 线程运行原理"></a>2. 线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p><strong>Java Virtual Machine Stacks（Java 虚拟机栈）</strong>：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><img src="https://s2.loli.net/2024/01/04/3sKQijeE9Z8v5bU.png" alt="yl" style="zoom:67%;" /><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p><strong>线程上下文切换（Thread Context Switch）</strong>：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park 等方法</li></ul><p>当上下文切换发生时，需要由操作系统保存当前线程的状态（存入当前进程的PCB 中），并恢复另一个线程的状态</p><img src="https://s2.loli.net/2024/01/04/VmF3Y1doB9lxIv6.png" alt="yl2" style="zoom: 67%;" /><h3 id="3-线程方法-API"><a href="#3-线程方法-API" class="headerlink" title="3. 线程方法-API"></a>3. 线程方法-API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>设置线程名称</td></tr><tr><td>public void getName()</td><td>获取当前线程的名称 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程阻塞规定时间再继续执行，time&#x3D;0则让当前线程立刻被重新调度</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>获取线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程结束 millis 毫秒，0则永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><ul><li><p>使用 <code>start()</code> 启动新的线程，使此线程处于就绪态，运行时执行 run 中的代码</p></li><li><p>被激活后的线程不能再次 <code>start()</code></p></li></ul><h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><ul><li>线程体，包含了要执行的内容，</li><li>运行结束后此线程随即终止</li><li>如直接调用 <code>run()</code> 则是在主线程中执行 <code>run()</code>，没有启动新的线程</li></ul><p><strong>注：</strong></p><p>​因为 <code>Thread</code> 类的 <code>run()</code> 方法没有定义抛出任何受检查的异常。如果在 <code>run()</code> 方法中抛出受检查异常，则需要在方法内部进行处理，例如使用 <code>try-catch</code> 块捕获异常或使用 <code>throws</code> 关键字在方法内部声明抛出异常。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><ul><li><p>调用 sleep() 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</p></li><li><p>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></p></li><li><p>其它线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 源码，其实是对Thread.sleep()进行包装</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> toMillis(timeout);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ns</span> <span class="hljs-operator">=</span> excessNanos(timeout, ms);<br>        Thread.sleep(ms, ns);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><ul><li>让出当前线程对 CPU 的使用，并立即进入线程调度</li><li>让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程</li><li>具体的实现依赖于操作系统的调度算法</li><li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><blockquote><p>如果一个线程实例A执行了<code>threadB.join()</code>,其含义是：当前线程A会等待<code>threadB</code>线程终止后<code>threadA</code>才会继续执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>           log.debug(<span class="hljs-string">&quot;Running...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        t.start();<br>        t.join();<br>        log.debug(<span class="hljs-string">&quot;End...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>join 方法是被 synchronized 修饰的，本质上是一个对象锁</li><li>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br><span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><blockquote><p>中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。</p></blockquote><ul><li><p><code>public void interrupt()</code>：打断线程，异常处理机制</p></li><li><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，<strong>清除打断标记</strong></p></li><li><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，<strong>不清除打断标记</strong></p></li></ul><p>&#x3D;&#x3D;<strong>注意</strong>&#x3D;&#x3D;</p><ul><li><p><code>sleep、wait、join</code> 方法都会让线程进入阻塞状态，此时打断线程<strong>会清空打断状态</strong></p></li><li><p>当抛出<code>InterruptedException</code>时，会清除中断标志位</p></li></ul><p><strong>打断sleep线程时报错</strong></p><p><img src="https://s2.loli.net/2024/01/04/TSLciIw8DgPu7RV.png" alt="sleep"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test5&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           log.debug(<span class="hljs-string">&quot;T1开始sleep&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           log.debug(<span class="hljs-string">&quot;T2开始循环&quot;</span>);<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> thread.isInterrupted();<br>                <span class="hljs-keyword">if</span> (interrupted)&#123;<br>                    log.debug(<span class="hljs-string">&quot;T2被中断了,状态&#123;&#125;&quot;</span>,thread.getState());<span class="hljs-comment">// RUNNABLE(就绪/运行)</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        <span class="hljs-comment">// 将主线程先阻塞0.5s,让T1能先执行睡眠</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">// 打断sleep线程</span><br>        t1.interrupt();<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>        log.debug(<span class="hljs-string">&quot;T1的标志位&#123;&#125;&quot;</span>,t1.isInterrupted()); <span class="hljs-comment">// false(被重置)</span><br>        log.debug(<span class="hljs-string">&quot;T1的状态&#123;&#125;&quot;</span>,t1.getState());<span class="hljs-comment">// TERMINATED(终止)</span><br><br>        t2.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">// 打断正常运行线程</span><br>        t2.interrupt();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打断park状态的线程</strong></p><blockquote><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test6&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;进入park...&quot;</span>);<br>            LockSupport.park(); <span class="hljs-comment">// TIME_WAITING</span><br>            log.debug(<span class="hljs-string">&quot;被唤醒...&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;线程标志位&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted()); <span class="hljs-comment">// true</span><br>            <span class="hljs-comment">// 当标志位为true时无法被park</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;跳过park&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">// 打断线程</span><br>        t1.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如需多次park则可以使用<code>Interrupted()</code>在获取状态位后清除标记（false）</li></ul><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p><strong>不推荐使用</strong></p><ul><li><p><code>stop()</code> ：会杀死线程，如果此时线程锁住了共享资源，则资源无法释放，使其他线程无法获取</p></li><li><p><code>System.exit(int)</code>：此方法会停止线程所在的整个进程</p></li><li><p><code>suspend()</code>：挂起（暂停）线程，如果此时线程锁住了共享资源，且没有进程调用<code>resume()</code>则资源无法释放</p></li><li><p><code>resume()</code>：恢复线程运行</p></li></ul><p><strong>两阶段终止模式</strong></p><pre><code class=" mermaid">graph TDa(&quot;while(true)&quot;) --&gt; b(是否被打断)b --是--&gt; c(处理结束流程)b --否--&gt; d(休眠2s)d --无异常--&gt; f(执行监控记录)d --有异常--&gt; g(设置打断标志)f --&gt; ag --&gt; a</code></pre><center>流程图</center><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-comment">// 监控进程</span><br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span> (current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;处理后续事务&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控事务&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-comment">// 有异常则说明在sleep时被打断，所以重置标志位</span><br>                    current.interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 打断监控线程</span><br>        monitor.interrupt();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>        monitor.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><p><strong>用户线程</strong>：平常创建的普通线程</p></li><li><p><strong>守护线程</strong>：服务于用户线程，当其它非守护线程运行结束，守护线程会强制结束。</p><blockquote><p>守护进程是<strong>脱离终端且在后台运行</strong>，避免在执行的过程中的信息在终端上显示</p></blockquote></li></ul><p>使用 <code>setDaemon(true)</code>将普通线程设置为守护线程</p><p><strong>常见的守护线程</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h3 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4. 线程状态"></a>4. 线程状态</h3><blockquote><p> 在Java中线程存在 6 种状态</p></blockquote><p><img src="https://s2.loli.net/2024/01/04/8UG7qmnQ94cCRsb.png" alt="xczt"></p><ul><li>注意：在<code>RUNNABLE</code>种还包含线程<strong>由于IO操作被阻塞</strong>的状态</li></ul><p><strong>线程状态转换</strong></p><img src="https://s2.loli.net/2024/01/04/hpvPaZ2WBdzg3LM.png" alt="ztzh" style="zoom:80%;" /><ul><li><p><code>NEW</code> → <code>RUNNABLE</code>：当调用 <code>t.start()</code> 方法时，由 <code>NEW → RUNNABLE</code></p></li><li><p><code>RUNNABLE &lt;--&gt; WAITING</code>：</p><ul><li><p>调用 <code>obj.wait()</code> 方法时</p><p>调用 <code>obj.notify()、obj.notifyAll()、t.interrupt()</code>：</p><ul><li>竞争锁成功，线程从 <code>WAITING → RUNNABLE</code></li><li>竞争锁失败，线程从 <code>WAITING → BLOCKED</code></li></ul></li><li><p>当前线程调用 <code>t.join()</code> 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 <code>LockSupport.park()</code> 方法</p></li></ul></li><li><p><code>RUNNABLE &lt;--&gt; TIMED_WAITING</code>：</p><ul><li>调用 <code>obj.wait(long n)</code> 方法、当前线程调用 <code>t.join(long n)</code> 方法、当前线程调用 <code>Thread.sleep(long n)</code></li></ul></li><li><p><code>RUNNABLE &lt;--&gt; BLOCKED</code>：t 线程用 <code>synchronized(obj)</code> 获取了对象锁时竞争失败</p></li></ul><h2 id="三、同步与互斥"><a href="#三、同步与互斥" class="headerlink" title="三、同步与互斥"></a>三、同步与互斥</h2><ul><li><strong>互斥</strong>是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li><strong>同步</strong>是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><ul><li><p><strong>临界资源</strong>：一次只允许一个线程访问的资源</p></li><li><p><strong>临界区</strong>：一段代码快内，存在多个线程对临界资源的读写操作，则该代码快称之为临界区</p></li><li><p><strong>竞态条件</strong>：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 临界资源</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 临界区</span><br>&#123;<br>    count++;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 临界区</span><br>&#123;<br>    count--;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>注：当多个线程在临界区内对共享资源发生指令交错时，会出现线程安全问题</p><p><code>count++</code>编译为字节码命令为</p><ul><li><code>getstatic i</code></li><li><code>iconst_1</code></li><li><code>iadd</code></li><li><code>putstatic i</code></li></ul></li></ul><img src="https://s2.loli.net/2024/01/04/ruKL8lt2XysCQoJ.png" alt="xcaq" style="zoom:67%;" /><center>正常结果应该为 0</center> <p><strong>解决线程安全问题（互斥）</strong></p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2. synchronized"></a>2. synchronized</h3><blockquote><p>synchronized 对象锁</p></blockquote><p><strong>保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，<br>其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><strong>代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 锁对象为手动指定的对象</span><br><span class="hljs-keyword">synchronized</span>(锁对象)&#123;<br><span class="hljs-comment">// 访问共享资源的核心代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            counter++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 等价于上面的写法</span><br>    <span class="hljs-comment">// 锁对象this为当前对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>            counter--;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (Room.class) &#123;<br>            counter++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 等价于上面的写法</span><br>    <span class="hljs-comment">// 锁对象为类对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>            counter--;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加锁以后则可以让线程互斥的访问临界资源</strong>、</p><img src="https://s2.loli.net/2024/01/05/DuVhpdXc37sH6UJ.png" alt="xcaq2" style="zoom:80%;" /><h4 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h4><p><strong>成员变量和静态变量</strong></p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量</strong></p><ul><li>局部变量是线程安全的<ul><li>但局部变量引用的对象则夫必</li></ul></li><li>如果该对象没有逃离方法，它是线程安全的</li><li>如果该对象逃离方法的作用范围（被return），需要考虑线程安全</li></ul><p><strong>常见线程安全类</strong></p><ul><li><p>String</p></li><li><p>Integer</p></li><li><p>StringBuffer</p></li><li><p>Random</p></li><li><p>Vector</p></li><li><p>Hashtable</p></li><li><p>java.util.concurrent 包下的类（JUC）</p></li></ul><p>它们的<strong>每个方法是原子的</strong>但注意它们多个方法的<strong>组合不是原子</strong>的</p><p>其中，String，Integer 为不可变类，指其内部状态不可改变</p><h3 id="3-Monitor"><a href="#3-Monitor" class="headerlink" title="3. Monitor"></a>3. Monitor</h3><blockquote><p>监视器或管程</p></blockquote><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，<br>使用 synchronized 给对象上锁之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是<strong>重量级锁</strong></p><p><strong>monitor结构</strong></p><p><img src="https://s2.loli.net/2024/01/05/blzhkd63RVUpaui.png" alt="monitor"></p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><blockquote><p>在同步的时候是获取对象的monitor,即获取到对象的锁。<br>对象的锁是类似对对象的一个标志，这个标志就是存放在Java对象的对象头</p></blockquote><p><strong>存储结构</strong>[^引用]</p><p>synchronized 用的锁是存在 Java 对象头里的。</p><ul><li>如果对象是数组类型，则虚拟机用 3 个字宽（Word）存储对象头，</li><li>如果对象是非数组类型，则用 2 字宽存储对象头。</li></ul><p>在 32 位虚拟机中，1 字宽等于 4 字节</p><p><img src="https://s2.loli.net/2024/01/05/nyCAdFqBaKHr3DM.png" alt="dxt"></p><p>​Java 对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。32 位 JVM 的 Mark Word 的默认存储结构如图</p><p><img src="https://s2.loli.net/2024/01/05/F2KtSMHvkr8JsTU.png" alt="jg"></p><p>​在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化</p><p><img src="https://s2.loli.net/2024/01/05/F7n6iBSCPIdoWGa.png" alt="bh"></p><p>​在 64 位虚拟机下，Mark Word 是 64bit 大小</p><p><img src="https://s2.loli.net/2024/01/05/h8pE9Hq7XIWPJd3.png" alt="jg2"></p><p>[^引用]: <em>方腾飞 《Java并发编程的艺术》</em></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>开始时 Monitor 中 <code>Owner</code> 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner<br><strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 Mark Word 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）</li></ul><img src="https://s2.loli.net/2024/01/05/qso2ERkiYSAjFuf.png" alt="gzlc" style="zoom:67%;" /><ul><li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 <code>EntryList</code> BLOCKED </li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 <code>Owner</code> 为空，<strong>恢复 MarkWord 原来的数据</strong></li><li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，未得到锁的线程会继续阻塞</li><li><code>WaitSet</code> 中的 Thread-0，是以前获得过锁，但<strong>条件不满足</strong>进入 WAITING 状态的线程（wait-notify 机制）</li></ul><img src="https://s2.loli.net/2024/01/05/317oMOPWXdNeD6r.png" alt="gzlc2" style="zoom:67%;" /><p><strong>字节码角度分析</strong></p><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对应字节码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br> <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span><span class="hljs-comment">// &lt;- lock引用 （synchronized开始）</span><br> <span class="hljs-number">3</span>: dup<br> <span class="hljs-number">4</span>: astore_1  <span class="hljs-comment">// lock引用 -&gt; slot 1</span><br> <span class="hljs-number">5</span>: monitorenter <span class="hljs-comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span><br> <span class="hljs-number">6</span>: getstatic  #<span class="hljs-number">3</span><span class="hljs-comment">// &lt;- i</span><br> <span class="hljs-number">9</span>: iconst_1<span class="hljs-comment">// 准备常数 1</span><br><span class="hljs-number">10</span>: iadd <span class="hljs-comment">// +1</span><br><span class="hljs-number">11</span>: putstatic    #<span class="hljs-number">3</span><span class="hljs-comment">// -&gt; i</span><br><span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br><span class="hljs-number">15</span>: monitorexit <span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="hljs-number">16</span>: goto   <span class="hljs-number">24</span> <br><span class="hljs-number">19</span>: astore_2 <span class="hljs-comment">// e(异常) -&gt; slot 2</span><br><span class="hljs-number">20</span>: aload_1 <span class="hljs-comment">// &lt;- lock引用</span><br><span class="hljs-number">21</span>: monitorexit<span class="hljs-comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="hljs-number">22</span>: aload_2 <span class="hljs-comment">// &lt;- slot 2 (e) </span><br><span class="hljs-number">23</span>: athrow <span class="hljs-comment">// throw e</span><br><span class="hljs-number">24</span>: <span class="hljs-keyword">return</span> <br>Exception table:<br>    from to target type<br>       <span class="hljs-number">6</span>  <span class="hljs-number">9</span> <span class="hljs-number">19</span> any<br>      <span class="hljs-number">19</span> <span class="hljs-number">22</span> <span class="hljs-number">19</span> any<br>LineNumberTable: ...<br></code></pre></td></tr></table></figure><h3 id="4-CAS"><a href="#4-CAS" class="headerlink" title="4. CAS"></a>4. CAS</h3><blockquote><p>Compare And Swap，是CPU并发原语</p></blockquote><p><strong>原语</strong></p><ul><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以不会造成数据不一致的问题，是线程安全的</li><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li></ul><p><strong>与锁对比</strong></p><ul><li><p>使用锁时，线程获取锁是一种<strong>悲观锁策略</strong>，即假设每一次执行临界区代码都会产生冲突，<br>所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。</p></li><li><p>而CAS操作（又称为无锁操作）是一种<strong>乐观锁策略</strong>，它假设所有线程访问共享资源的时候不会出现冲突，<br>既然不会出现冲突自然而然就不会阻塞其他线程的操作。线程就不会出现阻塞停顿的状态。</p></li></ul><p>无锁操作是使用<strong>CAS</strong>又叫做比较交换来鉴别线程是否出现冲突，出现冲突就<strong>重试当前操作</strong>直到没有冲突为止</p><h4 id="CAS操作流程"><a href="#CAS操作流程" class="headerlink" title="CAS操作流程"></a>CAS操作流程</h4><blockquote><p>Java代码实现见第四、五章</p></blockquote><p>CAS的过程可以理解为比较交换**(V,O,N)**</p><ul><li><p>V 内存地址存放的<strong>实际值</strong></p></li><li><p>O 预期的值（<strong>旧值</strong>）</p></li><li><p>N 更新的<strong>新值</strong></p></li><li><p><strong>V和O相同时</strong><br>旧值和内存中实际的值相同，表明该值没有被其他线程更改过，即O就是目前来说最新的值了，可以将新值N赋值给V</p></li><li><p><strong>V和O不同时</strong><br>表明该值已经被其他线程改过了，则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可</p></li></ul><p>当多个线程使用CAS操作一个变量时，只有一个线程会成功，并成功更新，其余会失败<br>失败的线程会重新尝试，也可以选择挂起线程</p><p>当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做<strong>非阻塞同步</strong><br>不过，CAS的实现需要硬件指令集的支撑，在JDK1.5后虚拟机才可以使用处理器提供的<strong>CMPXCHG</strong>指令实现</p><p>结合CAS与volatile可以实现<strong>无锁并发</strong>，<strong>适用于线程数少，多核CPU的情况下</strong></p><ul><li>没有锁，线程不会阻塞，这是提高效率的原因之一</li><li>但如果线程太多，CPU核心少等导致竞争激烈，会平发生自旋，反而会影响效率</li><li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</li></ul><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><p><strong>ABA问题</strong></p><p>因为 CAS 需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，<br>但是如果一个值原来是 A，变成了 B，又变成了 A<br>那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><ul><li>解决方法</li></ul><p>使用版本号。在变量前面追加上版本号<br>每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A</p><p>所以当前线程执行CAS操作时，会发现版本号与线程一开始获取的不一样，就会放弃此次更新</p><p><strong>循环时间长开销大</strong></p><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销</p><ul><li>解决办法</li></ul><p>使用 CAS 线程数不要超过 CPU 的核心数，如果 JVM 能支持处理器提供的 pause 指令，那么效率会有一定的提升。</p><p>pause 指令 有两个作用：</p><ul><li>第一，它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li><li>第二， 它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起 CPU 流水线被清空（CPU Pipeline Flush），从而提高 CPU 的执行效率。</li></ul><p><strong>只能保证一个共享变量的原子操作</strong></p><p>当对一个共享变量执行操作时，我们可以使用 循环 CAS 的方式来保证原子操作，<br>但是对多个共享变量操作时，循环 CAS 就无法保证 操作的原子性</p><ul><li>解决办法</li></ul><p>使用锁，或将多个共享变量合并为一个共享变量来操作</p><p><strong>参考：《Java并发编程的艺术》方腾飞</strong></p><h3 id="5-synchronized优化原理"><a href="#5-synchronized优化原理" class="headerlink" title="5. synchronized优化原理"></a>5. synchronized优化原理</h3><blockquote><p>synchronized 锁是可重入，不公平的重量级锁</p></blockquote><p><strong>优化的顺序</strong></p><p><strong><code>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</code></strong></p><p><strong>注意</strong>：锁可以升级但<strong>不能降级</strong>，目的是为了提高获得锁和释放锁的效率</p><p><img src="https://s2.loli.net/2024/01/05/aZFWimHfGNT8V9w.webp" alt="ssj"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>当锁没有竞争时，每次重入都需要进行CAS操作，为了让线程获得锁的代价更低而引入了偏向锁</p></blockquote><ul><li><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储<strong>锁偏向的线程 ID</strong><br>以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁</p></li><li><p>当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</p></li></ul><img src="https://s2.loli.net/2024/01/05/d7UDzRm6oX5ILxe.png" alt="pxs" style="zoom:80%;" /><ul><li><p>对象创建时<strong>默认开启</strong>了偏向锁，MarkWord最后 3 位为 101，其余都为 0，处于<code>Biased</code>状态</p></li><li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 可以禁用偏向锁</p></li></ul><p>​<strong>注：</strong>偏向锁是默认是延迟的，不会在程序启动时立即生效，添加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟<br>​            JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有许多线程来竞争锁，立即开偏向锁效率反而降低</p><p><strong>偏向锁的撤销</strong></p><ul><li>当一个对象已经计算过 hashCode，会撤销偏向状态，且再也无法进入偏向状态</li><li>由上图可知，因为在<code>Biased</code>状态 MarkWord 无法存放 hashCode<ul><li>轻量级锁在锁记录中存放HashCode</li><li>重量级锁在Monitor中存放HashCode</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java">TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">synchronized</span> (o)&#123;<br>    <span class="hljs-comment">// 加锁后会在mark word 上记录ThreadID（由操作系统设置）</span><br>    log.debug(ClassLayout.parseInstance(o).toPrintable());<br>&#125;<br><span class="hljs-comment">// 解锁后mark word 上ThreadID 不会消失（体现了偏向锁的特性），除非发生特定情况</span><br>log.debug(ClassLayout.parseInstance(o).toPrintable());<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 如果计算对象的hashCode则会撤销对象的偏向状态</span><br>o1.hashCode();<br><span class="hljs-comment">// 因为在 Biased 状态下，Mark word 中没有存放HashCode的空间</span><br><span class="hljs-comment">// 而在 Normal 状态下 Mark Word 中存放了HashCode</span><br>log.debug(ClassLayout.parseInstance(o1).toPrintable());<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/05/Uo68NHvRnZaTl9b.png" alt="pxs2" style="zoom: 50%;" /><ul><li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p></li><li><p>调用 wait&#x2F;notify，需要申请 Monitor，也会撤销偏向锁</p></li></ul><p><strong>批量撤销</strong></p><blockquote><p>如果对象被多个线程访问且没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p></blockquote><ul><li><p>当虚拟机撤销偏向锁数量超过 阈值20 （批量重偏向）</p><ul><li><p>JVM 会给以后的对象加锁时<strong>重新偏向</strong>至加锁线程</p><blockquote><ul><li>先对30个对象用 T1线程 加锁</li><li>等 T1 线程运行完毕，T2线程再对这些对象获取锁</li><li>当T2 对象访问到第 20 个 (19 号) 时，JVM对剩余10个对象进行了重偏向</li></ul></blockquote><p><img src="https://s2.loli.net/2024/01/05/MRYoAq97TsJHQmx.png" alt="plcpx"></p></li></ul></li><li><p>当虚拟机撤销偏向锁数量超过 阈值40  （批量撤销）</p><ul><li>JVM 会对该类的所有对象都会变为不可偏向，新建的对象也是不可偏向</li></ul></li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p> 一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争）<br>可以使用轻量级锁来优化，轻量级锁对使用者是透明的</p></blockquote><p>如果多个线程存在竞争，则轻量级锁会变成重量级锁</p><ul><li><strong>可重入锁</strong><br>线程可以进入一个它已经拥有的锁的代码块，可重入锁最大的作用是<strong>避免死锁</strong><br>轻量级锁在锁重入时，每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</li></ul><p><strong>锁重入示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>    <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/05/ex5hHSyQmYWapOn.png" alt="sjl"></p><ul><li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</p></li><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁</p></li></ul><p><img src="https://s2.loli.net/2024/01/05/jHGnhrlDZ4UYWpu.png" alt="sjl2"></p><ul><li>如果 CAS 失败，有两种情况：<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入<strong>锁膨胀</strong>过程</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为<strong>重入的计数</strong></li></ul></li></ul><p><img src="https://s2.loli.net/2024/01/05/mGvVjBwiU4pRnHq.png" alt="sjl3"></p><ul><li>当退出 synchronized 代码块（解锁时）<ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果锁记录的值不为 null，这时使用 CAS 将 Mark Word 的值恢复给对象头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><blockquote><p>当某线程尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（出现竞争），<br>这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p></blockquote><ul><li>当 T1 进行轻量级加锁时，发现 T0 已经对该对象加了轻量级锁，出现竞争，开始锁膨胀</li></ul><p><img src="https://s2.loli.net/2024/01/05/EymPshi89gxCvkL.png" alt="spz"></p><ul><li>锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 T0，<br>将 Object 的对象头指向Monitor地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://s2.loli.net/2024/01/05/em1lsW2D5ZqjELM.png" alt="spz2"></p><ul><li>当 T0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程<br>即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h4 id="锁自旋"><a href="#锁自旋" class="headerlink" title="锁自旋"></a>锁自旋</h4><blockquote><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化<br>采用循环的方式去尝试获取锁</p></blockquote><ul><li><p>自旋占用 CPU 时间，同一时刻只能运行一个线程，只有多核 CPU 自旋才能发挥优势</p></li><li><p>自旋失败后会进入阻塞状态</p></li></ul><center>自旋成功</center><img src="https://s2.loli.net/2024/01/05/HvArSsU56yYdZRE.png" alt="szx" style="zoom:67%;" /><center>自旋失败</center><img src="https://s2.loli.net/2024/01/05/rNmWFGkXlutgIqT.png" alt="szx2" style="zoom:67%;" /><ul><li>在 Java 6 之后自旋锁是自适应的<ul><li>如果在同一个锁上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，<strong>会自动增加等待时间</strong>这种机制可以使JVM对程序的锁的状态预测更加准确，从而提高并发性能</li></ul></li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><blockquote><p>若JVM检测到一个共享数据不会被多个线程访问时，会对锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p></blockquote><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，<br>那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除</p><ul><li><code>-XX:-EliminateLocks</code>：通过设置此VM参数可以关闭JVM的锁消除</li></ul><h3 id="6-多把锁"><a href="#6-多把锁" class="headerlink" title="6. 多把锁"></a>6. 多把锁</h3><blockquote><p> 多把不相干的锁，细分管理资源</p></blockquote><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigRoom</span> <span class="hljs-variable">bigRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigRoom</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; bigRoom.study()).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; bigRoom.sleep()).start();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigRoom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">sleepRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (sleepRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote><p>多个线程同时被阻塞，其中每个线程都在等待其他线程占用的锁，导致程序无法正常运行</p></blockquote><p>操作系统中，死锁产生的条件</p><ul><li><p><strong>互斥条件</strong>，即当资源被一个线程使用（占有）时，别的线程不能使用</p></li><li><p><strong>不可剥夺条件</strong>，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</p></li><li><p><strong>请求和保持条件</strong>，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</p></li><li><p><strong>循环等待条件</strong>，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</p></li></ul><p>当四个条件都满足时，则会出现死锁情况，打破任一条件即可解除死锁</p><ul><li><p>代码演示死锁情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-comment">// 线程1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (A)&#123;<br><br>                log.debug(<span class="hljs-string">&quot;线程1获取到A锁&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 休眠1s使线程2先获取到B锁</span><br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (B)&#123;<br>                    log.debug(<span class="hljs-string">&quot;线程1获取到B锁&quot;</span>);<br>                    log.debug(<span class="hljs-string">&quot;线程1开始执行任务&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;T1&quot;</span>).start();<br><br>        <span class="hljs-comment">// 线程2</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (B)&#123;<br>                log.debug(<span class="hljs-string">&quot;线程2获取到B锁&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 休眠1s使线程1先获取到A锁</span><br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (A)&#123;<br>                    log.debug(<span class="hljs-string">&quot;线程2获取到A锁&quot;</span>);<br>                    log.debug(<span class="hljs-string">&quot;线程2开始执行任务&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;T2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>死锁的检测和定位</strong></p><ul><li><strong>使用JPS定位进程ID，再使用jstack id定位死锁</strong></li></ul><p><img src="https://s2.loli.net/2024/01/08/4Md5BNCUiQfzPex.png" alt="dead"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmd">Found one Java-level deadlock:<br>=============================<br>&quot;T2&quot;:<br>  waiting to lock monitor <span class="hljs-number">0</span>x000002829a1765a8 (object <span class="hljs-number">0</span>x00000000d9927c38, a java.lang.Object),<br>  which is held by &quot;T1&quot;<br>&quot;T1&quot;:<br>  waiting to lock monitor <span class="hljs-number">0</span>x000002829a174298 (object <span class="hljs-number">0</span>x00000000d9927c48, a java.lang.Object),<br>  which is held by &quot;T2&quot;<br><br></code></pre></td></tr></table></figure><ul><li><strong>使用Jconsole</strong></li></ul><img src="https://s2.loli.net/2024/01/08/N9we6PBTW3MKHrZ.png" alt="dead2" style="zoom:50%;" /><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><blockquote><p>指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p></blockquote><ul><li>两个线程相互改变对方的结束条件，导致都无法结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveLock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count:&#123;&#125;&quot;</span>,count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;T1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count:&#123;&#125;&quot;</span>,count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;T2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><blockquote><p>一个线程由于某些情况，始终得不到 CPU 调度执行，也不能够结束</p></blockquote><p>例如：</p><ul><li>资源竞争：多个线程同时竞争有限的资源。</li><li>锁的不公平性：某些线程优先获得锁资源，导致其他线程无法获得。</li><li>优先级反转：低优先级线程长时间占用资源，导致高优先级线程无法获取。</li><li>资源过度分配：某些线程得不到足够的资源。</li></ul><h3 id="7-wait-notify"><a href="#7-wait-notify" class="headerlink" title="7. wait-notify"></a>7. wait-notify</h3><p><strong>相关API</strong></p><ul><li><strong><code>public final void notify()</code></strong> <ul><li>唤醒正在等待对象Monitor中的一个线程</li><li>唤醒是<strong>随机的</strong>，可能存在唤醒<strong>非目标线程</strong>的情况</li></ul></li><li><strong><code>public final void notifyAll()</code></strong> <ul><li>唤醒正在等待对象Monitor的所有线程</li><li>推荐使用</li></ul></li><li><strong><code>public final void wait()</code></strong><ul><li>使当前线程等待并进入Monitor的WaitSet中,直到被另一个线程唤醒</li></ul></li><li><strong><code>public final native void wait(long timeout)</code></strong> <ul><li>有时限的等待, 到n毫秒后结束等待，或是被唤醒</li></ul></li></ul><p><strong>注意：</strong></p><ul><li><p>当该线程获取锁对象，成为Owner时才能调用以上方法</p></li><li><p><strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以竞争锁，挂起的线程需要唤醒后竞争锁</p></li></ul><p><img src="https://s2.loli.net/2024/01/07/OuhFA12PaftqjKN.png" alt="wn"></p><p><strong>执行流程</strong></p><ul><li><p>当某对象的Owner线程发现因为某条件不足时，可以调用<code>wait</code>方法<strong>进入该对象Monitor的WaitSet中</strong>，并变为<code>WAITING</code>状态</p></li><li><p>此时该线程会释放锁资源，并等待被其他线程唤醒</p></li><li><p>此后获得锁对象的线程可以通过 <code>notify() 或 notifyAll()</code> 唤醒 WaitSet 中的线程，唤醒后进入EntryList 重新竞争锁</p></li></ul><p><strong>wait 与 sleep 对比</strong></p><ul><li><strong>对象不同</strong><ul><li><code>sleep()</code> 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把CPU让给其他线程</li><li><code>wait()</code> 方法属于 Object 类，用于线程间通信，也会让出CPU</li></ul></li><li><strong>处理机制不同</strong><ul><li>调用 <code>sleep()</code> 方法的过程中，线程<strong>不会释放对象锁</strong></li><li>当调用 <code>wait()</code> 方法的时候，线程会释放对象锁，且进入该对象Monitor的WaitSet中等待被唤醒</li></ul></li><li><strong>使用条件不同</strong><ul><li><code>wait()</code> 方法必须<strong>先获取锁（在同步代码块中）</strong>才能使用</li><li><code>sleep()</code> 方法则可以放在任何地方使用</li></ul></li></ul><h3 id="8-Park-Unpark"><a href="#8-Park-Unpark" class="headerlink" title="8. Park &amp; Unpark"></a>8. Park &amp; Unpark</h3><blockquote><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p></blockquote><ul><li><p><code>LockSupport.park()</code>：暂停当前线程，挂起原语</p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    setBlocker(t, blocker);<br>    UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    setBlocker(t, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>        UNSAFE.unpark(thread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>LockSupport 出现就是为了<strong>增强</strong> wait &amp; notify 的功能：   </p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p><strong>使用方法</strong></p><ul><li><p>先 park</p><p><img src="https://s2.loli.net/2024/01/08/QZs8SR3qPwi6eET.png" alt="park"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，此时情况为 0，则获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起 </li><li>调用 Unsafe.unpark(Thread-0) ，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread-0 恢复运行，设置 _counter 为 0</li></ol></li><li><p>先unpark</p><p><img src="https://s2.loli.net/2024/01/08/UYuQD37zocgK5mI.png" alt="unpark"></p><ol><li><p>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</p></li><li><p>当前线程调用 Unsafe.park() 方法</p></li><li><p>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，且设置 _counter 为 0</p></li></ol></li></ul><h3 id="9-同步模式"><a href="#9-同步模式" class="headerlink" title="9. 同步模式"></a>9. 同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><blockquote><p>Guarded Suspension，用于一个线程等待另一个线程的执行结果</p></blockquote><ul><li>当一个线程的结果需要传递到另一个线程，可以它们关联同一个 <code>GuardedObject</code></li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><strong>一对一模式</strong></p><p><img src="https://s2.loli.net/2024/01/08/Fn5PtEsvcUehZxm.png" alt="ydy"></p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer id;<br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuardedObject</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br><br>            <span class="hljs-comment">// 记录开始时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// 判断是否由返回结果</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 计算还需等待的时间 （预防被其他线程虚假唤醒）</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 不用timeout因为可能在超时之前被其他 非目标线程 唤醒，导致没有等待足够的时间</span><br>                    <span class="hljs-built_in">this</span>.wait(waitTime); <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 计算循环等待的时间（因为存在被其他线程虚假唤醒的可能）</span><br>                passedTime = System.currentTimeMillis() - begin;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果并赋值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-comment">// 唤醒等待的线程</span><br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模拟一个线程等待另一线程下载的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Download</span> &#123;<br>    <span class="hljs-comment">// 线程1 等待 线程2下载的结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;等待下载结果&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">3000</span>);<br>            log.debug(<span class="hljs-string">&quot;下载结果:&#123;&#125;&quot;</span>, response);<br>        &#125;, <span class="hljs-string">&quot;T1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始下载任务&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            guardedObject.complete(o);<br>            log.debug(<span class="hljs-string">&quot;下载完成&quot;</span>);<br><br>        &#125;, <span class="hljs-string">&quot;T2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;虚假唤醒T1&quot;</span>);<br>            guardedObject.complete(<span class="hljs-literal">null</span>);<br><br>        &#125;, <span class="hljs-string">&quot;T3&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><img src="https://s2.loli.net/2024/01/08/rOIpVNYG1fX4KtR.png" alt="ydy-r" style="zoom:67%;" /><p><strong>多对多模式</strong></p><img src="https://s2.loli.net/2024/01/08/BX5TLhfuGizySZ7.png" alt="ddd" style="zoom:67%;" /><ul><li><p>创建一个<code>MutiGO</code>对象来管理多个<code>GuardedObject</code></p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutiGO</span> &#123;<br>    <span class="hljs-comment">// Hashtable 线程安全</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; GOboxs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title function_">genId</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> ++id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-comment">// 设当前环境下，取出后删除</span><br>        <span class="hljs-keyword">return</span>  GOboxs.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">genGuardedObject</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(genId());<br>        GOboxs.put(id, guardedObject);<br>        <span class="hljs-keyword">return</span> guardedObject;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> GOboxs.keySet();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模拟邮递员送信</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        log.debug(<span class="hljs-string">&quot;开始收信&quot;</span>);<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> MutiGO.genGuardedObject();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> guardedObject.getId();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;收到信id:&#123;&#125;,内容&#123;&#125;&quot;</span>, id,mail);<br><br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Postman&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String mail)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> MutiGO.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信id:&#123;&#125;,内容&#123;&#125;&quot;</span>,id,mail);<br>        guardedObject.complete(mail);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>设三个邮箱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">3</span>; i++)&#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();<br>    &#125;<br>    Set&lt;Integer&gt; ids = MutiGO.getIds();<br>    ids.forEach(id -&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id,<span class="hljs-string">&quot;你好&quot;</span>+id).start());<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/01/08/9eJiplfTEsgZmQ8.png" alt="ddd-r" style="zoom:67%;" /><h3 id="10-异步模式"><a href="#10-异步模式" class="headerlink" title="10. 异步模式"></a>10. 异步模式</h3><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><p><img src="https://s2.loli.net/2024/01/08/UEeIzHwnLDdZrYu.png" alt="yb"></p><ul><li><p>消息队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</p></li><li><p>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p></li><li><p>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p></li><li><p>JDK 中各种阻塞队列，采用的就是这种模式</p></li><li><p>代码实现</p><ul><li><p>消息对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object msg;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, msg=&quot;</span> + msg +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Message&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                log.debug(<span class="hljs-string">&quot;队列已满,生产者等待&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addLast(message);<br>            <span class="hljs-comment">// 唤醒消费者</span><br>            queue.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                log.debug(<span class="hljs-string">&quot;队列为空,消费者等待&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            <span class="hljs-comment">// 唤醒生产者</span><br>            queue.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMQ</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                    mq.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id, <span class="hljs-string">&quot;消息&quot;</span> + id));<br>                    log.debug(<span class="hljs-string">&quot;生产者&#123;&#125; 生产消息&#123;&#125;&quot;</span>, id,id);<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-keyword">new</span>  <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> mq.get();<br>                log.debug(<span class="hljs-string">&quot;消费者 消费消息&#123;&#125;&quot;</span>, message.toString());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结果</p></li></ul><img src="https://s2.loli.net/2024/01/14/saQfPK4MhIqgnko.png" alt="yb-r" style="zoom:80%;" /><h3 id="11-ReentrantLock"><a href="#11-ReentrantLock" class="headerlink" title="11. ReentrantLock"></a>11. ReentrantLock</h3><blockquote><p>ReentrantLock重入锁，是实现Lock接口的一个类，在实际编程中使用频率很高<br><strong>基于AQS实现，原理见第八章</strong></p></blockquote><ul><li><p><strong>可重入性</strong></p><ul><li>表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞</li><li>Java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。</li></ul></li><li><p><strong>公平与非公平锁</strong></p><ul><li>ReentrantLock默认为非公平锁</li><li>设置为公平锁后，满足阻塞队列先进先出（FIFO）原则调度线程</li></ul></li><li><p><strong>可打断性</strong></p><ul><li>在等待锁状态的线程能被 Interrupt() 打断</li></ul></li><li><p><strong>超时等待</strong></p><ul><li>使用 tryLock() 可以在获取锁失败后使线程不进入等待</li><li>使用tryLock(long timeout , TimeUnit unit ) 可以设置超时等待时间</li></ul></li><li><p><strong>条件变量（Condition）</strong></p><ul><li>跟据多个条件变量可以设置多个等待(waitSet)队列</li></ul></li></ul><p><strong>使用语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>&#123;<br>    lock.lock();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>lock() 与 unlock() 需成对出现</p><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><ul><li><p>在线程获取锁的时如果当前线程已经获得该锁，则直接再次获取成功</p></li><li><p>锁会被获取n次，只有锁在被释放n次之后，该锁才算是完全释放成功</p></li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 可重入性</span><br>       m1();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;进入 m1&quot;</span>);<br>            m2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;进入 m2&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<br><strong>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，满足FIFO</strong></p><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 默认空参构造器为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><span class="hljs-comment">// 当参数为 true 时创建公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>与非公平锁对比</strong></p><ul><li><p>公平锁每次获取到锁为同步队列中的第一个节点，<strong>保证请求资源时间上的绝对顺序</strong></p></li><li><p>非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</p></li><li><p>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换</p></li><li><p>而非公平锁会降低一定的上下文切换，降低性能开销。</p><ul><li>因此ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</li></ul></li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptibility</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);<br>            <span class="hljs-comment">// 如没有线程竞争锁，此方法就会获取到锁</span><br>            <span class="hljs-comment">// 如果有其他线程竞争锁，就会进入阻塞队列。可被其他线程调用 interrupt 打断</span><br>            lock.lockInterruptibly();<br>            <span class="hljs-comment">//lock.lock(); // 使用lock() 则无法被打断，会一直等待锁</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            log.debug(<span class="hljs-string">&quot;被打断，未获取到锁&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;);<br>    lock.lock();<br>    t1.start();<br><br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;打断t1&quot;</span>);<br>    t1.interrupt();<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>运行结果</strong></p><p><img src="https://s2.loli.net/2024/01/14/wmFMbQs1WlfxcSj.png" alt="kdd"></p></li></ul><h4 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h4><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timeoutLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;尝试获取锁&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// tryLock() 也能被Interrupt打断</span><br>            <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                log.debug(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            log.debug(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;获取到锁&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 设主线程先获取到锁</span><br>    lock.lock();<br>    log.debug(<span class="hljs-string">&quot;主线程获取到锁&quot;</span>);<br>    t1.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>运行结果</strong></p><p>等待 1s 后自动结束</p><p><img src="https://s2.loli.net/2024/01/14/ESYzrPDgR6uJNnM.png" alt="scs"></p></li></ul><h4 id="条件变量Condition"><a href="#条件变量Condition" class="headerlink" title="条件变量Condition"></a>条件变量Condition</h4><blockquote><p>实现原理见第八章</p></blockquote><p>在线程间实现通信时往往会应用到Object的几个方法，比如wait(),notify()等几个方法实现等待&#x2F;通知机制。<br>而在java Lock体系下依然会有同样的方法实现等待&#x2F;通知机制。</p><p>从整体上来看<strong>Object的wait和notify是与对象监视器配合完成线程间的等待&#x2F;通知机制，而Condition与是Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。</p><ol><li>Condition能够支持不响应中断，而通过使用Object方式不支持；</li><li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；</li><li>Condition能够支持超时时间的设置，而Object不支持</li></ol><p><strong>Condition中等待与通知的方法</strong></p><p><strong>等待</strong></p><ol><li><code>void await() throws InterruptedException</code>：获取到锁后调用，使当前线程进入等待状态，此时被中断会抛出被中断异常</li><li><code>long awaitNanos(long nanosTimeout)</code>：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</li><li><code>boolean await(long time, TimeUnit unit)throws InterruptedException</code>：同第二种，支持自定义时间单位</li><li><code>boolean awaitUntil(Date deadline) throws InterruptedException</code>：当前线程进入等待状态直到被通知，中断或者<strong>到了设定时间</strong></li></ol><p><strong>通知</strong></p><ol><li><code>void signal()</code>：唤醒一个等待在condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步（阻塞）队列</strong>中，如果在同步队列中能够竞争到锁则可以从等待方法中返回</li><li><code>void signalAll()</code>：唤醒所有等待在condition上的线程</li></ol><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">ROOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitASet</span> <span class="hljs-operator">=</span> ROOM.newCondition();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitBSet</span> <span class="hljs-operator">=</span> ROOM.newCondition();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">hasA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">hasB</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 需要A资源的线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;线程A尝试获取资源A...&#123;&#125;&quot;</span>, hasA);<br>                <span class="hljs-keyword">while</span> (!hasA) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取失败，进入A资源等待队列...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitASet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;线程A获取到资源A,开始执行任务...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-comment">// 需要B资源的线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;线程B尝试获取资源B...&#123;&#125;&quot;</span>, hasB);<br>                <span class="hljs-keyword">while</span> (!hasB) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取失败，进入B资源等待队列...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitBSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;线程B获取到资源B,开始执行任务...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 提供A资源线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;释放A资源，唤醒A资源等待队列...&quot;</span>);<br>                hasA = <span class="hljs-literal">true</span>;<br>                waitASet.signalAll();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;C&quot;</span>).start();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 提供B资源线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;释放B资源，唤醒B资源等待队列...&quot;</span>);<br>                hasB = <span class="hljs-literal">true</span>;<br>                waitBSet.signalAll();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;D&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><img src="https://s2.loli.net/2024/01/14/YOLDJymk2rWRcNA.png" alt="condition" style="zoom:80%;" /><h2 id="四、Java内存模型-JMM"><a href="#四、Java内存模型-JMM" class="headerlink" title="四、Java内存模型-JMM"></a>四、Java内存模型-JMM</h2><blockquote><p>Java 内存模型是 Java Memory Model（JMM）</p></blockquote><p>本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范<br>通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>Java <strong>线程之间的通信</strong>由 JMM控制，其决定一个线程对共享变量的写入<strong>何时</strong>对另一个线程可见。</p><p>JMM 定义了线程和主内存之间的抽象关系：</p><ul><li>线程之间的共享变量存储在主内存（Main Memory）中，每个线 程都有一个私有的本地内存（Local Memory）<br>本地内存中存储了该线程以读&#x2F;写共享变 量的副本。</li><li>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲 区、寄存器以及其他的硬件和编译器优化。</li></ul><img src="https://s2.loli.net/2024/01/15/3ILxmrJvot78RjZ.png" alt="jmm" style="zoom:67%;" /><h3 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1. 三大特性"></a>1. 三大特性</h3><blockquote><p>在线程安全问题中存在三条性质分别是，原子性，可见性，有序性</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>。<br>在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p></blockquote><p>在JMM中定义了8种原子操作</p><ol><li><code>lock（锁定）</code>：作用于<strong>主</strong>内存中的变量，它把一个变量标识为一个线程独占的状态；</li><li><code>unlock（解锁）</code>:作用于<strong>主</strong>内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li><code>read（读取）</code>：作用于<strong>主</strong>内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；</li><li><code>load（载入）</code>：作用于<strong>工作</strong>内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本</li><li><code>use（使用）</code>：作用于<strong>工作</strong>内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</li><li><code>assign（赋值）</code>：作用于<strong>工作</strong>内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</li><li><code>store（存储）</code>：作用于<strong>工作</strong>内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；</li><li><code>write（写入）</code>：作用于<strong>主</strong>内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ol><p><img src="https://s2.loli.net/2024/01/15/CORitLxXYGAHBUK.png" alt="yzx"></p><p>注意：由原子性变量操作read,load,use,assign,store,write，可以<strong>大致认为基本数据类型的访问读写具备原子性</strong><br>（例外就是没有加volatile的long和double的非原子性协定）</p><p>已6条可以满足基本数据类型的访问读写具备原子性<br>如果我们需要<strong>更大范围的原子性操作</strong>就可以使用lock和unlock原子操作。</p><p><strong>JVM种lock和unlock没有开放使用</strong>，但更高层次的指令<code>monitorenter</code>和<code>monitorexit</code>指令开放使用</p><p>即java代码中的<strong>synchronized满足原子性</strong></p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p></blockquote><p>存在不可见问题的根本原因是由于缓存（工作内存）的存在</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visuality</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(run)&#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;T1&quot;</span>).start();<br><br>        log.debug(<span class="hljs-string">&quot;停止T1&quot;</span>);<br>        run = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>此时主线程将 run 值修改并不会使线程 T1 停止 （此次修改在两个线程中出现不可见问题）</li></ul><p><img src="https://s2.loli.net/2024/01/15/WyAVE8azU2qGONY.png" alt="kjx"></p><ul><li>因为当 T1 线程频繁的访问共享变量 run 时，JIT（即时编译器）会将 run 的值缓存至该线程的工作内存中，以减少对主存的访问提高效率</li></ul><p><strong>解决方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加volatile关键字，使线程每一次都从主存中获取变量，此时变量在多个线程中可见</span><br><span class="hljs-comment"> * 不加volatile关键字，线程会从自己的工作内存中获取变量，导致线程不可见</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li>在 run 上添加 volatile 关键字使线程每一次都从主存中获取该变量</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>指令的有序性是指在多线程环境下，对共享变量进行操作或访问时的执行顺序问题。</p></blockquote><p>Java使用了一些优化技术，例如指令重排序和缓存一致性来提高执行效率。<br>指令重排序是指在不改变程序结果的前提下，改变指令的执行顺序以提高性能。<br>但它们也引入了可见性和有序性问题。</p><p>CPU 的基本工作是执行存储的指令序列，执行的过程实际上是不断地取出指令、分析指令、执行指令的过程<br>为了提高性能，编译器和处理器会对指令重排，例如：</p><p><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></p><p>现代 CPU 支持多级指令流水线，其工作都可以分为 5 个阶段：</p><p><code>取指令、指令译码、执行指令、访存取数、结果写回</code></p><ul><li>instruction fetch (IF)</li><li>instruction decode (ID)</li><li>execute (EX)</li><li>memory access(MEM)</li><li>register write back (WB)</li></ul><p><img src="https://s2.loli.net/2024/01/15/l6gjxM4uAi2sN7k.png" alt="lsx"></p><p>当CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>称之为<strong>五级指令流水线</strong>，提高了CPU的吞吐率</p><p><img src="https://s2.loli.net/2024/01/15/uYeTH3G6AnCFbSr.png" alt="lsx2"></p><p>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</p><p><strong>代码示例</strong></p><p><img src="https://s2.loli.net/2024/01/15/BRLZNcxz8lKk9Cn.png" alt="yxx"></p><ul><li>上图代码中，正常情况下应只有两种结果 1 ，4 但因存在指令重排，在多线程下还会存在结果为 0 的情况</li></ul><img src="https://s2.loli.net/2024/01/15/YxOp26mfK3GRNBC.png" alt="yxxr" style="zoom:67%;" /><ul><li>因为重排序，导致线程2中可能存在，先将 ready 赋值，再将 num 赋值<br>而再多线程下，另一线程可能再num赋值之前，获取了ready的值，导致结果为 0</li></ul><h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h3><blockquote><p>volatile是java虚拟机提供的最轻量级的同步机制</p></blockquote><p><strong>特性</strong></p><ul><li>保证可见性：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值</li><li>保证有序性：设置屏障禁止指令重排</li><li>不保证原子性</li></ul><p>与synchronized对比：synchronized <strong>无法禁止指令重排和处理器优化</strong>，但可以保证有序性可见性</p><ul><li>加锁后，同一时间只有一个线程执行临界区代码，指令重排但结果不会改变</li><li>加锁前，线程会<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值<br>解锁前，会把共享变量的最新值<strong>刷新到主内存</strong>中</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定</p><ul><li>将当前处理器缓存的数据写回系统内存</li><li>这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效</li><li>当处理器发现本地缓存失效后，就会从主存中重读该共享变量数据，即可以获取当前最新值</li></ul><p>lock 前缀指令就相当于<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><img src="https://s2.loli.net/2024/01/15/q9X5ClYnQgw3bhE.png" alt="ncpz" style="zoom:67%;" /><ul><li>在每个volatile写操作的<strong>前面</strong>插入一个StoreStore屏障；</li><li>在每个volatile写操作的<strong>后面</strong>插入一个StoreLoad屏障；</li><li>在每个volatile读操作的<strong>后面</strong>插入一个LoadLoad屏障；</li><li>在每个volatile读操作的<strong>后面</strong>插入一个LoadStore屏障。</li></ul><p><strong>注意</strong>：volatile写是在前面和后面<strong>分别插入内存屏障</strong>，而volatile读操作是在<strong>后面插入两个内存屏障</strong></p><ul><li><p>写屏障（Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><ul><li><strong>StoreStore屏障</strong>：禁止上面的普通写和下面的volatile写重排序；</li><li><strong>StoreLoad屏障</strong>：禁止上面的volatile写与下面可能有的volatile读&#x2F;写重排序</li></ul><img src="https://s2.loli.net/2024/01/15/ea5KDvgQi3BwzNS.png" alt="xpz" style="zoom:80%;" /></li><li><p>读屏障（Load Barrier）保证在该屏障之后的，对共享变量的读取，都是主存中最新数据</p><ul><li><strong>LoadLoad屏障</strong>：禁止下面所有的普通读操作和上面的volatile读重排序</li><li><strong>LoadStore屏障</strong>：禁止下面所有的普通写操作和上面的volatile读重排序</li></ul><img src="https://s2.loli.net/2024/01/15/MwA9WB5JP7opfO4.png" alt="dpz" style="zoom:80%;" /></li></ul><p><strong>保证可见性</strong></p><ul><li><p>写屏障（Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p></li><li><p>读屏障（Load Barrier）保证在该屏障之后的，对共享变量的读取，都是主存中最新数据</p></li></ul><p><strong>保证有序性</strong></p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>    r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 写屏障</span><br>    ready = <span class="hljs-literal">true</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/15/9RHNC24AlWOFSgd.png" alt="bzkjx"></p><p><strong>不能解决指令交错的问题（不保证原子性）</strong></p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">volatile</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;i++&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;i--&#125;);<br><br><br><span class="hljs-comment">// i++ 字节码指令</span><br><span class="hljs-number">0</span>: iconst_1<span class="hljs-comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span><br><span class="hljs-number">1</span>: istore_1<span class="hljs-comment">// 将操作数栈顶数据弹出，存入局部变量表的 slot 1</span><br><span class="hljs-number">2</span>: iinc<span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/15/owacSkHDPyOJF2V.png" alt="bbzyzx"></p><h4 id="双端检锁-DCL"><a href="#双端检锁-DCL" class="headerlink" title="双端检锁-DCL"></a>双端检锁-DCL</h4><blockquote><p>Double-Checked Locking：双端检锁机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里线程不安全，在临界区指令重排后，可能会先使INSTANCE != null,再构造对象赋值</span><br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 首次访问会同步，之后使用不会上锁</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <br>                    <span class="hljs-comment">// 这里会产生指令重排</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><p><strong>DCL指令重排问题</strong></p><p><code>getInstance()</code> 方法对应的字节码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcom/kongke/jmm/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class com/kongke/jmm/Singleton</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcom/kongke/jmm/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class com/kongke/jmm/Singleton 创建对象，将对象引用入栈</span><br><span class="hljs-number">20</span>: dup<span class="hljs-comment">// 复制一份对象引用，引用地址</span><br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V 利用一个对象引用，调用构造方法初始化对象</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcom/kongke/jmm/Singleton; 利用一个对象引用，赋值给 static INSTANCE</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcom/kongke/jmm/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，<strong>因此这种重排优化是允许的</strong></p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化<br>那么其拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://s2.loli.net/2024/01/15/q3r4v8TEC7yXMzL.png" alt="dcl"></p><p><strong>解决办法</strong></p><p>将共享变量加上 volatile 修饰，禁止读写操作时的指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>此时，指令操作中，赋值操作就不会先于构造操作</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><blockquote><p><strong>JMM可以通过happens-before(先行发生)关系向程序员提供跨线程的内存可见性保证</strong></p></blockquote><p>JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。</p><p><strong>具体的定义为</strong></p><ol><li><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见<br>而且第一个操作的执行顺序排在第二个操作之前。</p></li><li><p>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行<br>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法<br>(也就是说，JMM允许这种重排序)</p></li></ol><p><strong>其中</strong></p><ul><li><p><strong>1是JMM对程序员的承诺</strong></p></li><li><p><strong>2是JMM对编译器和处理器重排序的约束原则</strong>。<br>JMM遵循一个基本原则：只要不改变程序的执行结果编译器和处理器怎么优化都行。<br>原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变<br>(即执行结果不能被改变)</p></li></ul><p><strong>具体的六项规则</strong></p><ol><li><code>程序顺序规则(Program Order Rule)</code>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><code>监视器锁规则(Monitor Lock Rule)</code>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><code>volatile变量规则(Volatile Variable Rule)</code>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><code>传递规则(Transitivity)</code>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><code>start()规则 (Thread Start Rule)</code>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><code>join()规则(Thread Termination Rule)</code>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li><code>程序中断规则(Thread Interruption Rule)</code>：对线程interrupted()方法的调用happens-before被中断线程的代码检测到中断时间的</li><li><code>对象finalize规则(Finaizer Rule)</code>：一个对象的初始化完成（构造函数执行结束）happens-before它的finalize()方法的开始。</li></ol><h4 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h4><p><strong>无锁方式实现线程安全</strong></p><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AccountLock</span> <span class="hljs-variable">accountLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountLock</span>(<span class="hljs-number">10000</span>);<br>        Account.demo(accountLock);<br><br>        <span class="hljs-type">AccountCas</span> <span class="hljs-variable">accountCas</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountCas</span>(<span class="hljs-number">10000</span>);<br>        Account.demo(accountCas);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountCas</span><span class="hljs-params">(Integer balance)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 取当前值（该线程认为的预期值）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 计算出新的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">/* cas操作</span><br><span class="hljs-comment">            * 1. 操作时会再在主存中取一次当前balance的值（当前实际值）</span><br><span class="hljs-comment">            * 2. 比较当前线程认为的预期值（prev）和当前实际值是否相等</span><br><span class="hljs-comment">            * 3. 相等说明此线程是最新来修改的线程，修改成功 返回true</span><br><span class="hljs-comment">            * 4. 不相等说明有其他线程已经修改了balance，当前线程认为的预期值已经失效，需要重新获取预期值，并再次进入循环</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> balance.compareAndSet(prev, next);<br>            <span class="hljs-keyword">if</span> (res)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountLock</span> <span class="hljs-params">(Integer balance)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        balance -= amount;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Account</span> &#123;<br>    Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Account account)</span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 创建1000个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; account.withDraw(<span class="hljs-number">10</span>)));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 全部启动</span><br>        ts.forEach(Thread::start);<br>        <span class="hljs-comment">// 等待全部完成</span><br>        ts.forEach(t-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;总耗时：&quot;</span>+(end-start)+<span class="hljs-string">&quot;ms , 剩余余额：&quot;</span>+account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行结果，无锁方式效率优于加锁方式，当多次执行时，由于JVM的优化，出现的对比会更加明显</p><p><img src="https://s2.loli.net/2024/01/16/l8mtpLIFycDjM9r.png" alt="cas"></p></li><li><p>分析</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 取当前值（该线程认为的预期值）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 计算出新的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">/* cas操作</span><br><span class="hljs-comment">            * 1. 操作时会再在主存中取一次当前balance的值（当前实际值）</span><br><span class="hljs-comment">            * 2. 比较当前线程认为的预期值（prev）和当前实际值是否相等</span><br><span class="hljs-comment">            * 3. 相等说明此线程是最新来修改的线程，修改成功 返回true</span><br><span class="hljs-comment">            * 4. 不相等说明有其他线程已经修改了balance，当前线程认为的预期值已经失效，需要重新获取预期值，并再次进入循环</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> balance.compareAndSet(prev, next);<br>            <span class="hljs-keyword">if</span> (res)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>CAS操作时序图为</p><p><img src="https://s2.loli.net/2024/01/16/lzuvCRZQaBcSste.png" alt="cassxt"></p><ul><li>使用CAS方式时，使用的AtomicInteger其中value是用volatile修饰的，来保证多线程间的可见性，使CAS操作能每次都获取到变量的最新值</li><li>且由于AtomicInteger中CAS的原子操作，保证了线程安全，不会出现数据脏读现象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 部分源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><h2 id="五、原子操作"><a href="#五、原子操作" class="headerlink" title="五、原子操作"></a>五、原子操作</h2><blockquote><p>原子操作（atomic  operation）意为“不可被中断的一个或一系列操作”</p></blockquote><p>由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案</p><p>在JUC下的Atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类<br>去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型<br>Atomic 包里的类基本都是使用 <strong>Unsafe 实现的包装类</strong></p><p>Atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在Java中则是使用CAS实现原子操作</p><p><strong>Atomic包提供的常见原子类</strong></p><ol><li>AtomicBoolean：以原子更新的方式更新boolean；</li><li>AtomicInteger：以原子更新的方式更新Integer;</li><li>AtomicLong：以原子更新的方式更新Long；</li></ol><p><strong>原子更新引用类型变量</strong>，atomic也提供了相关的类：</p><ol><li>AtomicReference：原子更新引用类型</li><li>AtomicStampedReference：原子更新带有版本号的引用类型</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ol><p>atomic包下提供能<strong>原子更新数组</strong>中元素的类有：</p><ol><li>AtomicIntegerArray：原子更新整型数组中的元素；</li><li>AtomicLongArray：原子更新长整型数组中的元素；</li><li>AtomicReferenceArray：原子更新引用类型数组中的元素</li></ol><p>更新对象的<strong>某个字段</strong>，atomic提供了相应的原子操作类：</p><ol><li>AtomicIntegeFieldUpdater：原子更新整型字段类；</li><li>AtomicLongFieldUpdater：原子更新长整型字段类；</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ol><p>原子<strong>累加器</strong>类：</p><ol><li>LongAdder：用于对long类型变量进行原子更新和累加操作。</li><li>DoubleAdder：用于对double类型变量进行原子更新和累加操作。</li><li>LongAccumulator：通用的线程安全的累加器，可对long类型变量进行原子更新和自定义累加操作。</li><li>DoubleAccumulator：通用的线程安全的累加器，可对double类型变量进行原子更新和自定义累加操作</li></ol><h3 id="1-AtomicInteger"><a href="#1-AtomicInteger" class="headerlink" title="1. AtomicInteger"></a>1. AtomicInteger</h3><blockquote><p>原子型 Integer</p></blockquote><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicInteger</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化一个默认值为 0 的原子型 Integer</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> initialValue)</span> <span class="hljs-comment">// 初始化一个指定值的原子型 Integer</span><br></code></pre></td></tr></table></figure><ul><li>常用API</li></ul><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取整数的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式自增 1，类似 i++</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式自增 1，类似 ++i</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为新值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将原值加上data，返回新值</td></tr><tr><td>public final int updateAndGet(IntUnaryOperator fun)</td><td>以原子方式将值以fun的逻辑进行更新</td></tr></tbody></table><p><strong>getAndIncrement()</strong></p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，该方法实际上是调用了<strong>unsafe对象</strong>的<code>getAndAddInt()</code>方法</p></li><li><p><code>getAndAddInt()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>o</code>：该AtomicInteger对象本身</li><li><code>offset</code>：对象内value的值的地址，相对于对象存储位置的偏移量，unsafe是根据内存偏移量获取到值</li><li><code>delta</code>：修改参数</li><li><code>v</code>：根据偏移量拿到的value值</li><li>调用CAS方法自旋来完成操作</li></ul></li></ul><h3 id="2-原子引用"><a href="#2-原子引用" class="headerlink" title="2. 原子引用"></a>2. 原子引用</h3><blockquote><p> 对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p></blockquote><p><strong>常见类</strong></p><ol><li>AtomicReference：原子更新引用类型</li><li>AtomicStampedReference：原子更新带有版本号的引用类型</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ol><p><strong>AtomicReference</strong></p><ul><li>构造方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">AtomicReference&lt;T&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;T&gt;()<br></code></pre></td></tr></table></figure><ul><li>原子引用实现CAS操作</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>);<br>    AtomicReference&lt;BigDecimal&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(bd);<br>  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> d.get();<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10&quot;</span>));<br>        <span class="hljs-keyword">if</span> (d.compareAndSet(prev, next)) &#123;<br>            log.debug(<span class="hljs-string">&quot;d:&#123;&#125;&quot;</span>, next);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-解决ABA问题"><a href="#3-解决ABA问题" class="headerlink" title="3. 解决ABA问题"></a>3. 解决ABA问题</h3><blockquote><p>ABA问题：当线程执行CAS操作 A -&gt; C 时，实际值被其他线程提前 由A -&gt; B B -&gt; A，而当前线程无法察觉并依旧能完成修改</p></blockquote><p>当前线程<strong>仅能判断出共享变量的值与预期值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，<br>这时 CAS 虽然成功，但是过程存在问题</p><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABA</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>        otherThread();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/* 此时，main线程并未察觉到变量已被其他线程修改 */</span><br>        log.debug(<span class="hljs-string">&quot;A -&gt; C , &#123;&#125;&quot;</span>,ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>                <span class="hljs-keyword">if</span>(ref.compareAndSet(prev, <span class="hljs-string">&quot;B&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;A -&gt; B , &#123;&#125;&quot;</span>,<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;T1&quot;</span>).start();<br><span class="hljs-comment">// 睡眠 100ms</span><br>        sleep(<span class="hljs-number">100L</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>                <span class="hljs-keyword">if</span>(ref.compareAndSet(prev, <span class="hljs-string">&quot;A&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;B -&gt; A , &#123;&#125;&quot;</span>,<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;T2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://s2.loli.net/2024/01/16/A1sOczpbZBLW7r8.png" alt="aba"></p><p><strong>解决办法</strong></p><ul><li>使用原子引用 <code>AtomicStampedReference</code>类，添加版本号，并在每次修改时更新版本号</li><li>常用API<ul><li><code> public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望值和期望版本号都一致</strong>才进行 CAS 操作</li><li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li><li><code>public V getReference()</code>：返回引用的值</li><li><code>public int getStamp()</code>：返回当前版本号</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SolveABA</span> &#123;<br>    <span class="hljs-comment">// 设置初始值与版本号</span><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;stamp:&#123;&#125;&quot;</span>, stamp);<br>        otherThread();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/* 此时，main线程根据版本号就能察觉到变量已被其他线程修改 */</span><br>        log.debug(<span class="hljs-string">&quot;A -&gt; C , &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>                log.debug(<span class="hljs-string">&quot;stamp:&#123;&#125;&quot;</span>, stamp);<br>                <span class="hljs-comment">// 每次修改变量时，使版本号自增</span><br>                <span class="hljs-keyword">if</span> (ref.compareAndSet(prev, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;A -&gt; B , &#123;&#125;&quot;</span>, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;T1&quot;</span>).start();<br>        sleep(<span class="hljs-number">100L</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>                log.debug(<span class="hljs-string">&quot;stamp:&#123;&#125;&quot;</span>, stamp);<br>                <span class="hljs-keyword">if</span> (ref.compareAndSet(prev, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;B -&gt; A , &#123;&#125;&quot;</span>, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;T2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><img src="https://s2.loli.net/2024/01/16/jtO4yrmMiRXafG2.png" alt="saba" style="zoom:80%;" /><h3 id="4-原子数组"><a href="#4-原子数组" class="headerlink" title="4. 原子数组"></a>4. 原子数组</h3><p><strong>常见类</strong></p><ol><li>AtomicIntegerArray：原子更新整型数组中的元素；</li><li>AtomicLongArray：原子更新长整型数组中的元素；</li><li>AtomicReferenceArray：原子更新引用类型数组中的元素</li></ol><p><strong>AtomicIntegerArray</strong></p><p>原子数组保证线程安全</p><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 普通数组，线程不安全</span><br>        arrayTest(<br>                ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                (array)-&gt;array.length,<br>                (array,index)-&gt;array[index]++,<br>                (array)-&gt;log.debug(<span class="hljs-string">&quot;NormalArray:&#123;&#125;&quot;</span>, Arrays.toString(array))<br>        );<br>        <span class="hljs-comment">// 原子数组，线程安全</span><br>        arrayTest(<br>                ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                (array)-&gt;array.length(),<br>                (array,index) -&gt; array.getAndIncrement(index),<br>                (array) -&gt; log.debug(<span class="hljs-string">&quot;AtomicArray:&#123;&#125;&quot;</span>, array)<br>        );<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrayTest</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">            Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer</span><br><span class="hljs-params">    )</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-comment">// 创建10个线程，分别对数组每个位置做10000次自增</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        printConsumer.accept(array);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="/img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/yzsz.png" alt="yzsz"></p><h3 id="5-原子更新器"><a href="#5-原子更新器" class="headerlink" title="5. 原子更新器"></a>5. 原子更新器</h3><p>更新对象的某个字段，atomic提供了相应的原子操作类：</p><ol><li>AtomicIntegeFieldUpdater：原子更新整型字段类；</li><li>AtomicLongFieldUpdater：原子更新长整型字段类；</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ol><p>使用原子更新字段需要两步操作</p><ol><li>原子更新字段类都是<strong>抽象类</strong>，只能通过静态方法<code>newUpdater</code>来创建一个更新器，并且需要设置想要更新的类和属性；</li><li>更新类的属性必须使用**<code>public volatile</code>**进行修饰，保证多线程时变量的可见性</li></ol><p>利用字段更新器，可以针对对象的<strong>某个域（Field）进行原子操作</strong>，<strong>只能配合 volatile 修饰的字段使用</strong>，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p><strong>AtomicReferenceFieldUpdater</strong></p><ul><li>构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">AtomicReferenceFieldUpdater&lt;Stu, String&gt; updater =<br>                AtomicReferenceFieldUpdater.newUpdater(Stu.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updaterTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Stu</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stu</span>();<br>    <span class="hljs-comment">// 字段更新器</span><br>    AtomicReferenceFieldUpdater&lt;Stu, String&gt; updater =<br>            AtomicReferenceFieldUpdater.newUpdater(Stu.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> updater.compareAndSet(stu, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;kongke&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;update:&#123;&#125; , &#123;&#125;&quot;</span>, update, stu);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span> &#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stu:&quot;</span> +<br>                <span class="hljs-string">&quot;name=&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-原子累加器"><a href="#6-原子累加器" class="headerlink" title="6. 原子累加器"></a>6. 原子累加器</h3><p><strong>常见累加器</strong></p><ol><li>LongAdder：用于对long类型变量进行原子更新和累加操作。</li><li>DoubleAdder：用于对double类型变量进行原子更新和累加操作。</li><li>LongAccumulator：通用的线程安全的累加器，可对long类型变量进行原子更新和自定义累加操作。</li><li>DoubleAccumulator：通用的线程安全的累加器，可对double类型变量进行原子更新和自定义累加操作</li></ol><p>LongAddr 类是 LongAccumulator 类的一个特例，当accumulatorFunction 为 null 时就等价于 LongAddr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LongAccumulator</span><span class="hljs-params">(LongBinaryOperator accumulatorFunction,</span><br><span class="hljs-params">                       <span class="hljs-type">long</span> identity)</span> &#123;<br>    <span class="hljs-built_in">this</span>.function = accumulatorFunction;<br>    base = <span class="hljs-built_in">this</span>.identity = identity;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul><p><strong>LongAdder对比普通自增</strong></p><ul><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">// 普通累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span> ;i++) &#123;<br>            accTest(<br>                    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>),<br>                    AtomicLong::getAndIncrement<br>            );<br>        &#125;<br>    <span class="hljs-comment">// LongAdder累加器</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span> ;i++)&#123;<br>            accTest(<br>                    LongAdder::<span class="hljs-keyword">new</span>,<br>                    LongAdder::increment<br>            );<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">accTest</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; accSupplier,</span><br><span class="hljs-params">            Consumer&lt;T&gt; accConsumer</span><br><span class="hljs-params">    )</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> accSupplier.get();<br>    <span class="hljs-comment">// 4个线程，分别累加25000次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">25000</span>; j++) &#123;<br>                    accConsumer.accept(acc);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;acc:&#123;&#125; , &#123;&#125;ms&quot;</span>, acc, System.currentTimeMillis() - start);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><img src="https://s2.loli.net/2024/01/17/Yishj7ZSO48uL6c.png" alt="ljq" style="zoom:67%;" /><p>后五次效率明显高于前五次，LongAdder优化明显</p><h3 id="7-LongAdder优化机制"><a href="#7-LongAdder优化机制" class="headerlink" title="7. LongAdder优化机制"></a>7. LongAdder优化机制</h3><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果<br>但对 CAS 机制进行了优化，尝试使用<strong>分段 CAS 以及自动分段迁移</strong>的方式来提升多线程高并发执行 CAS 操作的性能</p><p>CAS 是循环不断地尝试修改目标值，直到修改成功。<br>竞争激烈时失败率很高，失败后这些重复的原子性操作会耗费性能（<strong>空循环，自旋转</strong>）</p><p><strong>优化核心思想：数据分离</strong></p><ul><li>将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong></li><li>在低并发的时候直接更新，保障和 AtomicLong 的性能基本一致</li><li>在高并发的时候通过分散减少竞争，提高性能</li></ul><p><strong>分段 CAS 机制</strong>：</p><ul><li>在发生竞争时，创建 Cell 数组用于将不同线程的操作分散（通过 hash 等算法映射）到不同的节点上</li><li>设置多个Cell累加单元（会根据需要扩容，最大为 CPU 核数）,使T0 累加 Cell[0]，T1 累加 Cell[1] 等，最后汇总</li><li>累加时操作的不同的 Cell 变量，减少了线程 CAS 竞争，提高性能</li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个分段内 Cell 的 value 值进行 CAS 操作</p><p><strong>LongAdder累加源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Cell源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>    Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>    <span class="hljs-comment">// CAS操作</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>    &#125;<br>    / **省略** /<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：关键是其中**<code>@sun.misc.Contended</code>**实现了数据分离，将Cell累加单元能独立累加，多核CPU下互不影响</p><p><strong>解决了缓存行的伪共享</strong></p><h3 id="8-伪共享"><a href="#8-伪共享" class="headerlink" title="8. 伪共享"></a>8. 伪共享</h3><p>内存行伪共享（false sharing）<strong>指的是多个线程同时访问不同的变量，但这些变量被存储在同一个缓存行中</strong><br>当一个线程修改了所访问的变量时，由于缓存一致性协议的机制，<strong>整个缓存行会被标记为失效</strong>，<br>导致其他线程无法访问该变量，而需要进行额外的缓存同步操作。<br>这种情况下，多线程并发访问不同变量时，由于额外的缓存同步，性能会受到影响</p><p>内存行伪共享通常发生在，<strong>多个变量被存储在连续的内存地址上，且变量之间的距离小于一个缓存行的大小</strong>（通常是64字节）</p><p><strong>解决办法</strong></p><ul><li>使用填充（padding）：在变量之间插入额外的填充变量，使每个变量占据独立的缓存行，避免多个变量存储在同一个缓存行中</li><li>使用<code>@Contended</code>注解：在编译时会自动生成填充来确保这些变量在不同缓存行上。</li></ul><h4 id="CPU内存结构"><a href="#CPU内存结构" class="headerlink" title="CPU内存结构"></a><strong>CPU内存结构</strong></h4><p><img src="https://s2.loli.net/2024/01/17/eRtWYP91wiO7KXT.png" alt="cache"></p><p>当处理器发出内存访问请求时，会先检查缓存中是否存在该数据，存在，则直接返回该数据；不存在（失效），则将内存中的相应数据同步到缓存，再将其返回处理器</p><h4 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a><strong>缓存行</strong></h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是<strong>相邻的数据会一并加载到缓存中</strong></p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证<strong>数据的一致性</strong>，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效，需要重新从主存中载入</strong>，这就是伪共享</p><img src="img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/wgx.png" alt="wgx" style="zoom:67%;" /><h4 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a><strong>缓存一致性协议</strong></h4><p>每个处理器都有自己的高速缓存，而又共享同一主内存<br><strong>当多个处理器都涉及同一块主存区域的更改时，将导致各自的的缓存数据不一致</strong></p><p>要使各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，来保证处理器间缓存的一致性<br>这类协议有MSI、MESI、MOSI等。</p><p><strong>MESI（Modified Exclusive Shared Or Invalid）</strong>是一种<strong>支持写回策略的缓存一致性协议</strong></p><p>CPU 中每个缓存行使用 4 种状态进行标记（使用额外的2bit表示)：</p><ul><li>Modified（修改）：该缓存行仅出现在此cpu缓存中，缓存已被修改，和内存中不一致，等待同步至内存。</li><li>Exclusive（独占）：该缓存行仅出现在此cpu缓存中，缓存和内存中保持一致。</li><li>Shared（共享）：该缓存行可能出现在多个cpu缓存中，且多个cpu缓存的缓存行和内存中的数据一致。</li><li>Invalid（失效）：由于其他cpu修改了缓存行，导致本cpu中的缓存行失效。</li></ul><p><img src="https://s2.loli.net/2024/01/17/PcdpWBi2UMRAgux.png" alt="mesi"></p><h4 id="Cell的伪共享"><a href="#Cell的伪共享" class="headerlink" title="Cell的伪共享"></a><strong>Cell的伪共享</strong></h4><p>Cell 是数组形式<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个缓存行为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]时，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://s2.loli.net/2024/01/17/Bk5W2oRNhmpVZS3.png" alt="cell"></p><p>Cell的解决办法</p><p>添加**<code>@sun.misc.Contended</code><strong>注解：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时</strong>占用不同的缓存行**</p><p><img src="https://s2.loli.net/2024/01/17/GYVln1qKBfhuvr4.png" alt="cells"></p><h3 id="9-Unsafe"><a href="#9-Unsafe" class="headerlink" title="9. Unsafe"></a>9. Unsafe</h3><blockquote><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>命名Unsafe意为，涉及操作底层系统，不当操作会引起不安全情况发生</p></blockquote><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据</p><p><strong>使用Unsafe自定义实现原子整数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe UNSAFE;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用反射获取Unsafe对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>            UNSAFE = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br>            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <br>    <span class="hljs-comment">// CAS操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、不可变类"><a href="#六、不可变类" class="headerlink" title="六、不可变类"></a>六、不可变类</h2><blockquote><p>如果一个对象不能够修改其内部状态（属性），那么就是不可变对象<br>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p></blockquote><p>在Java中，不可变类是指类的实例在创建后不能被改变，所有的操作都会返回一个新的对象，而不是修改原始对象</p><p><strong>特点</strong></p><ol><li>状态不可改变：不可变类的属性在对象创建后不能被修改，对象的值是固定的，保持不变</li><li><strong>线程安全</strong>：由于不可变类的状态不可更改，多个线程同时访问该对象不需要额外的同步措施</li><li><strong>可以被缓存和重用</strong>：由于不可变类的值是确定的，可以安全地缓存对象，并在需要时重复使用。</li><li>易于设计和维护：不可变类的设计相对简单，因为它们没有可变状态，不需要处理状态变化带来的问题。</li></ol><p>常见的不可变类包括字符串（String）、包装类（如Integer、Double等）、枚举类、日期时间类等。这些类在创建后不能被修改，要改变其值只能通过创建新的对象来实现。</p><p><strong>例如String类的substring()方法</strong>，虽然产生了新值，但没有改变原对象</p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> value.length - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-comment">// 具体操作，创建新的String对象</span><br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset + count);<br>    &#125;<br>    <span class="hljs-comment">// 使用copyof方法创建新对象</span><br>    <span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>源码内部通过创建副本对象来避免共享的手段称之为 <strong>保护性拷贝（defensive copy）</strong></p></li></ul><h3 id="1-享元模式"><a href="#1-享元模式" class="headerlink" title="1. 享元模式"></a>1. 享元模式</h3><blockquote><p>享元模式（Flyweight pattern）：用于需要重用数量有限的同一类对象</p></blockquote><p>享元模式是一种结构型设计模式，它的核心思想是共享对象以减少内存开销</p><p>在享元模式中</p><ul><li><p>如果两个对象之间存在一些相同的属性，那么这些属性可以被提取出来作为一个共享的对象，并在需要时被多个对象共享使用</p></li><li><p>通常会将需要共享的对象封装在一个工厂类中，由工厂类负责创建和管理这些对象。这样就可以确保每个对象只有一份实例，并且可以在需要时复用这些对象，而不需要每次都创建新的对象</p></li></ul><p>享元模式的优点</p><ol><li>减少内存开销：通过共享对象，可以减少内存中的对象数量，降低内存开销</li><li>提高性能：由于可以重用对象，可以避免频繁地创建和销毁对象，提高系统性能</li><li>简化代码逻辑：共享对象的创建和管理由工厂类处理，可以简化客户端代码的逻辑，使其更易于维护</li><li>支持大规模数据处理：享元模式可以支持处理海量数据，它可以将大量相似的对象合并成一个共享对象</li></ol><p>享元模式在实际应用中的场景包括：字符编码、线程池、数据库连接池等</p><h4 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h4><p><strong>包装类</strong>，在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了valueOf方法</p><p>例如Long的valueOf会缓存 <code>-128~127</code> 之间的对象，在这个范围之间会重用对象，大于这个范围，才会新建Long对象</p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// 在范围之间不会创建对象</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="自定义连接池"><a href="#自定义连接池" class="headerlink" title="自定义连接池"></a>自定义连接池</h4><p>先预先创建好一批连接放入连接池，当请求到达后先从连接池获取连接，使用完毕后再放回连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> pool.borrow();<br>                sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">3</span>));<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Connection[] connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicIntegerArray status;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接 &quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-keyword">if</span> (status.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// CAS操作保证线程安全</span><br>                    <span class="hljs-keyword">if</span> (status.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>,connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 循环一遍后未发现空闲则使当前线程等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                status.set(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 唤醒等待的线程</span><br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free: &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockConnection</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">/**省略实现方法**/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行结果</li></ul><p><img src="https://s2.loli.net/2024/01/17/ZrnmgWGl1vEUMQV.png" alt="ljc"></p><h3 id="2-Final"><a href="#2-Final" class="headerlink" title="2. Final"></a>2. Final</h3><blockquote><p>final可以修饰<strong>变量，方法和类</strong>，用于表示所修饰的内容一旦赋值之后就不会再被改变</p></blockquote><h4 id="Final的使用场景"><a href="#Final的使用场景" class="headerlink" title="Final的使用场景"></a>Final的使用场景</h4><p><strong>修饰变量</strong></p><p>在java中变量，可以分为<strong>成员变量</strong>以及方法<strong>局部变量</strong></p><p>final修饰成员变量，又分为</p><ul><li>类变量<ul><li>必须在<strong>静态初始化块</strong>中指定初始值或者<strong>声明该类变量时</strong>指定初始值</li></ul></li><li>实例变量<ul><li>必需在<strong>非静态初始化块</strong>，<strong>声明该实例变量</strong>或者在<strong>构造器中</strong>指定初始值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;<br>    <span class="hljs-comment">// 类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> b ;<br>    <span class="hljs-keyword">static</span> &#123;<br>        b=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> d;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> e;<br>    &#123;<br>        d = <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestFinal</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> &#123;<br>        <span class="hljs-built_in">this</span>.e = e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>final修饰局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// f 不能在方法内赋值，因为调用该方法时已经赋值    </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> f)</span>&#123;<br>        <span class="hljs-comment">// 两种赋值方式</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> h;<br>        h = <span class="hljs-number">5</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意，如果final修饰的为<strong>引用数据类型</strong>，则其引用的对象的属性可以改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">24</span>, <span class="hljs-number">170</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//对final引用数据类型person进行更改</span><br>        <span class="hljs-comment">//此时修改可以生效</span><br>        person.age = <span class="hljs-number">22</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-built_in">this</span>.height = height;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>因为引用对象保存的是一个地址引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的</strong></p><p><strong>宏变量</strong></p><p>当变量满足一下三个条件时，就会成为一个“宏变量”，即一个常量</p><ol><li>使用final修饰符修饰</li><li>在定义该final变量时就指定了初始值</li><li>该初始值在编译时就能够唯一指定</li></ol><p>注意：当程序中使用该宏变量的地方，编译器会直接替换成该变量的值</p><hr><p><strong>修饰方法</strong></p><ul><li>父类的final方法是不能够被子类重写的</li><li>final方法是可以被重载的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>修饰类</strong></p><ul><li>被final修饰的类不能被子类继承</li></ul><p>子类继承往往可以重写父类的方法和改变父类属性，当一个类不希望被继承时就可以使用final修饰</p><h4 id="Final的应用"><a href="#Final的应用" class="headerlink" title="Final的应用"></a>Final的应用</h4><blockquote><p>final利用不可变性，通常来实现不可变类</p></blockquote><p><strong>String类</strong></p><ul><li>部分源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 被final修饰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">// 属性也被final修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure><h4 id="Final的实现原理"><a href="#Final的实现原理" class="headerlink" title="Final的实现原理"></a>Final的实现原理</h4><p><strong>设置final变量的原理</strong></p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> TestFinal&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字节码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0<br><span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span><br><span class="hljs-number">4</span>: aload_0<br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><br><span class="hljs-number">7</span>: putfield #<span class="hljs-number">2</span><br>   &lt;-- 写屏障 (storestore屏障)<br><span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>JMM禁止编译器把final域的写重排序到屏障以外</li><li>并且将屏障以内的写操作同步到内存中，使其他线程可见，且只能有唯一值</li></ol><p><strong>获取final对象的原理</strong></p><p><strong>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序</strong>处理器会在读final域操作的前面插入一个LoadLoad屏障。</p><h2 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h2><blockquote><p>一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p></blockquote><p><strong>线程池的作用</strong></p><ul><li><p>降低资源消耗：减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p></li><li><p>提高响应速度：当任务到达时，如果有线程可以直接用，不会出现系统僵死</p></li><li><p>提高管理性：线程池可以对线程进行统一的分配，调优和监控</p></li></ul><p>核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><p><strong>线程池基本处理流程</strong></p><p><img src="https://s2.loli.net/2024/01/18/tlj371dmeuYTBh8.png" alt="pool"></p><h3 id="1-自定义线程池"><a href="#1-自定义线程池" class="headerlink" title="1. 自定义线程池"></a>1. 自定义线程池</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>有界队列和无界队列：</p><ul><li>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</li><li>无界队列：没有设置固定大小的队列，任务可以直接入队，直到溢出（超过 Integer.MAX_VALUE）</li></ul><p><code>java.util.concurrent.BlockingQueue</code> 接口下阻塞队列的实现：先进先出队列（FIFO）</p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中<strong>阻塞添加和阻塞删除方法，以及线程安全</strong>：</p><ul><li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列不满时被唤醒</li><li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不空时被唤醒</li></ul><p><strong>示例代码</strong></p><ul><li>自定义任务阻塞队列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">// 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 生产者变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 消费者变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <span class="hljs-comment">// 超时获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 防止虚假唤醒</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 返回剩余等待时间</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T element)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;&quot;</span>, element);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addLast(element);<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, element);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 超时阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T element, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;&quot;</span>, element);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addLast(element);<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, element);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拒绝策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.addLast(task);<br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="池对象"><a href="#池对象" class="headerlink" title="池对象"></a>池对象</h4><p>线程池一般需要包含以下属性：</p><ul><li><p>核心线程数（corePoolSize）：线程池中保留的核心线程数量。核心线程会一直存活，即使没有任务需要执行。</p></li><li><p>最大线程数（maximumPoolSize）：线程池中允许的最大线程数量。当有新任务提交时，如果核心线程都在执行任务，且任务队列已满，则线程池会创建新的线程，直到达到最大线程数。</p></li><li><p>任务队列（workQueue）：用于存储待执行的任务的队列。当任务提交时，如果核心线程都在执行任务，任务会被放入任务队列中等待执行。</p></li><li><p>线程存活时间（keepAliveTime）：当线程池中的线程数量超过核心线程数时，空闲线程的存活时间。超过这个时间，空闲线程会被销毁，直到保持线程池中的线程数量不超过核心线程数</p></li><li><p>拒绝策略（rejectedExecutionHandler）：当线程池无法接受新的任务时，如何处理这些被拒绝的任务</p></li><li><p>线程工厂（threadFactory）：用于创建新线程的工厂</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-comment">// 超时单位</span><br>    <span class="hljs-keyword">private</span> TimeUnit unit;<br>    <span class="hljs-comment">// 拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit unit,</span><br><span class="hljs-params">                      <span class="hljs-type">int</span> capacity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.unit = unit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(capacity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-comment">// 工作线程数量小于核心数则创建新的工作线程，并直接赋予任务</span><br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                workers.add(worker);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;,当前任务&#123;&#125;&quot;</span>, worker, task);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 工作线程数量大于核心数则将任务放入任务队列</span><br><span class="hljs-comment">//                taskQueue.put(task);</span><br>                <span class="hljs-comment">// 使用策略模式，拒绝策略</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 只要任务不空就一直工作</span><br><span class="hljs-comment">//            while (task != null || (task = taskQueue.take()) != null)&#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, unit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行任务....&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 任务结束，将自己从线程集合中移除</span><br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>                log.debug(<span class="hljs-string">&quot;移除worker...&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><blockquote><p>指当线程池无法接受新的任务时，如何处理这些被拒绝的任务</p></blockquote><p><strong>常见拒绝策略</strong></p><ul><li><p>AbortPolicy：直接抛出<code>RejectedExecutionException</code>异常，拒绝执行新的任务。</p></li><li><p>CallerRunsPolicy：将任务返回给提交任务的线程进行执行。</p></li><li><p>DiscardPolicy：直接丢弃被拒绝的任务，不做任何处理。</p></li><li><p>DiscardOldestPolicy：丢弃线程池中最早被放入任务队列的任务，然后尝试将被拒绝的任务重新放入任务队列。</p></li></ul><p><strong>自定义策略</strong></p><ul><li><p>创建函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在构造线程池对象时，自定义实现</p></li></ul><h4 id="主函数测试"><a href="#主函数测试" class="headerlink" title="主函数测试"></a>主函数测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">2</span>,<br>                        (queue, task) -&gt; &#123;<br>                            <span class="hljs-comment">// 死等</span><br><span class="hljs-comment">//                            queue.put(task);</span><br>                            <span class="hljs-comment">// 超时等待</span><br><span class="hljs-comment">//                            queue.offer(task,1500,TimeUnit.MILLISECONDS);</span><br>                            <span class="hljs-comment">// 抛出异常</span><br><span class="hljs-comment">//                            throw new RuntimeException(&quot;任务执行失败&quot;+task);</span><br>                            <span class="hljs-comment">// 主线程自己执行</span><br>                            task.run();<br>                        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            threadPool.execute(() -&gt; &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>                log.debug(<span class="hljs-string">&quot;task..&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://s2.loli.net/2024/01/18/Ki7DV5Lxvsj23IX.png" alt="pooltest"></p><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2.  ThreadPoolExecutor"></a>2.  ThreadPoolExecutor</h3><blockquote><p>Executor 框架最核心的类是 ThreadPoolExecutor，它是线程池的实现类</p></blockquote><img src="https://s2.loli.net/2024/01/18/IqUtzNVYlgrmf1v.png" alt="stpe" style="zoom:50%;" /><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。</p><ul><li>状态信息</li></ul><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table><p>注意：int 的二进制表示时，第 1 位为符号位 ，1表示负数，0表示正数</p><p>所以五种状态的数字大小：TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p><p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以<strong>用一次 CAS 原子操作进行赋值</strong></p><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 使用或运算合并</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br><span class="hljs-comment">// cas操作</span><br>ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>状态转换</p></li></ul><p><img src="https://s2.loli.net/2024/01/18/jmpDXkZKP9rqRv7.png" alt="poolztzh"></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure></li><li><p><code>corePoolSize</code>：核心线程池的大小。当调用<code>execute()</code>提交任务时，当前核心线程池的线程个数没有达到corePoolSize，则会创建新的线程来执行所提交的任务，<strong>即使当前核心线程池有空闲的线程</strong>。</p></li><li><p>如果调用了<code>prestartCoreThread()</code>或 <code>prestartAllCoreThreads()</code>，线程池创建的时会创建并启动所有的核心线程</p></li><li><p><code>maximumPoolSize</code>：线程池能创建线程的最大个数。<strong>一般线程池中会存在核心线程和救急线程</strong></p></li><li><p><code>keepAliveTime</code>：空闲线程存活时间。当线程个数超过corePoolSize，且线程空闲时间超过了keepAliveTime会将这些空闲线程销毁，直到保持线程池中的线程数量不超过核心线程数</p></li><li><p><code>unit</code>：keepAliveTime的时间单位</p></li><li><p><code>workQueue</code>：阻塞队列。用于保存任务的阻塞队列</p></li><li><p><code>threadFactory</code>：创建线程的工程类。可以通过指定线程工厂为每个线程设置标志性的名称，方便查找和定位</p></li><li><p><code>handler</code>：饱和策略。当线程池的阻塞队列已满和指定的线程都已经开启，就需要采用一种策略来处理后续的任务</p></li></ul><p>通过 Executor 框架的工具类 Executors，可以创建 3 种类型的 ThreadPoolExecutor</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul><p><strong>FixedThreadPool</strong></p><blockquote><p>被称为可重用固定线程数的线程池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize 和 maximumPoolSize  相等，说明池中没有救急线程</p></li><li><p>使用无界队列 LinkedBlockingQueue 作为工作队列（容量为 Integer.MAX_VALUE），所以此线程池不会拒绝任务</p></li></ul><p><strong>适用于任务量已知，相对耗时的任务的场景</strong></p><p><code>execute()</code>工作示意图</p><img src="https://s2.loli.net/2024/01/18/VlIkcDpbm6KfOQ9.png" alt="ftp" style="zoom:67%;" /><ol><li>如果当前运行的线程数少于 corePoolSize，则创建新线程来执行任务</li><li>在线程池完成预热之后（运行的线程数等于 corePoolSize），将任务加入 LinkedBlockingQueue</li><li>线程执行完 1 中的任务后，会在循环中反复从 LinkedBlockingQueue 获取任务来执行</li></ol><hr><p><strong>SingleThreadExecutor</strong></p><blockquote><p>SingleThreadExecutor 是使用单个 worker 线程的 Executor    </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>corePoolSize 和 maximumPoolSize 为 1。</li><li>使用无界队列 LinkedBlockingQueue 作为线程池的工作队列</li></ul><p><strong>适用于多个任务排队执行的场景</strong></p><p><code>execute()</code>运行示意图</p><p><img src="/img/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ste.png" alt="ste"></p><ol><li>如果当前线程池中无运行的线程，则创建一个新线程来执行任务</li><li>当线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue</li><li>线程执行完任务后，会在一个无限循环中反复从 LinkedBlockingQueue 获取任务来执行</li></ol><hr><p><strong>CachedThreadPool</strong></p><blockquote><p>CachedThreadPool 是一个会根据需要创建新线程的线程池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize 为 0，即 corePool 为空，即创建出来的线程全部为救急线程</p></li><li><p>maximumPoolSize 为 Integer.MAX_VALUE，即 maximumPool 是无界的</p><ul><li>如果任务提交速度高于线程处理任务的速度，CachedThreadPool 会不断创建新线程</li></ul></li><li><p>keepAliveTime 为 60L，则空闲线程等待新任务的最长时间为 60 秒，超过 60 秒后将会被终止</p></li><li><p>使用没有容量的 SynchronousQueue 作为线程池的工作队列</p><ul><li>由于没有容量，所以只有线程等待任务时，才会将任务交给线程执行，否则会创建新的线程</li></ul></li></ul><p><strong>适合任务密集，且任务执行时间较短的环境</strong></p><p><strong>SynchronousQueue</strong></p><img src="https://s2.loli.net/2024/01/18/cYsnOm7vpGtXSFV.png" alt="sq" style="zoom:80%;" /><p><code>execute()</code>运行示意图</p><img src="https://s2.loli.net/2024/01/18/enjoKXWFVfw7MGY.png" alt="ctp" style="zoom:80%;" /><ol><li>首先执行 offer 如果当前线程池中有<strong>空闲线程正在执行</strong> poll ，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行。否则创建新的线程</li><li>当初始线程池为空或没有空闲线程时，线程池会创建一个新线程执行任务</li><li>线程任务执行完成后，执行 poll 操作，且会让空闲线程最多等待 60 秒钟，超时没有新任务这个空闲线程将终止</li></ol><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><blockquote><p>ExecutorService 类中提交任务的API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务（Executor 类的API）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span><br><span class="hljs-comment">// 提交任务 task()</span><br>Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span><br>Future <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable task)</span><br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">//提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</span><br>&lt;T&gt; List&lt;Future&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><span class="hljs-comment">//提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">// 可以设置超时等待时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p><code>execute()</code>方法用于提交不需要返回值的任务（Runnable），所以无法判断任务是否被线程池执行成功</p></li><li><p><code>execute()</code> 会直接抛出任务执行时的异常</p></li><li><p><code>submit()</code>方法用于提交需要返回值的任务（Callable）也能提交Runnable</p><ul><li>线程池会返回一个 future 类型的对象，通过future可以判断任务是否执行成功</li><li>并且可以通过 future 的 get() 方法来获取返回值，get()方法会<strong>阻塞当前线程</strong>直到任务完成</li></ul></li><li><p><code>submit()</code> 会吞掉异常，可通过 Future 的 get() 方法将任务执行时的异常重新抛出</p></li></ul><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><blockquote><p>ExecutorService 类中关闭线程池的 API</p></blockquote><ul><li><p><code>shutdownNow</code>首先将线程池的状态设置为<strong>STOP</strong>,然后尝试<strong>停止所有的正在执行和未执行任务</strong>的线程，并返回等待执行任务的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 修改线程状态</span><br>        advanceRunState(STOP);<br>        <span class="hljs-comment">// 打断所有线程</span><br>        interruptWorkers();<br>        <span class="hljs-comment">// 收集未执行任务</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结 （此时所有线程都被打断，会直接终止线程池）</span><br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>shutdown</code>只是将线程池的状态设置为<strong>SHUTDOWN</strong>状态，然后中断所有空闲线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 设置线程池状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">// 打断空闲线程</span><br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终止线程池，如果还有线程未结束也不会阻塞</span><br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>调用了这两个方法的任意一个，<code>isShutdown</code>方法都会返回 true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用<code>isTerminated</code>方法才会返回 true</p><h3 id="3-任务调度"><a href="#3-任务调度" class="headerlink" title="3. 任务调度"></a>3. 任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a><strong>Timer</strong></h4><p>Timer操作简单，但所有任务都是由同一个线程来调度，所有任务都是串行执行，且前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTimer</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一个任务出错会影响到下一个任务</span><br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 任务串行执行</span><br>    <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;task2&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <br>    timer.schedule(task1, <span class="hljs-number">1000</span>);<br>    timer.schedule(task2, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://s2.loli.net/2024/01/22/o1JFt347pmsVnAf.png" alt="timer"></p><img src="https://s2.loli.net/2024/01/22/BQbEWxKn84o7XUV.png" alt="timer2" style="zoom: 80%;" /><hr><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><blockquote><p>可以用来在给定延时后执行异步任务或者周期性执行任务，相对于任务调度的Timer来说，其功能更加强大</p></blockquote><p>属于任务调度线程池继承 ThreadPoolExecutor</p><ul><li>使用内部类 ScheduledFutureTask 封装任务</li><li>使用内部类 DelayedWorkQueue 作为线程池队列</li><li>重写 onShutdown 方法去处理 shutdown 后的任务</li><li>提供 DecorateTask 方法包装 ScheduledFutureTask</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Executors.newScheduledThreadPool(<span class="hljs-type">int</span> corePoolSize)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-comment">// 最大线程数固定为 Integer.MAX_VALUE，空闲存活时间 keepAliveTime 固定为 0</span><br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-comment">// 阻塞队列是 DelayedWorkQueue</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>常用 API：</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 延迟执行任务</span><br>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, <span class="hljs-type">long</span> delay, TimeUnit u)<br><span class="hljs-comment">// 定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</span><br>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period, TimeUnit unit)<br><span class="hljs-comment">// 定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</span><br>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, <span class="hljs-type">long</span> initialDelay, <br>                                          <span class="hljs-type">long</span> delay, TimeUnit unit)<br></code></pre></td></tr></table></figure><ul><li>当调用这些API时，实际上是将提交的任务转换成的<code>ScheduledFutureTask</code>类（可周期性执行的任务）<ul><li>例如<code>schedule</code>方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay,<br>                                   TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,<br>                                      triggerTime(delay, unit)));<br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>为了实现延时执行异步任务以及能够周期执行任务，其中含有一个延时队列<code>DelayedWorkQueue</code></p><ul><li><p>定时任务执行时需要取出最近要执行的任务，所以任务在队列中一定是按照时间先后排序</p></li><li><p>DelayedWorkQueue是一个优先级队列，是基于堆结构的队列，在执行插入和删除操作时的最坏时间复杂度是 <code>O(logN)</code></p></li><li><p>部分数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//初始大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-comment">//DelayedWorkQueue是由一个大小为16的数组组成，数组元素为实现RunnableScheduleFuture接口的类</span><br><span class="hljs-comment">//实际上为ScheduledFutureTask</span><br><span class="hljs-keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>简单使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSchedulePool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 任务调度线程池</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>        pool.schedule(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br><span class="hljs-comment">//            sleep(1);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span> ;<br>        &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        pool.schedule(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task2&quot;</span>);<br>        &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br>    -------------------------------------------<br><br>        log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br><br>        <span class="hljs-comment">// 严格设置任务间隔时间</span><br>        pool.scheduleWithFixedDelay(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;Running...&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br>        pool.scheduleAtFixedRate(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;Running...&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 任务时间超过规定间隔时间，则以任务时间为间隔</span><br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>设置每周四18时的定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSchedule</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 设置一个每周四18时执行的定时任务</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 计算当前距离周四的时间差</span><br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-comment">// 本周四的时间</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">thu</span> <span class="hljs-operator">=</span> now.withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>)<br>            .withNano(<span class="hljs-number">0</span>).with(DayOfWeek.THURSDAY);<br>        <span class="hljs-keyword">if</span> (now.compareTo(thu) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果当前时间在本周四之后，则选择下周四</span><br>            thu = thu.plusWeeks(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 计算时间差</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialDelay</span> <span class="hljs-operator">=</span> Duration.between(now, thu).toMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>;<br><br>        pool.scheduleAtFixedRate(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-Fork-Join"><a href="#4-Fork-Join" class="headerlink" title="4. Fork &#x2F; Join"></a>4. Fork &#x2F; Join</h3><blockquote><p>Fork&#x2F;Join 框架是 Java 7 提供的一个用于并行执行任务的框架，将大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</p></blockquote><p>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果</p><p><strong>运行流程图</strong></p><img src="https://s2.loli.net/2024/01/23/8Nw3MxuEf7c46Xd.png" alt="fj" style="zoom:80%;" /><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a><strong>工作窃取算法</strong></h4><blockquote><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</p></blockquote><p>将较大的任务分割为若干互不依赖的子任务时，为了减少线程间的竞争，把这些子任务分别放到<strong>不同的队列</strong>里，并为每个队列<strong>创建一个单独的线程</strong>来执行队列里的任务，<strong>线程和队列一一对应</strong></p><p>但是，当有的线程已经把自己队列里的任务完成，而其他线程对应的队列里还有任务等待处理，它就去其他线程的队列里窃取一个任务来执行，而在这时<strong>它们会访问同一个队列</strong></p><p>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用<strong>双端队列</strong>，被窃取任务线程永远从<strong>双端队列的头部</strong>拿任务执行，而窃取任务的线程永远从<strong>双端队列的尾部</strong>拿任务执行</p><ul><li><p><strong>优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争</p></li><li><p><strong>缺点</strong>：某些情况下还是有竞争，如双端队列里只有一个任务时，且该算法消耗了更多的系统资源，如创建多个线程和多个双端队列</p></li></ul><hr><p>Fork&#x2F;Join 使用两个类来完成任务切割与合并结果</p><ul><li>ForkJoinTask：我们要使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它 提供在任务 中执行 fork()和 join()操作的机制。通常情况下，我们不需要直接继承 ForkJoinTask 类，只需要继承它的子类Fork&#x2F;Join 框架提供了以下两个子类。 <ul><li>RecursiveAction：用于没有返回结果的任务</li><li>RecursiveTask：用于有返回结果的任务</li></ul></li><li>ForkJoinPool：是一个特殊的线程池，<strong>默认会创建与 CPU 核心数相同的线程</strong>，ForkJoinTask 需要通过 ForkJoinPool 来执行</li></ul><p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会<strong>随机</strong>从其他工作线程的队列的尾部获取一个任务</p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p><strong>使用Fork &#x2F; Join框架计算 n 的累加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestForkJoin</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.MyTask&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123; &quot;</span>+n+<span class="hljs-string">&quot; &#125;&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>,n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 递归任务拆分</span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">myTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(n - <span class="hljs-number">1</span>);<br>        myTask.fork();<br>        log.debug(<span class="hljs-string">&quot;fork : &#123;&#125; + &#123;&#125;&quot;</span>,n,myTask);<br>        <span class="hljs-comment">// 获取任务结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> myTask.join() + n;<br>        log.debug(<span class="hljs-string">&quot;join &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>,n,myTask,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><img src="https://s2.loli.net/2024/01/23/4cfmM6bLvtiUCHx.png" alt="fjr" style="zoom: 80%;" /><p>ForkJoinTask 与一般任务的主要区别在于它需要实现 compute 方法<br>首先需要判断任务是否足够小，足够小就直接执行任务，不够小就必须分割成两个子任务<br>每个子任务在调用 fork 时，又会进入 compute ，判断是否需要继续分割，使用 join 方法会等待子任务执行完并得到其结果</p><hr><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><p>ForkJoinTask 在执行的时候可能会抛出异常，但是无法在主线程里直接捕获异常</p><p>所以 ForkJoinTask 提供了 <code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，通过 ForkJoinTask 的 <code>getException</code> 方法获取异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (task.isCompletedAbnormally()) &#123;<br>    System.out.println(task.getException()); <br>&#125; <br></code></pre></td></tr></table></figure><p><code>getException</code> 方法返回 <code>Throwable</code> 对象，如果任务被取消了则返 <code>CancellationException</code></p><hr><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成</p><ul><li>ForkJoinTask 数组负责将存放的程序提交给 ForkJoinPool 的任务</li><li>ForkJoinWorkerThread 数组负责执行这些任务</li></ul><p><strong>fork方法实现原理</strong></p><ul><li>调用fork 方法时，程序会调用 ForkJoinWorkerThread 的 <strong>push</strong> 方法异步地执行这个任务，然后立即返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-comment">// 判断是否是此类对象</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>push 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用 ForkJoinPool 的 **signalWork()**方法唤醒或创建一个工作线程来执行任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, s = top, n;<br>    <span class="hljs-keyword">if</span> ((a = array) != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// ignore if queue removed</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>;     <span class="hljs-comment">// fenced write for task visibility</span><br>        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);<br>        U.putOrderedInt(<span class="hljs-built_in">this</span>, QTOP, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> ((n = s - b) &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((p = pool) != <span class="hljs-literal">null</span>)<br>                p.signalWork(p.workQueues, <span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= m)<br>            growArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>join 方法实现原理</strong></p><ul><li>Join 方法的主要作用是阻塞当前线程并等待获取结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportException</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-keyword">if</span> (s == EXCEPTIONAL)<br>        rethrow(getThrowableException());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先它调用了 **doJoin()**方法，通过 doJoin()方法得到当前任务的状态来判断返回结果，<ul><li>状态有 4 种：<strong>已完成（NORMAL）</strong>、<strong>被取消（CANCELLED）</strong>、<strong>信号 （SIGNAL）</strong>和<strong>出现异常（EXCEPTIONAL）</strong><ul><li>如果任务状态是已完成，则直接返回任务结果</li><li>如果任务状态是被取消，则直接抛出 CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中首先通过查看任务的状态，检查任务是否已经执行完成</p><ul><li>执行完成，则直接返回任务状态，没有执行完，则从任务数组里取出任务并执行</li><li>任务顺利执行完成，则设置任务状态为 NORMAL，出现异常则记录异常并将任务状态设置为 EXCEPTIONAL</li></ul><h2 id="八、队列同步器-AQS"><a href="#八、队列同步器-AQS" class="headerlink" title="八、队列同步器-AQS"></a>八、队列同步器-AQS</h2><blockquote><p>队列同步器 AbstractQueuedSynchronizer（AQS），是用来构建锁或者其他同步组件的基础框架</p></blockquote><p>同步器的主要使用方式是<strong>继承</strong>，子类通过继承同步器并实现它的抽象方法来管理同步状态<br>其自身没有实现任何同步接口，它仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用</p><p>同步器支持<strong>独占式和共享式</strong>地获取同步状态以实现不同类型的同步组件<br>(ReentrantLock、ReentrantReadWriteLock 和 CountDownLatch等)</p><p>同步器是实现锁（或任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义</p><ul><li><p><strong>锁（Lock）</strong>：<br>锁是用来控制多个线程访问共享资源的方式，在Lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而lock接口提供了与synchronized一样的锁功能<strong>它没有synchronize关键字隐式加锁解锁的便捷性，但是拥有锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性</strong></p><ul><li><p>拥有synchronized关键字所不具备的同步特性</p><p><img src="https://s2.loli.net/2024/01/25/t5bxyT3AwaQB71E.png" alt="lock1"></p></li><li><p>Lock 是一个接口，定义了锁获取和释放的基本操作</p><p><img src="https://s2.loli.net/2024/01/25/jU2asirEHmA74By.png" alt="lock2"></p></li><li><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>.......<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：lock 与 unlock需成对出现</p></li><li><p>当查看ReentrantLock（实现了Lock接口）源码时，会发现<strong>基本上所有的方法的实现实际上都是调用了其静态内存类<code>Sync</code>中的方法，而<code>Sync</code>类继承了<code>AbstractQueuedSynchronizer</code></strong></p></li></ul></li></ul><p>锁与同步器之间的关系</p><ul><li><strong>锁面向使用者</strong>，它定义了使用者与锁交互的接口，隐藏了实现细节</li><li><strong>同步器面向锁的实现者</strong>，它简化了锁的实现方式，屏蔽了状态管理、等待与唤醒等底层操作</li></ul><h3 id="1-AQS的设计模式"><a href="#1-AQS的设计模式" class="headerlink" title="1. AQS的设计模式"></a>1. AQS的设计模式</h3><blockquote><p>同步器AQS的设计是基于模板方法模式</p></blockquote><p>使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中</p><p>重写同步器指定的方法时，需要使用同步器提供的如下 3 个方法来访问或修改同步状态</p><ul><li><code>getState()</code>：获取当前同步状态</li><li><code>setState(int newState)</code>：设置当前同步状态</li><li><code>compareAndSetState(int expect,int update)</code>：使用 CAS 设置当前状态，保证状态设置的原子性</li></ul><p>AQS可重写方法</p><p><img src="https://s2.loli.net/2024/01/25/VUlBqghoHWmtSRz.png" alt="aqs1"></p><p>实现同步组件时AQS提供的模板方法</p><p><img src="https://s2.loli.net/2024/01/25/FDv6gRY8SuhImVl.png" alt="aqs2"></p><p>模板方法分为3类</p><ol><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中等待线程情况</li></ol><h4 id="自定义不可重入锁"><a href="#自定义不可重入锁" class="headerlink" title="自定义不可重入锁"></a>自定义不可重入锁</h4><ul><li>完整代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义同步器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-comment">// 操作成功则设置 owner</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// 注意此处state是volatile变量，所以将此操作放在后面执行加上写屏障</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">mySync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        mySync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可打断加锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        mySync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试加锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> mySync.tryAcquireNanos(<span class="hljs-number">1</span>,unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        mySync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建条件变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mySync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-同步队列"><a href="#2-同步队列" class="headerlink" title="2. 同步队列"></a>2. 同步队列</h3><blockquote><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列</p></blockquote><p>同步器依赖内部的同步队列（一个 FIFO 双向链式队列）来完成同步状态的管理</p><p>当线程获取同步状态（锁）失败时，同步器会将当前线程以及等待状态等信息构造成为一个<strong>节点 （Node）</strong>并将其加入同步队列，同时阻塞当前线程，当同步状态（锁）释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态 </p><p>同步队列中的节点用来保存获取<strong>同步状态失败的线程引用、等待状态以及前驱和后继节点</strong></p><p><strong>节点属性</strong></p><p><img src="https://s2.loli.net/2024/01/25/Wkcad5FBjCQ1O6Y.png" alt="node"></p><p>节点是构成同步队列的基础，同步器拥首节点（head）和尾节点（tail）没有获取到同步状态的线程会成为节点加入该队列的尾部</p><p><strong>同步队列的基本结构</strong></p><p><img src="https://s2.loli.net/2024/01/25/s9n2dotjSX8WPyE.png" alt="tbdl"></p><p>当一个线程成功地获取了同步状态，其他线程被构造成节点并加入到同步队列中时，这个<strong>加入队列的过程必须要保证线程安全</strong><br>因此同步器提供了一个基于 CAS 的设置尾节点的方法： <code>compareAndSetTail(Node expect,Node update)</code></p><p><strong>同步队列遵循 FIFO</strong></p><p><strong>首节点是获取同步状态成功的节点</strong>，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点，设置首节点是获取同步状态成功的线程来完成的，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可</p><p><img src="https://s2.loli.net/2024/01/25/X87pyrlOdh3mRUW.png" alt="tbdl2"></p><h3 id="3-独占锁"><a href="#3-独占锁" class="headerlink" title="3. 独占锁"></a>3. 独占锁</h3><blockquote><p>同一时刻只有一个线程能获得锁，具体的 Java 实现有 ReentrantLock</p></blockquote><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>通过调用同步器的 <code>acquire(int arg)</code>方法获取同步状态，且方法对中断不敏感，也就是当线程未获取到同步状态后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出</p><ul><li><p><code>acquire(int arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 检查同步状态是否获取成功，成功则退出方法</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        <span class="hljs-comment">// 失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>首先调用 <code>tryAcquire(int arg)</code>，保证线程安全的获取同步状态，如果获取失败，则构造同步节点 （独占式 <code>Node.EXCLUSIVE</code>）并通过 <code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部，最后调用 <code>acquireQueued(Node node,int arg)</code>方法，使得该节点以“死循环”的方式获取同步状态</p><ul><li><p><code>addWaiter(Node node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 返回当前线程的 node 节点</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式   </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 快速入队，如果 tail 不为 null，说明存在队列</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将当前节点的前驱节点指向 尾节点</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 通过 cas 将 node 对象加入 AQS 队列尾部</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<span class="hljs-comment">// 双向链表</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 初始时队列为空，或者 CAS 失败进入这里</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>enq(final Node node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br><span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//1.初始队列为空，构造头结点</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                    tail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 2. 尾插入，CAS操作失败自旋尝试</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>节点进入同步队列之后，就进入了一个自旋的过程，每个节点都在自旋地观察，当条件满足获取到了同步状态就退出，否则会留在这个自旋过程中（并会阻塞节点的线程）</p><ul><li><p><code>acquireQueued(Node node,int arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// true 表示当前线程抢占锁失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 表示当前线程是否被中断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获得当前线程节点的前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 获取成功, 设置当前线程自己的 node 为 head</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 返回当前线程是否被中断</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里</span><br>                <span class="hljs-comment">// 就算被打断了，也会继续循环</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 可打断模式下才会进入该逻辑</span><br>        <span class="hljs-keyword">if</span> (failed)cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取锁失败的话<code>shouldParkAfterFailedAcquire(p, node)</code>，<strong>将前驱节点的 waitStatus 改为 -1（由INITIAL改为SIGNAL）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 前置节点的状态处于取消状态，需要删除前面所有取消的节点, 返回到外层循环重试</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 获取到非取消的节点，连接上当前节点</span><br>        pred.next = node;<br>    <span class="hljs-comment">// 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 设置上一个节点状态为 Node.SIGNAL，返回外层循环重试</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 返回不应该 park，再次尝试一次</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当<code>compareAndSetWaitStatus</code>设置失败则说明<code>shouldParkAfterFailedAcquire</code>方法返回false，然后会在<code>acquireQueued()</code>方法中<code>for (;;)</code>死循环中会继续重试，直至<code>compareAndSetWaitStatus</code>设置节点状态位为SIGNAL时<code>shouldParkAfterFailedAcquire</code>返回true时才会执行方法<code>parkAndCheckInterrupt()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 判断当前线程是否被打断，并清除打断标记</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示意图</p><p><img src="https://s2.loli.net/2024/01/25/zKoZ54Ob6NFwUjP.png" alt="xhtj"></p><ul><li>由于头节点是成功获取同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后<strong>需要检查自己的前驱节点是否是头节点</strong>，如果是则尝试获取同步状态。节点和节点之 间在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合 FIFO，并且也便于对过早通知的处理（<strong>过早通知是指前驱节点不是头节点的线程由于中断而被唤醒</strong>）</li></ul></li><li><p>流程图</p><img src="https://s2.loli.net/2024/01/25/x5AH9VcLdUTi3kr.png" alt="dzslct" style="zoom:67%;" /></li></ul><h4 id="超时获取锁"><a href="#超时获取锁" class="headerlink" title="超时获取锁"></a>超时获取锁</h4><p>调用同步器的 <code>doAcquireNanos(int arg,long nanosTimeout)</code>方法可以<strong>在指定的时间段内获取同步状态</strong>，获取成功返回 true，否则false，该方法提供了 synchronized 所不具备的特性</p><p>在该方法前，先介绍一下响应中断的同步状态获取过程</p><ul><li>当一个线程获取不到锁而被阻塞在 synchronized 之外时，对该线程进行中断操作， 此时该线程的中断标志位会被修改，<strong>但线程依旧会阻塞</strong>在 synchronized 上，等待着获取锁</li><li>在同步器中提供了 <code>acquireInterruptibly(int arg)</code>方法，这个方法在等待获取同步状态时，如果当前<strong>线程被中断，会立刻返回</strong>，并抛出 <code>InterruptedException</code></li></ul><p>而超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”</p><ul><li><p><code>tryAcquireNanos</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">return</span> tryAcquire(arg) ||<br>        doAcquireNanos(arg, nanosTimeout);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>doAcquireNanos</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//1. 根据超时时间和当前时间计算出截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><span class="hljs-comment">//2. 当前线程获得锁出队列</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">// 3.1 重新计算超时时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-comment">// 3.2 已经超时返回false</span><br><span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 3.3 线程阻塞等待 </span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 3.4 线程被中断抛出被中断异常</span><br><span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，获取成功则从该方法返回</p><p>如果线程获失败，则判断是否超时 ，如果没有超时，重新计算超时间隔 <code>nanosTimeout</code>，然后使当前线程等待，当已到设置的超时时间，该线 程会从 <code>LockSupport.parkNanos(Object blocker,long nanos)</code>方法返回，如果 <code>nanosTimeout</code> 小于等于 <code>spinForTimeoutThreshold</code>（1000 纳秒）时，<strong>将不会使该线程进行超时等待，而是进入快速的自旋过程</strong>，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让 <code>nanosTimeout</code> 的超时从整体上表现得不精确</p></li><li><p>超时获取流程图</p></li></ul><img src="https://s2.loli.net/2024/01/26/UWHqYK16ZFeRlbz.png" alt="cshq" style="zoom:67%;" /><hr><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>调用同步器的 <code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点</p><ul><li><code>release(int arg)</code></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 尝试释放锁，tryRelease 返回 true 表示当前线程已经完全释放锁（包括所有重入）</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-comment">// 队列头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 当头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>unparkSuccessor()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 当前节点的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;    <br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 尝试重置状态为 0，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);    <br>    <span class="hljs-comment">// 找到需要 unpark 的节点，当前节点的下一个    </span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;    <br>    <span class="hljs-comment">// 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// AQS 队列 从后至前 找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-comment">// 说明当前线程状态需要被唤醒</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 置换引用</span><br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 找到合适的可以被唤醒的 node，则唤醒线程</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-共享锁"><a href="#4-共享锁" class="headerlink" title="4. 共享锁"></a>4. 共享锁</h3><blockquote><p>共享式获取与独占式获取最主要的区别在于，同一时刻能否有多个线程同时获取到同步状态</p></blockquote><h4 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h4><ul><li><p>调用同步器的 <code>acquireShared(int arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>tryAcquireShared</code>返回一个int值，当值大于等于0时成功获取锁，否则失败，执行<code>doAcquireShared</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 当该节点的前驱节点是头结点且成功获取同步状态则退出自旋</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><ul><li><p>调用 <code>releaseShared(int arg)</code> 方法可以释放同步状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成功释放同步状态之后会继续执行<code>doReleaseShared</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，<strong>必须保证多个线程能够安全的释放同步状态</strong>，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试</p></li></ul><hr><h3 id="5-ReentrantLock实现原理"><a href="#5-ReentrantLock实现原理" class="headerlink" title="5. ReentrantLock实现原理"></a>5. ReentrantLock实现原理</h3><blockquote><p>ReentrantLock重入锁，是实现Lock接口的一个类</p></blockquote><p><strong>特性</strong></p><ul><li>支持重入性</li><li>支持公平锁和非公平锁</li></ul><h4 id="重入性的实现原理"><a href="#重入性的实现原理" class="headerlink" title="重入性的实现原理"></a>重入性的实现原理</h4><p>要想支持重入性，就要解决两个问题</p><ol><li>在线程获取锁的时候，如果当前线程已经获得锁的话，则可以再次成功获取，不会被锁所阻塞</li><li>由于锁会被获取n次，只有锁在被释放n次之后，锁才算是成功释放</li></ol><ul><li><p>以非公平锁，判断当前线程能否获得锁为例，核心方法<code>nonfairTryAcquire</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//2.若被占有，检查占有线程是否是当前线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-comment">// 3. 再次获取，计数加一</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>释放锁<code>tryRelease(int releases)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br><span class="hljs-comment">//1. 同步状态减1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span><br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br><span class="hljs-comment">// 3. 锁未被完全释放，返回false</span><br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="公平锁和非公平锁原理"><a href="#公平锁和非公平锁原理" class="headerlink" title="公平锁和非公平锁原理"></a>公平锁和非公平锁原理</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，<strong>那么锁的获取顺序，就应该符合请求的绝对时间顺序</strong>，也就是 FIFO</p><p>ReentrantLock默认构造非公平锁</p><p>对于非公平锁，只要 CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同</p><ul><li><p>公平获取锁<code>tryAcquire(int acquires)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>与 <code>nonfairTryAcquire(int acquires)</code>比较，唯一不同的位置为判断条件多了 <code>hasQueuedPredecessors()</code>方法，即当前节点是否有前驱节点的判断，如果该方法返回 true 则表示该节点之前有比他更早入队的节点，因此需要等待前驱线程获取并释放锁完成</p></li></ul><p><strong>总结</strong></p><ol><li><strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong></li><li>公平锁<strong>保证请求资源时间上的绝对顺序</strong>，而非公平锁则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong></li><li>公平锁为了保证时间上的绝对顺序，<strong>需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销</strong>因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong></li></ol><hr><h3 id="6-读写锁"><a href="#6-读写锁" class="headerlink" title="6. 读写锁"></a>6. 读写锁</h3><p>之前提到锁（如synchronized，ReentrantLock）基本都是排他锁，这些锁在<strong>同一时刻只允许一个线程进行访问</strong>，而在一些业务场景中，大部分只是读数据，写数据很少，在这种业务场景下，独占锁会出现性能瓶颈<br>针对这种读多写少的情况，Java还提供了另外一个实现Lock接口的<strong>ReentrantReadWriteLock(读写锁)</strong></p><p>而读写锁在<strong>同一时刻可以允许多个读线程访问</strong>，但是在写线程访问时，所有的读线程和其他写线程均被阻塞<br>读写锁维护了一对锁，<strong>一个读锁和一个写锁</strong>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升</p><p> <strong>读锁是共享锁，写锁是独占锁</strong></p><p><strong>特性</strong></p><ol><li><strong>公平性选择</strong>：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</li><li><strong>重入性</strong>：读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁</li><li><strong>锁降级</strong>：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</li></ol><p><strong>简单使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRWLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DataContainer</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(dataContainer::read,<span class="hljs-string">&quot;T1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(dataContainer::write,<span class="hljs-string">&quot;T2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainer&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainer</span>&#123;<br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>        log.debug(<span class="hljs-string">&quot;尝试获取读锁&quot;</span>);<br>        r.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;读取。。。&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放读锁&quot;</span>);<br>            r.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        log.debug(<span class="hljs-string">&quot;尝试获取写锁&quot;</span>);<br>        w.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            log.debug(<span class="hljs-string">&quot;写入。。。&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放写锁&quot;</span>);<br>            w.unlock();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读写状态设计"><a href="#读写状态设计" class="headerlink" title="读写状态设计"></a>读写状态设计</h4><p>在 ReentrantLock 中同步状态表示锁被一个线程重复获取的次数，而读写锁需要在同步状态（state）上<strong>维护多个读线程和一个写线程的状态</strong></p><p>在一个整型变量上维护多种状态，就一定需要“<strong>按位切割使用”</strong>这个变量，读写锁将变量切分成了两个部分<br>高 16 位表示读，低 16 位表示写</p><p><img src="https://s2.loli.net/2024/01/31/58WMwXpUekxEiCO.png" alt="state"></p><p>读写锁<strong>通过位运算</strong>迅速确定读和写各自的状态</p><p>假设当前同步状态值为 S，写状态等于 <code>S&amp;0x0000FFFF</code>（将高 16 位全部抹去），读状态等于 <code>S&gt;&gt;&gt;16</code>（无符号补 0 右移 16 位）<br>当写状态增加 1 时，等 于 S+1，当读状态增加 1 时，等于 S+(1&lt;&lt;16)，也就是 <code>S+0x00010000</code> </p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><blockquote><p>写锁是一个支持重进入的排它锁</p></blockquote><p><strong>写锁的获取，ReentrantReadWriteLock 的 <code>tryAcquire</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 1. 获取写锁当前的同步状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">// 2. 获取写锁获取的次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="hljs-comment">// 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话</span><br><span class="hljs-comment">// 当前线程获取写锁失败</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">// Reentrant acquire</span><br><span class="hljs-comment">// 3.2 当前线程获取写锁，支持可重复加锁</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 3.3 写锁未被任何线程获取，当前线程可获取写锁</span><br>    <span class="hljs-keyword">if</span> (writerShouldBlock() ||<br>        !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法除了重入条件之外，增加了一个读锁是否存在的判断</p><ul><li>如果存在读锁，则写锁不能被获取，因为<strong>要确保写锁的操作对读锁可见</strong>，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作</li></ul><p><strong>写锁的释放 <code>tryRelease</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br><span class="hljs-comment">//1. 同步状态减去写状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><span class="hljs-comment">//2. 当前写状态是否为0，为0则释放写锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (free)<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//3. 不为0则更新同步状态</span><br>    setState(nextc);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>与ReentrantLock基本一致，需要注意的是，减少写状态<code> int nextc = getState() - releases;</code><br>只需要用<strong>当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的</strong></p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><blockquote><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取</p></blockquote><p>如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁 时，写锁已被其他线程获取，则进入等待状态。</p><p>其中 <code>getReadHoldCount()</code>方法，作用是返回当前线程获取读锁的次数。<strong>读状态是所有线程获取读锁次数的总和</strong>，<strong>而每个线程各自获取 读锁的次数只能选择保存在 ThreadLocal 中</strong>，由线程自身维护</p><p><strong>读锁的获取<code>tryAcquireShared</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">//1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前</span><br><span class="hljs-comment">// 线程获取读锁失败返回-1</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br><span class="hljs-comment">//2. 当前线程获取读锁</span><br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br><span class="hljs-comment">//3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法</span><br><span class="hljs-comment">//返回当前获取读锁的次数</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">//4. 处理在第二步中CAS操作失败的自旋已经实现重入性</span><br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是 <strong>当写锁被其他线程获取后，读锁获取失败</strong>，否则获取成功利用CAS更新同步状态<br>当前同步状态需要加上<code>SHARED_UNIT（(1 &lt;&lt; SHARED_SHIFT)即0x00010000）</code>因为同步状态的高16位用来表示读锁被获取的次数<br>如果CAS失败或者已经获取读锁的线程再次获取读锁时，是靠<code>fullTryAcquireShared</code>方法实现的</p><p><strong>读锁的释放 <code>tryReleaseShared</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 前面还是为了实现getReadHoldCount等新功能</span><br>    <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>        <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>            firstReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            firstReaderHoldCount--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>            rh = readHolds.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>            readHolds.remove();<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>        &#125;<br>        --rh.count;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><span class="hljs-comment">// 读锁释放 将同步状态减去读状态即可</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span><br>            <span class="hljs-comment">// but it may allow waiting writers to proceed if</span><br>            <span class="hljs-comment">// both read and write locks are now free.</span><br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><blockquote><p> 锁降级指的是写锁降级成为读锁</p></blockquote><p>锁降级是指把持住写锁，再获取到读锁，随后释放写锁的过程</p><p><strong>源码中的示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">processCachedData</span><span class="hljs-params">()</span> &#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 在获得写锁之前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 重新检查状态，因为另一个线程可能获取</span><br>                <span class="hljs-comment">// 获得写锁并在操作之前更改状态</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>            cacheValid = <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-comment">// 通过在释放写锁之前获取读锁来降级</span><br>          rwl.readLock().lock();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          rwl.writeLock().unlock(); <span class="hljs-comment">// 释放写锁，继续保留读锁</span><br>        &#125;<br>      &#125;<br> <br>      <span class="hljs-keyword">try</span> &#123;<br>        use(data);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        rwl.readLock().unlock();<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-Condition原理"><a href="#7-Condition原理" class="headerlink" title="7. Condition原理"></a>7. Condition原理</h3><p><strong>Object的wait和notify&#x2F;notifyAll是与对象监视器配合完成线程间的等待&#x2F;通知机制，而Condition与Lock配合完成等待通知机制，前者是Java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong></p><p><strong>功能特性</strong></p><ol><li>Condition能够支持不响应中断，而通过使用Object方式不支持</li><li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个</li><li>Condition能够支持超时时间的设置，而Object不支持</li></ol><p>ConditionObject <strong>是同步器AQS的内部类</strong>，因为 Condition 的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理，每个 Condition 对象都包含着一个队列（等待队列），<strong>该队列是 Condition 对象实现等待&#x2F;通知功能的关键</strong></p><p>Condition 的实现，主要包括：等待队列、等待和通知</p><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><blockquote><p>等待队列是一个 FIFO 的队列</p></blockquote><p>队列中的每个节点都包含了一个线程引用，就是在 Condition 对象上等待的线程</p><p>如果一个线程调用了 <code>Condition.await()</code>方法，该线程将会释放锁、构造成节点加入等待队列并进入等待状态<br><strong>节点的定义复用了同步器中节点的定义</strong>，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类 <code>AbstractQueuedSynchronizer.Node</code></p><p>一个 Condition 包含一个等待队列，Condition 拥有首节点（firstWaiter）和尾节点 （lastWaiter）<br>当前线程调用 <code>Condition.await()</code>方法，将会以当前线程构造节点，<strong>并将节点从尾部加入等待队列</strong></p><p><strong>基本结构</strong></p><img src="https://s2.loli.net/2024/01/31/21jLQ8Cgb6aRHOB.png" alt="dddl" style="zoom:80%;" /><p>Condition 拥有首尾节点的引用，而新增节点只需要将原有的尾节点 nextWaiter 指向它，并且更新尾节点即可<br><strong>节点引用更新的过程并没有使用 CAS 保证</strong>，因为调用 await()方法的线程<strong>必定是获取了锁的线程</strong></p><p>在 Object 的Monitor模型上，一个对象拥有一个同步队列和等待队列，而并发包中的同步器拥有一个同步队列和多个等待队列</p><img src="https://s2.loli.net/2024/01/31/extsUIrRQTfXVKJ.png" alt="tbq" style="zoom:80%;" /><p><strong>Condition 的实现是同步器的内部类</strong>，每个 Condition 都能够访问同步器提供的方法，每个 Condition 都拥有所属同步器的引用</p><h4 id="等待（await）"><a href="#等待（await）" class="headerlink" title="等待（await）"></a>等待（await）</h4><blockquote><p>Condition 的 await()方法（或者 await 开头的方法）会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态</p></blockquote><p>从队列（同步队列和等待队列）的角度看 await()方法， 当调用 await()方法时，<strong>相当于同步队列的首节点（获取了锁的节点）移动到 Condition 的等待队列中</strong></p><p><strong>Condition 的 await()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><span class="hljs-comment">// 1. 将当前线程包装成Node，尾插入到等待队列中</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br><span class="hljs-comment">// 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br><span class="hljs-comment">// 3. 当前线程进入到等待状态</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-comment">// 4. 自旋等待获取到同步状态（即获取到lock）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 如果被取消则清理</span><br>        unlinkCancelledWaiters();<br><span class="hljs-comment">// 5. 处理被中断的情况</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><p>从队列的角度去看，当前线程加入 Condition 的等待队列，同步队列的首节点<strong>并不会直接加入</strong>等待队列，而是通过 <code>addConditionWaiter()</code>方法<strong>把当前线程构造成一个新的节点并将其加入等待队列中</strong></p><p><img src="https://s2.loli.net/2024/01/31/yJdzuPGZ1H76h3k.png" alt="await"></p><h4 id="通知（signal）"><a href="#通知（signal）" class="headerlink" title="通知（signal）"></a>通知（signal）</h4><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 <code>isHeldExclusively()</code>检查，接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程</p><p><strong>signal源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//1. 先检测当前线程是否已经获取lock</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            lastWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//1. 将头结点从等待队列中移除</span><br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//2. while中transferForSignal方法对头结点做真正的处理</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-comment">//1. 更新状态为0</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//2.将该节点移入到同步队列中去</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过AQS的 <code>enq(Node node)</code>方法，等待队列中的头节点线程安全地移动到同步队列，<strong>当节点移动到同步队列后，当前线程再使用 LockSupport 唤醒该节点的线程</strong></p><p>被唤醒后的线程，将从 <code>await()</code>方法中的 <code>while</code> 循环中退出<code>isOnSyncQueue(Node  node)</code>方法返回 true，节点已经在同步队列中，进而调用AQS的 <code>acquireQueued()</code>方法加入到获取同步状态的竞争中</p><p>成功获取同步状态之后，被唤醒的线程将从先前调用的 await()方法返回，此时该线程已经成功地获取了锁。 <code>signalAll()</code>方法相当于对等待队列中的每个节点均执行一次<code>signal()</code>方 法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><p><strong>过程图</strong></p><p><img src="https://s2.loli.net/2024/01/31/Qiv3oElJ1OrsaDg.png" alt="signal"></p><h2 id="九、并发工具类"><a href="#九、并发工具类" class="headerlink" title="九、并发工具类"></a>九、并发工具类</h2><p>在 JDK 的并发包里提供了几个非常有用的并发工具类</p><p>CountDownLatch、 CyclicBarrier 和 Semaphore 工具类提供了一种并发流程控制的手段，Exchanger 工具类则提供了在线程间交换数据的一种手段</p><h3 id="1-Semaphore"><a href="#1-Semaphore" class="headerlink" title="1.  Semaphore"></a>1.  Semaphore</h3><blockquote><p> Semaphore（信号量）是用来控制并发线程数量</p></blockquote><p>Semaphore就相当于一个许可证，线程需要先通过<code>acquire()</code>方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过<code>release()</code>方法将许可证归还，以便其他线程能够获得许可证继续执行。</p><p>Semaphore可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程个数最多只有10个。在限制资源使用的应用场景下，Semaphore是特别合适的。</p><p><strong>主要API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//获取许可，如果无法获取到，则阻塞等待直至能够获取为止</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException <br><br><span class="hljs-comment">//同acquire方法功能基本一样，只不过该方法可以一次获取多个许可</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">//释放许可</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//释放指定个数的许可</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><br><span class="hljs-comment">//尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//与tryAcquire方法一致，只不过这里可以指定获取多个许可</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span><br><br><span class="hljs-comment">//尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">//与上一个方法一致，只不过这里能够获取多个许可</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br><span class="hljs-comment">//返回当前可用的许可证个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">availablePermits</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//返回正在等待获取许可证的线程数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getQueueLength</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//是否有线程正在等待获取许可证</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedThreads</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//获取所有正在等待许可的线程集合</span><br>Collection&lt;Thread&gt; <span class="hljs-title function_">getQueuedThreads</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p><strong>简单运用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSemaphore</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>                    sleep(<span class="hljs-number">500L</span>);<br>                    log.debug(<span class="hljs-string">&quot;end&quot;</span>);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/31/K6u53x8rawnNVHP.png" alt="sema"></p><ul><li>可以发现同一时刻控制为三个线程并行</li></ul><h3 id="2-Exchanger"><a href="#2-Exchanger" class="headerlink" title="2. Exchanger"></a>2. Exchanger</h3><blockquote><p>进行线程间的数据交换</p></blockquote><p>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据</p><p>这两个线程通过 <code>exchange()</code> 方法交换数据，如果第一个线程先执行 <code>exchange()</code>方法，它会一直等待第二个线程也执行 <code>exchange()</code> 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p><p><strong>主要API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点</span><br><span class="hljs-comment">//将数据交换给另一个线程，同时返回获取的数据</span><br>V <span class="hljs-title function_">exchange</span><span class="hljs-params">(V x)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">//同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间</span><br>V <span class="hljs-title function_">exchange</span><span class="hljs-params">(V x, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException <br></code></pre></td></tr></table></figure><p><strong>举例</strong>[^引用]</p><p>Exchanger 也可以用于校对工作， 比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采 用 AB 岗两人进行录入，录入到 Excel 之后，系统需要加载这两个 Excel，并对两个 Excel 数据进行校对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        threadPool.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;银行流水 A&quot;</span>; <span class="hljs-comment">// A 录入银行流水数据</span><br>                exgr.exchange(A);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;);<br>        threadPool.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;银行流水 B&quot;</span>; <span class="hljs-comment">// B 录入银行流水数据</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;A 和 B 数据是否一致：&quot;</span> + A.equals(B) + <span class="hljs-string">&quot;，A 录入的是：&quot;</span><br>                        + A + <span class="hljs-string">&quot;，B 录入是：&quot;</span> + B);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;);<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-CountDownLatch"><a href="#3-CountDownLatch" class="headerlink" title="3. CountDownLatch"></a>3. CountDownLatch</h3><blockquote><p>CountDownLatch （倒计时锁）用来进行线程同步协作，允许一个或多个线程等待其他线程完成操作</p></blockquote><p>在多线程协作完成业务功能时，有时候主线程需要等待其他多个线程完成任务之后，在这种的业务场景下，通常可以使用Thread类的join方法，让主线程等待被join的线程执行完，使用线程间消息通信机制也可以完成。但CountDownLatch，可以十分方便的完成所说的这种业务场景</p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要 down 的次数</li></ul><p>常用API：</p><ul><li><code>public void await() </code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</li><li><code>public void countDown()</code>：计数器进行减 1（down 1）</li></ul><p><strong>简单运用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownTest</span> &#123;<br>    <span class="hljs-comment">// 模拟10人进入游戏倒计时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            <span class="hljs-comment">// 线程中需要引用值不变的常量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> j;<br>            service.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>                    sleep(random.nextInt(<span class="hljs-number">2</span>));<br>                    all[index] = i + <span class="hljs-string">&quot;%&quot;</span>;<br>                    <span class="hljs-comment">// \r代表覆盖之前的打印</span><br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<br>                &#125;<br>                <span class="hljs-comment">// 当前线程运行结束就将计数器减一</span><br>                latch.countDown();<br>            &#125;);<br>        &#125;<br>        latch.await();<br>        <span class="hljs-comment">// 只有当所有的线程到达 100% 后才会打印游戏开始</span><br>        System.out.println(<span class="hljs-string">&quot;\n游戏开始&quot;</span>);<br>        service.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-CyclicBarrier"><a href="#4-CyclicBarrier" class="headerlink" title="4. CyclicBarrier"></a>4. CyclicBarrier</h3><blockquote><p>CyclicBarrier（循环屏障）用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p></blockquote><p>它要做的事情是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</p><p>如跑步比赛，只有当所有的运动员（线程）到达跑道（屏障）才开始比赛，且当这一组比赛结束，下一组还能重复利用（循环）这个跑道</p><p><strong>构造方法</strong></p><ul><li><pre><code class="java">// 参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 已经到达了屏障，然后当前线程被阻塞public CyclicBarrier(int parties)<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string">  </span><br><span class="hljs-string">- `</span><span class="hljs-string">``</span>Java<br>  <span class="hljs-comment">// 于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景</span><br>  <span class="hljs-keyword">public</span> CyclicBarrier(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)<br></code></pre></td></tr></table></figure></code></pre></li></ul><p><strong>常用API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//等到所有的线程都到达指定的临界点</span><br>await() <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException <br><br><span class="hljs-comment">//与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止</span><br>await(<span class="hljs-type">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException, <br>BrokenBarrierException, TimeoutException <br><br><span class="hljs-comment">//获取当前有多少个线程阻塞等待在临界点上</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getNumberWaiting</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//用于查询阻塞等待的线程是否被中断</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isBroken</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p><strong>简单运用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;task1 task2 finish...&quot;</span>);<br>    &#125;);<br>     <span class="hljs-comment">// 循环重用</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        service.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;task1 begin...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                barrier.await(); <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        service.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;task2 begin...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                barrier.await(); <br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    service.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-CDL与CB的区别"><a href="#5-CDL与CB的区别" class="headerlink" title="5. CDL与CB的区别"></a>5. CDL与CB的区别</h3><p>CountDownLatch与CyclicBarrier都可以理解成维护的就是一个计数器，但侧重点不同：</p><ol><li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行<br>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行<br>CountDownLatch强调一个线程等多个线程完成某件事情<br>CyclicBarrier是多个线程互等，等大家都完成，再携手共进</li><li>调用CountDownLatch的<code>countDown()</code>方法后，当前线程并不会阻塞，会继续往下执行<br>CyclicBarrier的<code>await()</code>方法，会阻塞当前线程，直到指定的线程全部都到达了指定点，才能继续往下执行</li><li>CountDownLatch方法比较少，操作比较简单<br>CyclicBarrier提供的方法更多，**并且CyclicBarrier的构造方法可以传入<code>barrierAction</code>**，指定业务功能</li><li>CountDownLatch是不能复用的，而CyclicBarrier是可以通过<code>reset()</code>复用的</li></ol><h2 id="十、并发容器"><a href="#十、并发容器" class="headerlink" title="十、并发容器"></a>十、并发容器</h2><h3 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1. ConcurrentHashMap"></a>1. ConcurrentHashMap</h3><blockquote><p>ConcurrentHashMap 是线程安全且高效的 HashMap</p></blockquote><p>三种集合容器对比：</p><ul><li>HashMap 是线程不安全的，性能好</li><li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li><li>ConcurrentHashMap 保证了线程安全，而且效率高，性能好</li></ul><p><strong>JDK 1.6版本中</strong></p><p>ConcurrentHashMap、<strong>利用了锁分段的思想提高了并发度</strong><br>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是，<strong>所有访问 HashTable 的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中 一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争</strong>，从而提高并发访问效率，<strong>这就是 ConcurrentHashMap 所使用的锁分段技术</strong>：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</p><ul><li><p>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障</p></li><li><p>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表</p></li></ul><p><strong>JDK 1.8版本中</strong></p><p>ConcurrentHashMap就有了很大的变化，<strong>1.8版本舍弃了segment</strong>，并且大量使用了synchronized，以及CAS无锁操作以保证ConcurrentHashMap操作的线程安全性。</p><p>实际上，synchronized做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，因此，使用synchronized相较于ReentrantLock的性能会持平甚至在某些情况更优另外，底层数据结构改变为<strong>采用数组+链表+红黑树的数据形式</strong></p><h4 id="关键属性及类"><a href="#关键属性及类" class="headerlink" title="关键属性及类"></a>关键属性及类</h4><p><strong>关键属性</strong></p><ul><li><code>volatile Node&lt;K,V&gt;[] table</code>：装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，<strong>数组的大小总是为2的幂次方</strong></li><li><code>volatile Node&lt;K,V&gt;[] nextTable</code>：扩容时使用，平时为null，只有在扩容的时候才为非null</li><li><code>volatile int sizeCtl</code>：<strong>用来控制table数组的大小</strong>，根据是否初始化和是否正在扩容有几种情况： <ul><li><strong>当值为负数时：</strong>为-1表示正在初始化，为-N则表示当前正有N-1个线程进行扩容操作</li><li><strong>当值为正数时：</strong><ul><li>当前数组为null的话表示table在初始化过程中，sizeCtl表示为需要新建数组的长度</li><li>若已经初始化了，表示下次扩容时的触发条件（阈值，元素个数，不是数组的长度）</li></ul></li><li><strong>当值为0时</strong>：即数组长度为默认初始值</li></ul></li><li><code>sun.misc.Unsafe U</code>在ConcurrentHashMap的实现中可以看到大量的<code>U.compareAndSwapXXXX</code>的方法去修改ConcurrentHashMap的一些属性，<ul><li>这些方法实际上是利用了CAS保证了线程安全性，大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的，该类提供了一些可以直接操控内存和线程的底层操作，该成员变量的获取是在静态代码块中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        U = sun.misc.Unsafe.getUnsafe();<br>.......<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>关键内部类</strong></p><ul><li><code>Node</code> 类实现了<code>Map.Entry</code>接口，主要存放键值对，并且具有next域</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">volatile</span> V val;<br>        <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证多线程的可见性</p><ul><li><code>TreeNode</code> 树节点，继承于承载数据的Node类，而红黑树的操作是针对<code>TreeBin</code>类的，从该类的注释也可以看出，<strong>也就是TreeBin会将TreeNode进行再一次封装</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">**<br> * Nodes <span class="hljs-keyword">for</span> use in TreeBins<br> */<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>        TreeNode&lt;K,V&gt; left;<br>        TreeNode&lt;K,V&gt; right;<br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-type">boolean</span> red;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>TreeBin</code> 这个类并不负责包装用户的键值信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap<strong>数组中，存放的是TreeBin对象，而不是TreeNode对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; root;<br>        <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>        <span class="hljs-keyword">volatile</span> Thread waiter;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>        <span class="hljs-comment">// values for lockState</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>ForwardingNode</code> 在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;<br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>   .....<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><p><strong>CAS关键操作</strong></p><blockquote><p> 几个常用的利用CAS算法来保障线程安全的操作</p></blockquote><ul><li><code>tabAt()</code>：用来获取table数组中索引为 i 的Node元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>casTabAt()</code>：利用CAS操作设置table数组中索引为 i 的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>setTabAt()</code>：用来设置table数组中索引为 i 的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em>以下代码分析 参考文章</em></p><ul><li><a href="https://github.com/Seazean/JavaNote/blob/main/Prog.md">JavaNote&#x2F;Seazean</a></li><li>[Java-concurrency&#x2F;14.并发容器之ConcurrentHashMap(JDK 1.8版本)](<a href="https://github.com/CL0610/Java-concurrency/blob/master/14.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap">https://github.com/CL0610/Java-concurrency/blob/master/14.并发容器之ConcurrentHashMap</a>(JDK 1.8版本))</li></ul><hr><h4 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a><strong>构造器方法</strong></h4><p>一共提供了如下几个构造器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span><br>ConcurrentHashMap()<br><span class="hljs-comment">// 2. 给定map的大小</span><br>ConcurrentHashMap(<span class="hljs-type">int</span> initialCapacity) <br><span class="hljs-comment">// 3. 给定一个map</span><br>ConcurrentHashMap(Map&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; m)<br><span class="hljs-comment">// 4. 给定map的大小以及加载因子</span><br>ConcurrentHashMap(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)<br><span class="hljs-comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span><br>ConcurrentHashMap(<span class="hljs-type">int</span> initialCapacity,<span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)<br></code></pre></td></tr></table></figure><ul><li><code>ConcurrentHashMap(int initialCapacity)</code> 源码为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br><span class="hljs-comment">//1. 小于0直接抛异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br><span class="hljs-comment">//3. 赋值给sizeCtl</span><br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当调用构造器方法之后，sizeCtl的大小应该就代表了ConcurrentHashMap的大小，即table数组长度</strong></p><ul><li><code>tableSizeFor(int c)</code>源码为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> c - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，<strong>ConcurrentHashMap的大小一定是2的幂次方</strong></p><p>当指定大小为18时，为了满足2的幂次方特性，实际上的大小为2的5次方（32）另外，<strong>调用构造器方法的时候并未构造出table数组</strong>（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，<strong>当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组</strong></p><hr><h4 id="initTable-初始化方法"><a href="#initTable-初始化方法" class="headerlink" title="initTable()初始化方法"></a><strong>initTable()初始化方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 1. 保证只有一个线程正在进行初始化操作</span><br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 2. 得出数组的大小</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">// 3. 这里才真正的初始化数组</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br><span class="hljs-comment">// 4. 计算数组中可用的大小：n*0.75（加载因子）</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p>若当前已经有一个线程正在初始化即sizeCtl值变为-1，<strong>这个时候其他线程在 If判断为true 从而调用<code>Thread.yield()</code>让出CPU时间片</strong>正在进行初始化的线程会调用<code>U.compareAndSwapInt</code>将sizeCtl改为-1即正在初始化的状态</p><p>如果选择是无参的构造器的话，会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，可用大小为12</p><hr><h4 id="put-存入方法"><a href="#put-存入方法" class="headerlink" title="put()存入方法"></a><strong>put()存入方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 第三个参数 onlyIfAbsent 为 false 表示哈希表中存在相同的 key 时【用当前数据覆盖旧数据】</span><br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 【ConcurrentHashMap 不能存放 null 值】</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 重哈希，以减小Hash冲突</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-comment">// 表示当前 键值对 封装成 node 后插入到指定桶位后，在桶位中的所属链表的下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// tab 引用当前 map 的数组 table，开始自旋</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        <span class="hljs-comment">// f 表示桶位的头节点，n 表示哈希表数组的长度</span><br>        <span class="hljs-comment">// i 表示 key 通过寻址计算后得到的桶位下标，fh 表示桶位头结点的 hash 值</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 【CASE1】：表示当前 map 中的 table 尚未初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 懒惰初始化</span><br>            tab = initTable();<br>        <span class="hljs-comment">// 【CASE2】：i 表示 key 使用【寻址算法】得到 key 对应数组的下标位置，tabAt 获取指定桶位的头结点f</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 对应的数组为 null 说明没有哈希冲突，直接新建节点添加到表中</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 【CASE3】：逻辑说明数组已经被初始化，并且当前 key 对应的位置不为 null</span><br>        <span class="hljs-comment">// 条件成立表示当前桶位的头结点为 FWD 结点，表示目前 map 正处于扩容过程中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            <span class="hljs-comment">// 当前线程【需要去帮助哈希表完成扩容】</span><br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-comment">// 【CASE4】：哈希表没有在扩容，当前桶位可能是链表也可能是红黑树</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当插入 key 存在时，会将旧值赋值给 oldVal 返回</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 【锁住当前 key 寻址的桶位的头节点】</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-comment">// 这里重新获取一下桶的头节点有没有被修改，因为可能被其他线程修改过，这里是线程安全的获取</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 【头节点的哈希值大于 0 说明当前桶位是普通的链表节点】</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 当前的插入操作没出现重复的 key，追加到链表的末尾，binCount表示链表长度 -1</span><br>                        <span class="hljs-comment">// 插入的key与链表中的某个元素的 key 一致，变成替换操作，binCount 表示第几个节点冲突</span><br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 迭代循环当前桶位的链表，e 是每次循环处理节点，e 初始是头节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            <span class="hljs-comment">// 当前循环节点 key</span><br>                            K ek;<br>                            <span class="hljs-comment">// key 的哈希值与当前节点的哈希一致，并且 key 的值也相同</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                <span class="hljs-comment">// 把当前节点的 value 赋值给 oldVal</span><br>                                oldVal = e.val;<br>                                <span class="hljs-comment">// 允许覆盖</span><br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    <span class="hljs-comment">// 新数据覆盖旧数据</span><br>                                    e.val = value;<br>                                <span class="hljs-comment">// 跳出循环</span><br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-comment">// 如果下一个节点为空，把数据封装成节点插入链表尾部，【binCount 代表长度 - 1】</span><br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 当前桶位头节点是红黑树</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                              value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 条件成立说明当前是链表或者红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果 binCount &gt;= 8 表示处理的桶位一定是链表，说明长度是 9</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    <span class="hljs-comment">// 树化</span><br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 统计当前 table 一共有多少数据，判断是否达到扩容阈值标准，触发扩容</span><br>    <span class="hljs-comment">// binCount = 0 表示当前桶位为 null，node 可以直接放入，2 表示当前桶位已经是红黑树</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>spread()</code>：重哈希，以减小Hash冲突</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">spread</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; HASH_BITS; <span class="hljs-comment">// 0111 1111 1111 1111 1111 1111 1111 1111</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>从整体而言，为了解决线程安全的问题，ConcurrentHashMap使用了synchronized和CAS的方式</strong></p><p>ConcurrentHashMap结构图</p><p><img src="https://s2.loli.net/2024/01/31/W2P7aLX9MoCI8kO.png" alt="cctmap"></p><p>ConcurrentHashMap是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是<strong>标准的链地址的解决方式</strong>，将hash值相同的节点构成链表的形式，称为“拉链法”，另外，在1.8版本中为了防止拉链过长，<strong>当链表的长度大于8的时候会将链表转换成红黑树</strong>。<strong>table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点</strong>。</p><p><strong>整体流程</strong>：</p><ol><li>首先对于每一个放入的值，首先利用spread方法对key的HashCode进行一次hash计算，由此来确定这个值在table中的位置</li><li>如果当前table数组还未初始化，先将table数组进行初始化操作</li><li>如果这个位置是null的，那么使用CAS操作直接放入</li><li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点<code>fh==MOVED</code>(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容</li><li>如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的<strong>链表的头节点</strong>。需要依次向后遍历确定这个新加入的值所在位置。<strong>如果遇到key相同的节点，则只需要覆盖该结点的value值即可</strong>。否则依次向后遍历，直到链表尾插入这个结点</li><li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点</li><li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树</li><li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</li></ol><hr><h4 id="get-获取方法"><a href="#get-获取方法" class="headerlink" title="get()获取方法"></a><strong>get()获取方法</strong></h4><ul><li><p><code>get()</code>：获取指定数据的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-comment">// 重hash获取哈希值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-comment">// 判断当前哈希表的数组是否初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">// 如果 table 已经初始化，进行【哈希寻址】，映射到数组对应索引处，获取该索引处的头节点</span><br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 对比头结点 hash 与查询 key 的 hash 是否一致</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-comment">// 进行值的判断，如果成功就说明当前节点就是要查询的节点，直接返回</span><br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">// 当前槽位的【哈希值小于0】说明是红黑树节点或者是正在扩容的 fwd 节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 当前桶位是【链表】，循环遍历查找</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>ForwardingNode的find()</code>：转移节点的查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;<br>    <span class="hljs-comment">// 获取新表的引用</span><br>    outer: <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;)  &#123;<br>        <span class="hljs-comment">// e 表示在扩容而创建新表使用寻址算法得到的桶位头结点，n 表示为扩容而创建的新表的长度</span><br>        Node&lt;K,V&gt; e; <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> || tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// 在新表中重新定位 hash 对应的头结点，表示在 oldTable 中对应的桶位在迁移之前就是 null</span><br>            (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> eh; K ek;<br>            <span class="hljs-comment">// 【哈希相同值也相同】，表示新表当前命中桶位中的数据，即为查询想要数据</span><br>            <span class="hljs-keyword">if</span> ((eh = e.hash) == h &amp;&amp; ((ek = e.key) == k || (ek != <span class="hljs-literal">null</span> &amp;&amp; k.equals(ek))))<br>                <span class="hljs-keyword">return</span> e;<br><br>            <span class="hljs-comment">// eh &lt; 0 说明当前新表中该索引的头节点是 TreeBin 类型，或者是 FWD 类型</span><br>            <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 在并发很大的情况下新扩容的表还没完成可能【再次扩容】，在此方法处再次拿到 FWD 类型</span><br>                <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ForwardingNode) &#123;<br>                    <span class="hljs-comment">// 继续获取新的 fwd 指向的新数组的地址，递归了</span><br>                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;<br>                    <span class="hljs-keyword">continue</span> outer;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 说明此桶位为 TreeBin 节点，使用TreeBin.find 查找红黑树中相应节点。</span><br>                    <span class="hljs-keyword">return</span> e.find(h, k);<br>            &#125;<br><br>            <span class="hljs-comment">// 逻辑到这说明当前桶位是链表，将当前元素指向链表的下一个元素，判断当前元素的下一个位置是否为空</span><br>            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">// 条件成立说明迭代到链表末尾，【未找到对应的数据，返回 null】</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="transfer-扩容方法"><a href="#transfer-扩容方法" class="headerlink" title="transfer()扩容方法"></a><strong>transfer()扩容方法</strong></h4><p>扩容机制：</p><ul><li>当链表中元素个数超过 8 个，数组的大小还未超过 64 时，此时进行数组的扩容，如果超过则将链表转化成红黑树</li><li>put 数据后调用 addCount() 方法，判断当前哈希表的容量超过阈值 sizeCtl，超过进行扩容</li><li>增删改线程发现其他线程正在扩容，帮其扩容</li></ul><p>源码：</p><ul><li><p><code>transfer()</code>：数据转移到新表中，完成扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-comment">// n 表示扩容之前 table 数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <span class="hljs-comment">// stride 表示分配给线程任务的步长，默认就是 16 </span><br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE;<br>    <span class="hljs-comment">// 如果当前线程为触发本次扩容的线程，需要做一些扩容准备工作，【协助线程不做这一步】</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建一个容量是之前【二倍的 table 数组】</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 把新表赋值给对象属性 nextTable，方便其他线程获取新表</span><br>        nextTable = nextTab;<br>        <span class="hljs-comment">// 记录迁移数据整体位置的一个标记，transferIndex 计数从1开始不是 0，所以这里是长度，不是长度-1</span><br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-comment">// 新数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>    <span class="hljs-comment">// 当某个桶位数据处理完毕后，将此桶位设置为 fwd 节点，其它写线程或读线程看到后，可以从中获取到新表</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <span class="hljs-comment">// 推进标记</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 完成标记</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// i 表示分配给当前线程任务，执行到的桶位</span><br>    <span class="hljs-comment">// bound 表示分配给当前线程任务的下界限制，因为是倒序迁移，16 迁移完 迁移 15，15完成去迁移14</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <br>        <span class="hljs-comment">// 给当前线程【分配任务区间】</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-comment">// 分配任务的开始下标，分配任务的结束下标</span><br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>         <br>            <span class="hljs-comment">// --i 让当前线程处理下一个索引，true说明当前的迁移任务尚未完成，false说明线程已经完成或者还未分配</span><br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 迁移的开始下标，小于0说明没有区间需要迁移了，设置当前线程的 i 变量为 -1 跳出循环</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 逻辑到这说明还有区间需要分配，然后给当前线程分配任务，</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      <span class="hljs-comment">// 判断区间是否还够一个步长，不够就全部分配</span><br>                      nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-comment">// 当前线程的结束下标</span><br>                bound = nextBound;<br>                <span class="hljs-comment">// 当前线程的开始下标，上一个线程结束的下标的下一个索引就是这个线程开始的下标</span><br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 任务分配结束，跳出循环执行迁移操作</span><br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 【分配完成，开始数据迁移操作】</span><br>        <span class="hljs-comment">// 【CASE1】：i &lt; 0 成立表示当前线程未分配到任务，或者任务执行完了</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-comment">// 如果迁移完成</span><br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<span class="hljs-comment">// help GC</span><br>                table = nextTab;<span class="hljs-comment">// 新表赋值给当前对象</span><br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">// 扩容阈值为 2n - n/2 = 3n/2 = 0.75*(2n)</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当前线程完成了分配的任务区间，可以退出，先把 sizeCtl 赋值给 sc 保留</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 判断当前线程是不是最后一个线程，不是的话直接 return，</span><br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">// 所以最后一个线程退出的时候，sizeCtl 的低 16 位为 1</span><br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 【这里表示最后一个线程需要重新检查一遍是否有漏掉的区间】</span><br>                i = n;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 【CASE2】：当前桶位未存放数据，只需要将此处设置为 fwd 节点即可。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>        <span class="hljs-comment">// 【CASE3】：说明当前桶位已经迁移过了，当前线程不用再处理了，直接处理下一个桶位即可</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>; <br>        <span class="hljs-comment">// 【CASE4】：当前桶位有数据，而且 node 节点不是 fwd 节点，说明这些数据需要迁移</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 【锁住头节点】</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-comment">// 二次检查，防止头节点已经被修改了，因为这里才是线程安全的访问</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">// 【迁移数据的逻辑，和 HashMap 相似】</span><br>                    <span class="hljs-comment">// ln 表示低位链表引用</span><br>                    <span class="hljs-comment">// hn 表示高位链表引用</span><br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">// 哈希 &gt; 0 表示当前桶位是链表桶位</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 和 HashMap 的处理方式一致，与老数组长度相与，16 是 10000</span><br>                        <span class="hljs-comment">// 判断对应的 1 的位置上是 0 或 1 分成高低位链表</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                        Node&lt;K,V&gt; lastRun = f;<br>                        <span class="hljs-comment">// 遍历链表，寻找【逆序看】最长的对应位相同的链表</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                            <span class="hljs-comment">// 将当前节点的哈希 与 n</span><br>                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>                            <span class="hljs-comment">// 如果当前值与前面节点的值 对应位 不同，则修改 runBit，把 lastRun 指向当前节点</span><br>                            <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                runBit = b;<br>                                lastRun = p;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 判断筛选出的链表是低位的还是高位的</span><br>                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                            ln = lastRun;<span class="hljs-comment">// ln 指向该链表</span><br>                            hn = <span class="hljs-literal">null</span>;<span class="hljs-comment">// hn 为 null</span><br>                        &#125;<br>                        <span class="hljs-comment">// 说明 lastRun 引用的链表为高位链表，就让 hn 指向高位链表头节点</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            hn = lastRun;<br>                            ln = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 从头开始遍历所有的链表节点，迭代到 p == lastRun 节点跳出循环</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>                                <span class="hljs-comment">// 【头插法】，从右往左看，首先 ln 指向的是上一个节点，</span><br>                                <span class="hljs-comment">// 所以这次新建的节点的 next 指向上一个节点，然后更新 ln 的引用</span><br>                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>                            <span class="hljs-keyword">else</span><br>                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>                        &#125;<br>                        <span class="hljs-comment">// 高低位链设置到新表中的指定位置</span><br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        <span class="hljs-comment">// 老表中的该桶位设置为 fwd 节点</span><br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 条件成立：表示当前桶位是 红黑树结点</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;<br>                        TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                        <span class="hljs-comment">// 迭代 TreeBin 中的双向链表，从头结点至尾节点</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                            <span class="hljs-comment">// 迭代的当前元素的 hash</span><br>                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;<br>                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;<br>                                (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                            <span class="hljs-comment">// 条件成立表示当前循环节点属于低位链节点</span><br>                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)<br>                                    lo = p;<br>                                <span class="hljs-keyword">else</span><br>                                    <span class="hljs-comment">//【尾插法】</span><br>                                    loTail.next = p;<br>                                <span class="hljs-comment">// loTail 指向尾节点</span><br>                                loTail = p;<br>                                ++lc;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)<br>                                    hi = p;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = p;<br>                                hiTail = p;<br>                                ++hc;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 拆成的高位低位两个链，【判断是否需要需要转化为链表】，反之保持树化</span><br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                        (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                        (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>helpTransfer()</code>：帮助扩容机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;<br>    Node&lt;K,V&gt;[] nextTab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-comment">// 数组不为空，节点是转发节点，获取转发节点指向的新表开始协助主线程扩容</span><br>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span> &amp;&amp; (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;<br>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 扩容标识戳</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(tab.length);<br>        <span class="hljs-comment">// 判断数据迁移是否完成，迁移完成会把 新表赋值给 nextTable 属性</span><br>        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 设置扩容线程数量 + 1</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 协助扩容</span><br>                transfer(tab, nextTab);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nextTab;<br>    &#125;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>整个扩容操作分为<strong>两个部分</strong>：</p><p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p><p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置 i，然后利用tabAt方法获得 i 位置的元素再进行判断：</p><ol><li>如果这个位置为空，就在原table中的 i 位置放入forwardNode节点，这个也是触发并发扩容的关键点</li><li>如果这个位置是Node节点（fh&gt;&#x3D;0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</li></ol><img src="https://s2.loli.net/2024/01/31/cfRYP32w58kxKQH.png" alt="kr" style="zoom:80%;" /><hr><h4 id="size-相关方法"><a href="#size-相关方法" class="headerlink" title="size()相关方法"></a>size()相关方法</h4><p>对于ConcurrentHashMap来说，这个table里已存的数是不确定的，因为<strong>不可能在调用size()方法的时让其他线程都停下来统计，因此只能说这个数量是个估计值</strong></p><p>为了统计元素个数，其定义了一些变量和一个内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterCell</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>    CounterCell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新</span><br><span class="hljs-comment"> * 但它并不用返回当前hashmap的元素个数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> baseCount;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;<br></code></pre></td></tr></table></figure><p><strong>mappingCount与size方法</strong></p><p><strong>mappingCount</strong>与<strong>size</strong>方法的类似从给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-type">int</span>)n);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mappingCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : n; <span class="hljs-comment">// ignore transient negative values</span><br>&#125;<br><br> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<span class="hljs-comment">//所有counter的值求和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>addCount方法</strong></p><p>在put方法结尾处调用了addCount方法，把当前元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> check)</span> &#123;<br>    CounterCell[] as; <span class="hljs-type">long</span> b, s;<br>    <span class="hljs-comment">//利用CAS方法更新baseCount的值 </span><br>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> ||<br>        !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>        CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended =<br>              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>            <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                 <span class="hljs-comment">//如果已经有其他线程在执行扩容操作</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-literal">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud</title>
    <link href="/2023/12/11/SpringCloud/"/>
    <url>/2023/12/11/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="一、微服务介绍"><a href="#一、微服务介绍" class="headerlink" title="一、微服务介绍"></a>一、微服务介绍</h2><h3 id="1-什么是微服务"><a href="#1-什么是微服务" class="headerlink" title="1. 什么是微服务"></a>1. <strong>什么是微服务</strong></h3><ul><li>微服务是一种架构风格</li><li>一个应用拆分为一组小型服务</li><li>可独立部署和升级</li><li>服务之间使用轻量级HTTP交互</li><li>服务围绕业务功能拆分</li><li>可以由全自动部署机制独立部署</li><li>去中心化，服务自治</li></ul><h3 id="2-技术架构"><a href="#2-技术架构" class="headerlink" title="2. 技术架构"></a>2. <strong>技术架构</strong></h3><blockquote><p><strong>SpringCloud&#x3D;分布式微服务架构的站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶</strong></p></blockquote><p><img src="https://s2.loli.net/2023/12/11/dojxUBtal79WVAq.png" alt="sp"></p><ul><li><strong>服务调用 、服务降级、服务注册与发先、服务熔断、负载均衡、服务消息队列、服务网关</strong></li><li><strong>配置中心管理、自动化构建部署、服务监控、全链路追踪、服务定时任务、调度操作</strong></li></ul><h3 id="3-相关技术栈"><a href="#3-相关技术栈" class="headerlink" title="3. 相关技术栈"></a>3. <strong>相关技术栈</strong></h3><p><img src="https://s2.loli.net/2023/11/02/iTdp3XvHRWlGSgj.png" alt="jsz"></p><p><img src="https://s2.loli.net/2023/11/02/fMnNkGVXWCaxqcD.png" alt="jsz2"></p><h3 id="4-版本选择"><a href="#4-版本选择" class="headerlink" title="4. 版本选择"></a>4. <strong>版本选择</strong></h3><ul><li><strong><a href="https://start.spring.io/actuator/info">官方匹配查询</a></strong></li><li><strong><a href="https://spring.io/projects/spring-cloud">官网</a></strong></li></ul><h2 id="二、服务注册与发现"><a href="#二、服务注册与发现" class="headerlink" title="二、服务注册与发现"></a>二、服务注册与发现</h2><h3 id="1-CAP理论"><a href="#1-CAP理论" class="headerlink" title="1. CAP理论"></a>1. CAP理论</h3><h4 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1) CAP"></a>1) CAP</h4><p><img src="https://s2.loli.net/2023/11/02/hNo95wxpbCmUtrB.png" alt="cap"></p><p><strong>C：Consistency (强一致性)</strong></p><p><strong>A：Availability (可用性)</strong></p><p><strong>P：Partition tolerance （分区容错性)</strong></p><blockquote><p>最多只能同时较好的满足两个</p></blockquote><p><strong>CAP理论的核心</strong></p><blockquote><p>一个分布式系统不可能同时很好的满足<strong>一致性</strong>，<strong>可用性</strong>和<strong>分区容错性</strong>这三个需求。</p></blockquote><blockquote><p>因此，根据CAP原理将其分成了满足CA原则、满足CP原则和满足AP原则三大类</p></blockquote><ul><li><strong>CA</strong> - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。</li><li><strong>CP</strong> - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li><strong>AP</strong> - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><h4 id="2-AP架构"><a href="#2-AP架构" class="headerlink" title="2) AP架构"></a>2) AP架构</h4><p><strong>Eureka</strong></p><p><img src="https://s2.loli.net/2023/11/02/jnbge6NWMxSmG97.png" alt="ap"></p><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p><p><strong>结论：</strong>违背了一致性C的要求，只满足可用性和分区容错，即AP</p><h4 id="3-CP架构"><a href="#3-CP架构" class="headerlink" title="3) CP架构"></a>3) CP架构</h4><p><strong>ZooKeeper&#x2F;Consul</strong></p><p><img src="https://s2.loli.net/2023/11/02/TVDpvlzOIKXGZ93.png" alt="cp"></p><p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。</p><p><strong>结论：</strong>违背了可用性A的要求，只满足一致性和分区容错，即CP。</p><p><strong>CP 与 AP 对立的矛盾关系。</strong></p><h4 id="4-三个注册中心异同点"><a href="#4-三个注册中心异同点" class="headerlink" title="4) 三个注册中心异同点"></a>4) 三个注册中心异同点</h4><table><thead><tr><th>组件名</th><th>语言</th><th>CAP</th><th>服务健康检查</th><th>对外暴露接口 &#x2F; Spring Cloud集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>AP</td><td>可配支持</td><td>HTTP</td></tr><tr><td>Consul</td><td>Go</td><td>CP</td><td>支持</td><td>HTTP&#x2F;DNS</td></tr><tr><td>Zookeeper</td><td>Java</td><td>CP</td><td>支持客户端</td><td>已集成</td></tr></tbody></table><h3 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2. Eureka"></a>2. Eureka</h3><p><strong>Eureka</strong></p><p><img src="https://s2.loli.net/2023/11/02/mg6czilGsZ3BYtr.png" alt="erka"></p><h4 id="1-Eureka的两个组件"><a href="#1-Eureka的两个组件" class="headerlink" title="1) Eureka的两个组件"></a>1) <strong>Eureka的两个组件</strong></h4><p><strong>Eureka Server 和 Eureka Client</strong></p><ul><li><p><strong>Eureka Server</strong>提供服务注册服务</p><p>各个微服务节点通过配置启动后，会在Eureka Server中进行注册，</p><p>这样Eureka Server中的服务注册表中，将会存储所有可用服务节点的信息，</p><p>服务节点的信息可以在界面中直观看到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">server:</span><br><span class="hljs-comment">#    关闭自我保护机制</span><br><span class="hljs-comment">#    enable-self-preservation: false</span><br><span class="hljs-comment">#    设置定期清理过期服务的间隔时间</span><br><span class="hljs-comment">#    eviction-interval-timer-in-ms: 2000</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span><br>  <span class="hljs-attr">client:</span><br><span class="hljs-comment">#    表示不向注册中心注册自己</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment">#    表示自己就是注册中心，不需要检索自己的服务</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment">#    设置与eureka交互的地址</span><br>    <span class="hljs-attr">service-url:</span><br><span class="hljs-comment">#      集群</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span><br></code></pre></td></tr></table></figure><p><strong>主类添加注解激活</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaMain7001</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaMain7001.class , args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Eureka Client</strong>通过注册中心进行访问</p><p>它是一个Java客户端，用于简化Eureka Server的交互，</p><p>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。</p><p>如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，</p><p>Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span><br><span class="hljs-comment">#    访问路径显示ip</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#    向服务端发送心跳的时间间隔，单位为秒（默认是30秒）</span><br><span class="hljs-comment">#    lease-renewal-interval-in-seconds: 1</span><br><span class="hljs-comment">#    表示服务的存活时间，单位为秒（默认是90秒）超时未收到心跳则剔除服务</span><br><span class="hljs-comment">#    lease-expiration-duration-in-seconds: 2</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#    表示是否向注册中心查询自己的注册信息，默认为true，单点可以不配，集群必须配置为配合Ribbon实现负载均衡</span><br>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br><span class="hljs-comment">#      集群</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka,http://eureka7001.com:7001/eureka</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-集群与负载均衡"><a href="#2-集群与负载均衡" class="headerlink" title="2) 集群与负载均衡"></a>2) 集群与负载均衡</h4><p><strong>注：集群环境时修改主机ip映射便于区分</strong></p><ul><li>找到   <code>C:\Windows\System32\drivers\etc</code>   路径下的   <code>hosts</code>  文件，修改映射配置添加进hosts文件</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> eureka7001.com<br><span class="hljs-number">127.0.0.1</span> eureka7002.com<br></code></pre></td></tr></table></figure><p><strong>配置文件</strong></p><ul><li><p><strong>server</strong></p><blockquote><p>多台eureka相互注册</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br><span class="hljs-comment">#      集群</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p><strong>client</strong></p><blockquote><p>将服务注册到每一台eureka中</p><p>并且相同的服务，同一服务名不同id</p></blockquote><p><strong>cloud-payment-service</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span><br><span class="hljs-comment">#    访问路径显示ip</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#   表示是否向注册中心查询自己的注册信息，默认为true，单点可以不配，集群必须配置为配合Ribbon实现负载均衡</span><br>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br><span class="hljs-comment">#     集群</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka,http://eureka7001.com:7001/eureka</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8002</span><br><span class="hljs-comment">#    访问路径显示ip</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">service-url:</span><br><span class="hljs-comment">#      集群</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka,http://eureka7001.com:7001/eureka</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>开启负载均衡</strong></p><ul><li><p><strong>RestTemplate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><span class="hljs-comment">//    private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span><br><span class="hljs-comment">//    修改为服务名，开启集群访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PAYMENT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-自我保护"><a href="#3-自我保护" class="headerlink" title="3) 自我保护"></a>3) 自我保护</h4><blockquote><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。</p><p>一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，</p><p>不再删除服务注册表中的数据，也就是不会注销任何微服务。</p></blockquote><ol><li><p>某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。</p></li><li><p>属于CAP里面的AP分支。</p></li><li><p>自我保护机制∶默认情况下Eureka Client定时向Eureka Server端发送心跳包</p></li></ol><p><strong>关闭自我保护</strong></p><ul><li><p><strong>server</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">server:</span><br><span class="hljs-comment">#    关闭自我保护机制</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment">#    设置定期清理过期服务的间隔时间</span><br>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure></li><li><p><strong>client</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br><span class="hljs-comment">#    向服务端发送心跳的时间间隔，单位为秒（默认是30秒）</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">1</span><br><span class="hljs-comment">#    表示服务的存活时间，单位为秒（默认是90秒）超时未收到心跳则剔除服务</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-服务发现"><a href="#4-服务发现" class="headerlink" title="4) 服务发现"></a>4) 服务发现</h4><p><strong>DiscoveryClient</strong></p><blockquote><p>开启服务发现，可获取eureka服务器上的所有的已注册服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引入spring的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><br><br>    <span class="hljs-meta">@GetMapping(&quot;/discovery&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">aboutMe</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//        获取注册中心已注册的服务</span><br>        List&lt;String&gt; list = discoveryClient.getServices();<br>        List&lt;List&lt;ServiceInstance&gt;&gt; res =<br>                list.stream().map(serverName -&gt; discoveryClient.getInstances(serverName))<br>                        .collect(Collectors.toList());<br><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;成功&quot;</span>,res);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-Zookeeper"><a href="#3-Zookeeper" class="headerlink" title="3. Zookeeper"></a>3. Zookeeper</h3><blockquote><p>zookeeper是临时节点，属于CAP中的CP分支</p></blockquote><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1) 配置"></a>1) 配置</h4><p><strong>pom</strong></p><blockquote><p>注意版本问题</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#8004表示注册到zookeeper服务器的支付服务提供者端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><br><br><span class="hljs-comment">#服务别名----注册zookeeper到注册中心名称</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-provider-payment</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">zookeeper:</span><br>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:2181</span><br><br></code></pre></td></tr></table></figure><p><strong>zookeeper客户端</strong></p><blockquote><p>注册成功则在services中出现服务名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: localhost:2181(CONNECTED) 0] <span class="hljs-built_in">ls</span> /<br>[services, zookeeper]<br>[zk: localhost:2181(CONNECTED) 1] <span class="hljs-built_in">ls</span> /services/cloud-provider-payment<br>[a4567f50-6ad9-47a3-9fbb-7391f41a9f3d]<br>[zk: localhost:2181(CONNECTED) 2] get /services/cloud-provider-payment/a4567f50-6ad9-47a3-9fbb-7391f41a9f3d<br>&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;cloud-provider-payment&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:<span class="hljs-string">&quot;192.168.199.218&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>:8004,<span class="hljs-string">&quot;ss</span><br><span class="hljs-string">lPort&quot;</span>:null,<span class="hljs-string">&quot;payload&quot;</span>:&#123;<span class="hljs-string">&quot;@class&quot;</span>:<span class="hljs-string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;application-1&quot;</span>,<span class="hljs-string">&quot;</span><br><span class="hljs-string">name&quot;</span>:<span class="hljs-string">&quot;cloud-provider-payment&quot;</span>,<span class="hljs-string">&quot;metadata&quot;</span>:&#123;&#125;&#125;,<span class="hljs-string">&quot;registrationTimeUTC&quot;</span>:1612811116918,<span class="hljs-string">&quot;serviceType&quot;</span>:<span class="hljs-string">&quot;DYNAMIC&quot;</span>,<span class="hljs-string">&quot;uriSpec&quot;</span>:&#123;<span class="hljs-string">&quot;pa</span><br><span class="hljs-string">rts&quot;</span>:[&#123;<span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;scheme&quot;</span>,<span class="hljs-string">&quot;variable&quot;</span>:<span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;://&quot;</span>,<span class="hljs-string">&quot;variable&quot;</span>:<span class="hljs-literal">false</span>&#125;,&#123;<span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;variable&quot;</span>:<span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;</span><br><span class="hljs-string">:&quot;</span>,<span class="hljs-string">&quot;variable&quot;</span>:<span class="hljs-literal">false</span>&#125;,&#123;<span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;port&quot;</span>,<span class="hljs-string">&quot;variable&quot;</span>:<span class="hljs-literal">true</span>&#125;]&#125;&#125;<br>[zk: localhost:2181(CONNECTED) 3]<br><br></code></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/consumer&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderZkController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">INVOKE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://cloud-provider-payment&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="4-Consul"><a href="#4-Consul" class="headerlink" title="4. Consul"></a>4. Consul</h3><blockquote><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。</p></blockquote><h4 id="1-启动"><a href="#1-启动" class="headerlink" title="1) 启动"></a>1) 启动</h4><p><strong>官网下载后启动exe文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 开发者模式启动<br>consul agent -dev<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/xX185E3wjOrQpql.png" alt="consul"></p><p><strong>访问8500端口进入可视化界面</strong></p><p><img src="https://s2.loli.net/2023/11/02/NjVenXyGA1JkzwQ.png" alt="consul2"></p><h4 id="1-配置-1"><a href="#1-配置-1" class="headerlink" title="1) 配置"></a>1) 配置</h4><p><strong>pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">###consul服务端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8006</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">consul-provider-payment</span><br><span class="hljs-comment">####consul注册中心地址</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">consul:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">service-name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/consumer&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderConsulController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">INVOKE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://consul-provider-payment&quot;</span>;<br><br></code></pre></td></tr></table></figure><p><strong>配置成功则可在可视化面板看到服务信息</strong></p><p><img src="https://s2.loli.net/2023/11/02/kDIzsBbpEldQ157.png" alt="consul3"></p><h2 id="三、服务调用"><a href="#三、服务调用" class="headerlink" title="三、服务调用"></a>三、服务调用</h2><h3 id="1-Ribbon"><a href="#1-Ribbon" class="headerlink" title="1. Ribbon"></a>1. <del>Ribbon</del></h3><blockquote><p>已淘汰</p></blockquote><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡的工具</strong>。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p><strong>Load Balance</strong></p><blockquote><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。</p><p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p></blockquote><p><strong>集中式LB</strong></p><p>即在服务的消费方和提供方之间<strong>使用独立的LB设施</strong>(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;</p><p><strong>进程内LB</strong></p><p>将LB逻辑<strong>集成到消费方</strong>，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p><p><strong>Ribbon就属于进程内LB</strong></p><h4 id="Ribbon默认自带的负载规则"><a href="#Ribbon默认自带的负载规则" class="headerlink" title="Ribbon默认自带的负载规则"></a>Ribbon默认自带的负载规则</h4><p><img src="https://s2.loli.net/2023/11/02/TvzRFHcI9KDjg3t.png" alt="ribbon"></p><h3 id="2-Open-Feign"><a href="#2-Open-Feign" class="headerlink" title="2. Open Feign"></a>2. Open Feign</h3><blockquote><p><strong>Feign</strong>是一个<strong>声明式WebService客户端</strong></p><p><strong>Feign</strong>集成了<strong>Ribbon</strong></p><p><strong>OpenFeign</strong>是Spring Cloud在Feign的基础上<strong>支持了SpringMVC的注解</strong></p></blockquote><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>启动类上激活</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignMain80</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderFeignMain80.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@FeignClient(&quot;CLOUD-PAYMENT-SERVICE&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentFeignService</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span><br>    Result&lt;Payment&gt; <span class="hljs-title function_">getPayment</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span><br>    String <span class="hljs-title function_">paymentFeignTimeout</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日志增强"><a href="#日志增强" class="headerlink" title="日志增强"></a>日志增强</h4><p><strong>日志级别</strong></p><ul><li><strong>NONE</strong>：默认的，不显示任何日志;</li><li><strong>BASIC</strong>：仅记录请求方法、URL、响应状态码及执行时间;</li><li><strong>HEADERS</strong>：包含BASIC，还有请求和响应的头信息;</li><li><strong>FULL</strong>：包含HEADERS，还有请求和响应的正文及元数据。</li></ul><p><strong>配置日志Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br><span class="hljs-comment">#    配置feign日志的级别以及监控的接口</span><br>    <span class="hljs-attr">com.kongke.springcloud.service.PaymentFeignService:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h2 id="四、服务控制"><a href="#四、服务控制" class="headerlink" title="四、服务控制"></a>四、服务控制</h2><h3 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1. Hystrix"></a>1. <del>Hystrix</del></h3><blockquote><p>已淘汰</p></blockquote><p>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，</p><p>在分布式系统里，许多依赖不可避免的会调用失败，</p><p>比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，</p><p><strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p><strong>哪些情况会出发降级</strong></p><ul><li>程序运行导常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池&#x2F;信号量打满也会导致服务降级</li></ul><h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><blockquote><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p></blockquote><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><blockquote><p><strong>类比保险丝</strong>达到最大服务访问后，直接拒绝访问，然后调用服务降级的方法</p></blockquote><p><strong>熔断机制</strong></p><p>是应对雪崩效应的一种微服务<strong>链路保护机制</strong>。</p><p>当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，</p><p>进而熔断该节点微服务的调用，快速返回错误的响应信息。</p><p><strong>当检测到该节点微服务调用响应正常后，恢复调用链路</strong>。</p><p><img src="https://s2.loli.net/2023/11/02/itsTqpYybPM4Fxv.png" alt="rd"></p><p><strong>熔断类型</strong></p><ul><li><p><strong>熔断打开</strong>：</p><blockquote><p> 请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，</p><p> 当打开时长达到所设时钟则进入半熔断状态。</p></blockquote></li><li><p><strong>熔断关闭</strong>：</p><blockquote><p> 熔断关闭不会对服务进行熔断。</p></blockquote></li><li><p><strong>熔断半开</strong>：</p><blockquote><p> 部分请求根据规则调用当前服务，</p><p> 如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</p></blockquote></li></ul><p><strong>涉及到断路器的三个重要参数</strong>：</p><ul><li><p><strong>快照时间窗</strong>：<code>circuitBreaker.sleepWindowInMilliseconds</code></p><p>断路器确定是否打开需要统计一些请求和错误数据，</p><p>而统计的时间范围就是快照时间窗，默认为最近的10秒。</p></li><li><p><strong>请求总数阀值</strong>：<code>circuitBreaker.requestVolumeThreshold</code></p><p>在快照时间窗内，必须满足请求总数阀值才有资格熔断。</p><p>默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次7,</p><p>即使所有的请求都超时或其他原因失败，断路器都不会打开。</p></li><li><p><strong>错误百分比阀值</strong>：<code>circuitBreaker.errorThresholdPercentage</code></p><p>当请求总数在快照时间窗内超过了阀值，</p><p>比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，</p><p>也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p></li></ul><p><strong>流程</strong></p><ul><li><strong>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</strong></li></ul><h2 id="五、服务网关"><a href="#五、服务网关" class="headerlink" title="五、服务网关"></a>五、服务网关</h2><p><img src="https://s2.loli.net/2023/11/02/vcdVyn71JpTi6f4.png" alt="wg"></p><p><img src="https://s2.loli.net/2023/11/02/plM4WnkfLw5qzF8.png" alt="wg2"></p><h3 id="1-Gateway"><a href="#1-Gateway" class="headerlink" title="1. Gateway"></a>1. Gateway</h3><blockquote><p>SpringCloud Gateway是基于<strong>WebFlux</strong>框架实现的，</p><p>WebFlux是一个典型<strong>非阻塞异步</strong>的框架</p><p>WebFlux框架底层则使用了高性能的<strong>Reactor模式通信框架Netty</strong>。</p></blockquote><p><strong>Spring Cloud Gateway的目标</strong></p><p>提供统一的路由方式且基于 <strong>Filter 链</strong>的方式提供了网关基本的功能，</p><p>例如:安全，监控&#x2F;指标，和限流。</p><h4 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a><strong>三大核心概念</strong></h4><ul><li><p><strong>Route(路由)</strong></p><p>路由是构建网关的基本模块</p><p><strong>它由ID,目标URI,一系列的断言和过滤器组成</strong>,如断言为true则匹配该路由</p></li><li><p><strong>Predicate(断言)</strong></p><p>参考的是Java8的java.util.function.Predicate，</p><p>开发人员可以<strong>匹配HTTP请求中的所有内容</strong>(例如请求头或请求参数),</p><p>如果请求与断言相匹配则进行路由</p></li><li><p><strong>Filter(过滤)</strong> </p><p>指的是Spring框架中GatewayFilter的实例,使用过滤器,</p><p><strong>可以在请求被路由前或者之后对请求进行修改</strong></p></li></ul><p><strong>工作流程</strong></p><p><img src="https://s2.loli.net/2023/11/02/fIlB6A8pGYObL3e.png" alt="gzlc"></p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><strong>pom</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--gateway--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- gateway 包与一下包冲突 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>yml</strong></p><blockquote><p>其中包含Gateway的路由配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-gateway</span><br>  <span class="hljs-comment">#############################新增网关配置###########################</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启从注册中心动态注册路由</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    </span><br><span class="hljs-comment">#          uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#匹配后提供服务的路由地址</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/get/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh2</span> <br><span class="hljs-comment">#          uri: http://localhost:8001         </span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/lb/**</span>         <br><span class="hljs-comment">#            - After=2023-10-30T20:23:58.940+08:00[Asia/Shanghai]</span><br><span class="hljs-comment">#            - Cookie=username,aabb</span><br><span class="hljs-comment">####################################################################</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cloud-gateway-service</span><br>  <span class="hljs-attr">client:</span> <span class="hljs-comment">#服务提供者provider注册进eureka服务列表内</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span><br><br></code></pre></td></tr></table></figure><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p><strong>Bean方式配置路由</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title function_">CustomRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> &#123;<br><br>        RouteLocatorBuilder.<span class="hljs-type">Builder</span> <span class="hljs-variable">routes</span> <span class="hljs-operator">=</span> builder.routes();<br>        routes.route(<span class="hljs-string">&quot;path_route_runoob&quot;</span>,<br>                <span class="hljs-comment">// 当访问网关的改路径时     </span><br>                r -&gt; r.path(<span class="hljs-string">&quot;/runoob&quot;</span>)<br>                         <span class="hljs-comment">// Gateway会将其转发到已下路径 </span><br>                        .uri(<span class="hljs-string">&quot;https://www.runoob.com&quot;</span>)).build();<br><br>        <span class="hljs-keyword">return</span> routes.build();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置动态路由</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    </span><br>         <span class="hljs-comment">#uri: http://localhost:8001          </span><br>         <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#以服务名作为路由地址</span><br></code></pre></td></tr></table></figure><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p><strong>示例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>          <span class="hljs-comment"># 这个时间后才能起效</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span><br>          <span class="hljs-comment"># 需带有以下的值</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=username,aabb</span><br></code></pre></td></tr></table></figure><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p><strong>自定义过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLogGatewayFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br><br>    <span class="hljs-comment">// 自定义条件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br><br>        log.info(<span class="hljs-string">&quot;=========come to MLGF &quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uname</span> <span class="hljs-operator">=</span> exchange.getRequest()<br>            .getQueryParams().getFirst(<span class="hljs-string">&quot;uname&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (uname == <span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;=========非法用户&quot;</span>);<br>            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);<br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">// 优先级</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、配置中心"><a href="#六、配置中心" class="headerlink" title="六、配置中心"></a>六、配置中心</h2><p><strong>分布式系统面临的配置问题</strong></p><blockquote><p>微服务意味着要将单体应用中的业务拆分成一子服务，每个服务的粒度相对较小，</p><p>系统中会出现大量的服务,由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p></blockquote><ul><li>SpringCloud提供了ConfigServer来解决这个问题</li></ul><h3 id="1-SpringCloud-Config"><a href="#1-SpringCloud-Config" class="headerlink" title="1. SpringCloud Config"></a>1. SpringCloud Config</h3><blockquote><p>SpringCloud Config为微服务架构中的微服务提供<strong>集中化</strong>的外部配置支持，</p><p>配置服务器为各个不同微服务应用的所有环境提供了一个中心化的<strong>外部配置</strong>。</p></blockquote><p><img src="https://s2.loli.net/2023/11/03/uxAc4VyNi1wIkQP.png" alt="config"></p><p><strong>分为服务端和客户端</strong></p><ul><li><p>服务端</p><p>也称为分布式配置中心，是一个独立的微服务应用，用来连接配置服务器</p><p>并为客户端<strong>提供获取</strong>配置信息，加密&#x2F;解密信息等访问接口。</p></li><li><p>客户端</p><p>是通过指定的配置中心来<strong>管理</strong>应用资源，以及与业务相关的配置内容，并在启动时从配置中心获取配置信息,</p><p>配置服务器默认采用git来存储配置信息，这样有助于对环境配置进行版本管理，且可以通过git客户端工具来管理和访问配置内容。</p></li></ul><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注&#x3D;&#x3D;：客户端还需要引入以下包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--     2020以上版本，需引入该包，才能正确引导bootstrap配置加载   --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong>  （总中心）application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">git@gitee.com:kongke7/springcloud-config.git</span> <span class="hljs-comment"># Gitee上面的git仓库名字</span><br>          <span class="hljs-comment"># 搜索目录</span><br>          <span class="hljs-attr">search-paths:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">springcloud-config</span><br>          <span class="hljs-comment"># 读取分支</span><br>          <span class="hljs-attr">default-label:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注&#x3D;&#x3D;：</p><ul><li><p>applicaiton.yml是用户级的资源配置项</p></li><li><p>bootstrap.yml是系统级的，<strong>优先级更高</strong></p></li></ul><blockquote><p>Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。</p><p>初始化的时候，BootstrapContext从<strong>外部源</strong>加载配置属性并解析配置。这两个上下文共享一个从<strong>外部获取</strong>的Environment。</p><p>Bootstrap属性有高优先级，默认情况下，<strong>它们不会被本地配置覆盖。</strong></p><p>Bootstrap context和Application Context有着不同的约定，</p><p>所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。</p></blockquote><p>要将Client模块下的application.yml文件改为bootstrap.yml, 这是很关键的，</p><p>因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。</p><p><strong>YML</strong>（客户端）bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-comment">#Config客户端配置</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#分支名称</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#读取后缀名称 -&gt; http://config3344.com:3344/master/config-dev.yml</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344</span> <span class="hljs-comment">#配置中心地址</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">cloud-config-center</span><br></code></pre></td></tr></table></figure><p><strong>激活</strong>（总中心）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplicationCenter3344</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MainApplicationCenter3344.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">// 动态刷新</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String configInfo;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/configInfo&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfigInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> configInfo;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读取规则</strong></p><ul><li><p>&#x2F;{label}&#x2F;{application}-{profile}.yml（推荐）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">localhost:</span><span class="hljs-number">3344</span><span class="hljs-keyword">/master/</span>config-dev.yml<br></code></pre></td></tr></table></figure></li></ul><h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><blockquote><p>避免每次更新配置都要重启客户端</p></blockquote><p><strong>手动</strong></p><hr><p><strong>POM</strong></p><blockquote><p>引入actuator监控</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong></p><blockquote><p>添加暴露监控端口配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 暴露监控端点</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p><strong>业务类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RefreshScope</span><span class="hljs-comment">//&lt;----- </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>刷新</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST <span class="hljs-string">&quot;http://localhost:3355/actuator/refresh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>自动</strong></p><blockquote><p>SpringCloud Bus配合SpringCloud Config使用可以实现配置的动态刷新。</p></blockquote><h2 id="七、消息控制"><a href="#七、消息控制" class="headerlink" title="七、消息控制"></a>七、消息控制</h2><p><strong>消息总线</strong></p><blockquote><p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个<strong>共用的</strong>消息主题,</p><p>由于该主题中产生的消息会被所有实例监听和消费，所以称它为<strong>消息总线</strong>。</p><p>在总线上的各个实例，都可以<strong>广播</strong>一些需要让其在该主题上的实例都知道的消息。</p></blockquote><p><strong>基本原理</strong></p><p>ConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。</p><p>当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听<strong>同一Topic</strong>的服务就能得到通知，然后去更新自身的配置。</p><h3 id="1-SpringCloud-Bus"><a href="#1-SpringCloud-Bus" class="headerlink" title="1. SpringCloud Bus"></a>1. SpringCloud Bus</h3><blockquote><p>Spring Cloud Bus是用来将分布式系统的<strong>节点</strong>与<strong>轻量级消息系统</strong>链接起来的框架</p><p>它整合了Java的事件处理机制和消息中间件的功能。</p><p>Spring Clud Bus目前支持RabbitMQ和Kafka。</p></blockquote><p><strong>作用</strong></p><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，</p><p>可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p><ol><li>通知节点更新全局</li></ol><p><img src="https://s2.loli.net/2023/11/03/nTA3ogz57ivBKjs.png" alt="bus1"></p><ol start="2"><li>通知总中心更新全局</li></ol><p><img src="https://s2.loli.net/2023/11/03/bXx3KC6d1yFmUZR.png" alt="bus"></p><h4 id="Bus配合RabbitMQ"><a href="#Bus配合RabbitMQ" class="headerlink" title="Bus配合RabbitMQ"></a>Bus配合RabbitMQ</h4><p><strong>POM</strong>（客户端 + 总中心）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong>（客户端 + 总中心）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><p><strong>动态全局广播</strong></p><blockquote><p>更新总中心,使全局更新</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST <span class="hljs-string">&quot;http://localhost:3344/actuator/busrefresh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>定点通知</strong></p><blockquote><p>指定具体某一个实例生效</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost:3344/actuator/busrefresh/&#123;destination&#125;<br><br>curl -X POST <span class="hljs-string">&quot;http://localhost:3344/actuator/busrefresh/config-client:3355</span><br></code></pre></td></tr></table></figure><h3 id="2-SpringCloud-Stream"><a href="#2-SpringCloud-Stream" class="headerlink" title="2. SpringCloud Stream"></a>2. SpringCloud Stream</h3><blockquote><p>Spring Cloud Stream是一个构建消息驱动微服务的框架。</p><p>应用程序通过 inputs 或者 outputs 来与Spring Cloud Stream中binder对象交互。</p><p>通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。</p><p>通过使用Spring Integration来<strong>连接消息代理中间件</strong>以实现消息事件驱动。</p></blockquote><p>Spring Cloud Stream为一些消息中间件提供了个性化的自动化配置实现</p><ul><li><p>引用发布-订阅、消费组、分区的三个核心概念。</p></li><li><p>目前仅支持RabbitMQ、 Kafka。</p></li></ul><p><strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</strong>。</p><p><strong>Binder</strong>：</p><ul><li>INPUT对应于消费者</li><li>OUTPUT对应于生产者</li></ul><p><img src="https://s2.loli.net/2023/11/03/RNZiYe7K8Wqj9ha.png" alt="stream"></p><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p><strong>YML</strong>（生产者）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-comment"># 配置要绑定的rabbitmq的服务信息</span><br>      <span class="hljs-attr">binders:</span><br>        <span class="hljs-comment"># 表示定义的名称，用于于binding整合</span><br>        <span class="hljs-attr">defaultRabbit:</span><br>          <span class="hljs-comment"># 消息组件类型</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span><br>          <span class="hljs-comment"># 设置rabbitmq的相关的环境配置</span><br>          <span class="hljs-attr">environment:</span><br>            <span class="hljs-attr">spring:</span><br>              <span class="hljs-attr">rabbitmq:</span><br>                <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>                <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>                <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>                <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>      <span class="hljs-comment"># 服务的整合处理</span><br>      <span class="hljs-attr">bindings:</span><br>        <span class="hljs-comment"># 新版本固定格式  channel名字-&#123;out/in&#125;-&#123;index&#125;</span><br>        <span class="hljs-attr">studyExchange-out-0:</span><br>          <span class="hljs-comment"># 表示要使用的Exchange名称定义</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">studyExchange</span><br>          <span class="hljs-comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span><br>          <span class="hljs-attr">content-type:</span> <span class="hljs-string">application/json</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong>（消费者）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 服务的整合处理</span><br><span class="hljs-attr">bindings:</span><br>  <span class="hljs-comment"># 新版本固定格式  channel名字-&#123;out/in&#125;-&#123;index&#125;</span><br>  <span class="hljs-attr">studyExchange-in-0:</span><br>    <span class="hljs-comment"># 表示要使用的Exchange名称定义</span><br>    <span class="hljs-attr">destination:</span> <span class="hljs-string">studyExchange</span><br>    <span class="hljs-comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span><br>    <span class="hljs-attr">content-type:</span> <span class="hljs-string">application/json</span><br>    <span class="hljs-comment"># 消息组</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">AAA</span><br></code></pre></td></tr></table></figure><p><strong>业务类</strong>（生产者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageProviderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IMessageProvider</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StreamBridge streamBridge;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">UUID</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID();<br>        streamBridge.send(<span class="hljs-string">&quot;studyExchange-out-0&quot;</span>, MessageBuilder.withPayload(uuid).build());<br>        <span class="hljs-keyword">return</span> uuid.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务类</strong>（消费者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageListener</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String serPort;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Consumer&lt;String&gt; <span class="hljs-title function_">studyExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> msg -&gt; System.out.println(msg + <span class="hljs-string">&quot; | &quot;</span> + serPort );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重复消费和持久化"><a href="#重复消费和持久化" class="headerlink" title="重复消费和持久化"></a>重复消费和持久化</h4><blockquote><p>保证消息只会被消费一次</p><p>保证当客户端挂机重启后，仍能接收到挂机时生产者发送的消息</p></blockquote><p><strong>使用Stream中的消息分组(group)来解决</strong></p><p>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。</p><p><strong>不同的组</strong>是可以重复消费的，<strong>同一个组</strong>内会发生竞争关系，只有其中一个可以消费。</p><p>有分组属性配置的客户端可以实现持久化</p><p><strong>YML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">bindings:</span><br>   <span class="hljs-comment"># 消息组</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">AAA</span><br></code></pre></td></tr></table></figure><h2 id="八、链路跟踪"><a href="#八、链路跟踪" class="headerlink" title="八、链路跟踪"></a>八、链路跟踪</h2><blockquote><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过<strong>多个不同的的服务节点</strong>调用来协同产生最后的请求结果，每一个请求都会形成一条复杂的分布式服务<strong>调用链路</strong>，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p></blockquote><h3 id="1-SpringCloud-Sleuth"><a href="#1-SpringCloud-Sleuth" class="headerlink" title="1.SpringCloud Sleuth"></a>1.SpringCloud Sleuth</h3><p><img src="https://s2.loli.net/2023/11/03/SkzvxjOTNP6b3nQ.png" alt="sleuth"></p><ul><li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li><li>span：表示调用链路来源，通俗的理解span就是一次请求信息</li></ul><p><strong>Zipkin</strong></p><blockquote><p>SpringCloud已不需要自己构建Zipkin Server，只需调用jar包即可</p></blockquote><p><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">官网下载</a></p><p><strong>运行jar</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar zipkin-server-2.12.9-exec.jar<br></code></pre></td></tr></table></figure><p><strong>运行控制台</strong></p><p>运行控制台</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:9411</span><br></code></pre></td></tr></table></figure><h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><blockquote><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>Sentine</strong>l：流量控制、熔断降级、系统负载保护等，保护服务的稳定性。</p></li><li><p><strong>Nacos</strong>：动态服务发现、<strong>配置管理</strong>和<strong>服务管理</strong>平台。</p></li><li><p><strong>RocketMQ</strong>：分布式<strong>消息系统</strong>，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p></li><li><p><strong>Dubbo</strong>：一款高性能 Java <strong>RPC 框架</strong>。</p></li><li><p><strong>Seata</strong>：微服务分布式<strong>事务解决方案</strong>。</p></li><li><p><strong>Alibaba Cloud OSS</strong>: <strong>对象存储</strong>服务（简称 OSS），云存储服务。</p></li><li><p><strong>Alibaba Cloud SchedulerX</strong>: 分布式<strong>任务调度</strong>，提供任务调度服务。</p></li><li><p><strong>Alibaba Cloud SMS</strong>: <strong>短信服务</strong></p></li></ul><h2 id="一、Nacos"><a href="#一、Nacos" class="headerlink" title="一、Nacos"></a>一、Nacos</h2><blockquote><p>Nacos就是注册中心＋配置中心的组合 -&gt; <strong>Nacos &#x3D; Eureka+Config+Bus</strong></p></blockquote><p><strong>[官网下载](<a href="https://nacos.io/zh-cn/index.html">home (nacos.io)</a>)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 访问</span><br>localhost:8848/nacos<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--负载均衡--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1. 注册中心"></a>1. 注册中心</h3><p><strong>YML</strong>（生产者）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-payment-provider</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#配置Nacos地址</span><br><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong>（消费者）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">83</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-order-consumer</span><br>  <span class="hljs-attr">cloud:</span><br>  <span class="hljs-comment"># 开启负载均衡</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p><strong>启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMain9001</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            SpringApplication.run(PaymentMain9001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者Rest</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContextConfig</span> &#123;<br><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">getRestTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-配置中心"><a href="#2-配置中心" class="headerlink" title="2. 配置中心"></a>2. 配置中心</h3><p><img src="https://s2.loli.net/2023/11/05/CsmeJUZ7VY5gNfi.png" alt="nacos"></p><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--     2020以上版本，需引入改包，才能正确引导bootstrap配置加载   --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong></p><ul><li><p>bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nacos配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-config-client</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span><br><span class="hljs-comment">#        group: DEV_GROUP #分组</span><br><span class="hljs-comment">#        namespace: a56da4e5-dd4c-4e92-92d3-d050386a0d2d #命名空间</span><br></code></pre></td></tr></table></figure></li><li><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br> <span class="hljs-attr">profiles:</span><br>  <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 表示开发环境</span><br><span class="hljs-comment">#  active: test # 表示测试环境</span><br><span class="hljs-comment">#  active: info</span><br></code></pre></td></tr></table></figure></li><li><p>在nacos上的配置文件命名规则为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$&#123;spring<span class="hljs-selector-class">.application</span>.name&#125;-$&#123;spring<span class="hljs-selector-class">.profile</span>.active&#125;.$&#123;spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.nacos</span><span class="hljs-selector-class">.config</span>.file-extension&#125;<br></code></pre></td></tr></table></figure><p>例如上述配置，在注册中心读取的，配置文件命名为</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nacos-config-client-dev.yaml<br></code></pre></td></tr></table></figure></li></ul><p><strong>业务类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">// nacos 动态刷新</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String configInfo;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/config/info&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfigInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> configInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-集群部署"><a href="#3-集群部署" class="headerlink" title="3. 集群部署"></a>3. 集群部署</h3><blockquote><p>Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。</p></blockquote><p><img src="https://s2.loli.net/2023/11/05/5gsHoZLdTNDXPv4.png" alt="nacosJq"></p><p><strong>数据库持久化</strong></p><ol><li>安装数据库，版本要求:5.6.5+</li><li>初始化mysq数据库，数据库初始化文件: nacos-mysql.sql</li><li>修改conf&#x2F;application.properties文件，增加支持mysql数据源配置（目前只支持mysql)，添加mysql数据源的url、用户名和密码。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://IP:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">db.user</span>=<span class="hljs-string">nacos_devtest</span><br><span class="hljs-attr">db.password</span>=<span class="hljs-string">youdontknow</span><br></code></pre></td></tr></table></figure><p><strong>Linux集群</strong></p><p><strong>配置Nacos</strong></p><ul><li><p>下载安装</p></li><li><p>配置数据库</p><p><img src="https://s2.loli.net/2023/11/05/UTCY1q8PMVWrZzx.png" alt="NacosLinux"></p></li><li><p>配置端口</p><p><img src="https://s2.loli.net/2023/11/05/GDliIX7UdwBptvT.png" alt="JqPz"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.111.144:3333</span><br><span class="hljs-number">192.168.111.144:4444</span><br><span class="hljs-number">192.168.111.144:5555</span><br></code></pre></td></tr></table></figure></li><li><p>配置启动文件</p><p><img src="https://s2.loli.net/2023/11/05/kb85gUBRqDr4jIx.png" alt="QdPz"></p></li></ul><p>​<img src="https://s2.loli.net/2023/11/05/iORBoVQZnDqtJYm.png" alt="QdPz2"></p><ul><li><code>startup.sh - p 端口号</code>：带端口启动</li></ul><p><strong>配置Nginx</strong></p><ul><li><p>修改配置文件</p><p><img src="https://s2.loli.net/2023/11/05/69sm8Vd4zraJohe.png" alt="nginx"></p></li></ul><p>​<img src="https://s2.loli.net/2023/11/05/1g4XCJfEkj9sdFR.png" alt="nginx2"></p><ul><li><p>启动nginx</p><p><img src="https://s2.loli.net/2023/11/05/MagsTSGRtrWIV7D.png" alt="nginx3"></p></li></ul><h2 id="二、Sentinel"><a href="#二、Sentinel" class="headerlink" title="二、Sentinel"></a>二、Sentinel</h2><blockquote><p>以流量为切入点，流量控制、熔断降级、系统负载保护等</p></blockquote><p><strong>主要特征</strong></p><p><img src="https://s2.loli.net/2023/11/08/5vlmSJxHwPuoed3.png" alt="sentinel"></p><p><strong>下载安装</strong></p><ul><li><p><strong><a href="https://github.com/alibaba/Sentinel/releases">GitHub下载</a></strong><br>下载到本地的jar包</p></li><li><p>运行命令</p><p>8080端口不能被占用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar sentinel-dashboard-1.7.0.jar<br></code></pre></td></tr></table></figure></li><li><p>访问Sentinel管理界面</p><ul><li>localhost:8080</li><li>登录账号密码均为sentinel</li></ul></li></ul><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud Alibaba nacos --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--SpringCloud Alibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!--SpringCloud Alibaba sentinel --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--openfeign--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cloudalibaba-sentinel-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment">#配置Sentinel dashboard地址</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span><br><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 激活Sentinel对Feign的支持</span><br></code></pre></td></tr></table></figure><h3 id="1-流量控制"><a href="#1-流量控制" class="headerlink" title="1. 流量控制"></a>1. 流量控制</h3><p><strong>界面</strong></p><p><img src="https://s2.loli.net/2023/11/08/46FhmTwe5NAzLrI.png" alt="senLk"></p><ul><li><p>资源名：唯一名称，默认请求路径。</p></li><li><p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。</p></li><li><p>阈值类型&#x2F;单机阈值：</p><ul><li>QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。</li><li>线程数：当调用该API的线程数达到阈值的时候，进行限流。</li></ul></li><li><p>是否集群：不需要集群。</p></li><li><p>流控模式：</p><ul><li>直接：API达到限流条件时，直接限流。</li><li>关联：当关联的资源达到阈值时，就限流自己。</li><li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。</li></ul></li><li><p>流控效果：</p><ul><li>快速失败：直接失败，抛异常。</li><li>Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设置的QPS阈值。</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。</li></ul></li></ul><p><strong>预热</strong></p><blockquote><p>即预热&#x2F;冷启动方式。当系统长期处于低访问量的情况下，当流量突然增加时，可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p></blockquote><p><img src="https://s2.loli.net/2023/11/08/BSGjdD7zMlLYAX1.png" alt="warmUp"></p><p><strong>排队等待</strong></p><blockquote><p>会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p></blockquote><p>注：阀值类型必须设成QPS，否则无效。</p><p><img src="https://s2.loli.net/2023/11/08/LoHJF4KP2xCO5eQ.png" alt="pd"></p><h3 id="2-服务降级"><a href="#2-服务降级" class="headerlink" title="2. 服务降级"></a>2. 服务降级</h3><blockquote><p>对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p></blockquote><p><strong>慢调用比例 (SLOW_REQUEST_RATIO)</strong></p><ul><li>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。</li><li>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断</li></ul><p><strong>异常比例 (ERROR_RATIO)</strong></p><ul><li>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。</li><li>经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</li></ul><p><strong>热点Key</strong></p><p><img src="https://s2.loli.net/2023/11/08/9Fhdc3UevnVDNWP.png" alt="rdKey"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowLimitController</span><br>&#123;<br><br>    ...<br><br>    <span class="hljs-meta">@GetMapping(&quot;/testHotKey&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler/*兜底方法*/ = &quot;deal_testHotKey&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testHotKey</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span><br><span class="hljs-params">                             <span class="hljs-meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testHotKey&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*兜底方法*/</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deal_testHotKey</span> <span class="hljs-params">(String p1, String p2, BlockException exception)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="hljs-comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>@SentinelResource(value = &quot;testHotKey&quot;)</code>：前台报出异常界面</p></li><li><p><code>@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;dealHandler_testHotKey&quot;)</code><br>方法testHotKey里面第一个参数只要超过限流规则，马上降级处理<br>异常用了我们自己定义的兜底方法</p></li></ul><p><strong>参数例外项</strong></p><ul><li>普通 - 超过1秒钟一个后，达到阈值1后马上被限流</li><li><strong>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样</strong></li><li>特例 - 假如当p1的值等于5时，它的阈值可以达到200</li></ul><p><img src="https://s2.loli.net/2023/11/08/tfkvCcnuqFlHrdJ.png" alt="rdKey2"></p><p><strong>自定义限流处理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;<br><span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerBlockHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title function_">handlerException</span><span class="hljs-params">(BlockException exception)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">4444</span>,<span class="hljs-string">&quot;按客戶自定义,global handlerException----1&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title function_">handlerException2</span><span class="hljs-params">(BlockException exception)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">4444</span>,<span class="hljs-string">&quot;按客戶自定义,global handlerException----2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitController</span> &#123;<br>...<br><br>    <span class="hljs-meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span><br><span class="hljs-meta">            blockHandlerClass = CustomerBlockHandler.class,//&lt;-------- 自定义限流处理类</span><br><span class="hljs-meta">            blockHandler = &quot;handlerException2&quot;)</span><span class="hljs-comment">//&lt;-----------</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">customerBlockHandler</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;按客戶自定义&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-number">2020L</span>,<span class="hljs-string">&quot;serial003&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-服务熔断"><a href="#3-服务熔断" class="headerlink" title="3. 服务熔断"></a>3. 服务熔断</h3><blockquote><p>sentinel整合ribbon+openFeign+fallback</p></blockquote><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--负载均衡--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--SpringCloud Alibaba nacos --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--SpringCloud Alibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!--SpringCloud Alibaba sentinel --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--openfeign--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>无配置</strong></p><blockquote><p>给用户error页面</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleBreakerController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br> <br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;)</span><span class="hljs-comment">//没有配置</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span><br>    &#123;<br>        CommonResult&lt;Payment&gt; result = <br>            restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);<br><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>只配置fallback</strong></p><blockquote><p>fallback只负责业务异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleBreakerController</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br> <br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span> <span class="hljs-comment">//fallback只负责业务异常</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>        CommonResult&lt;Payment&gt; result = <br>            restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);<br><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-comment">//本例是fallback</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">handlerFallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,Throwable e)</span> &#123;<br>        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(id,<span class="hljs-string">&quot;null&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>&lt;&gt;(<span class="hljs-number">444</span>,<span class="hljs-string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>只配置blockHandler</strong></p><blockquote><p>blockHandler只负责<strong>sentinel控制台配置违规</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleBreakerController</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span><br>    <span class="hljs-comment">//blockHandler只负责sentinel控制台配置违规</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;)</span> <br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span><br>    &#123;<br>        CommonResult&lt;Payment&gt; result = <br>            restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);<br><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//本例是blockHandler</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">blockHandler</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,BlockException blockException)</span> &#123;<br>        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(id,<span class="hljs-string">&quot;null&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>&lt;&gt;(<span class="hljs-number">445</span>,<br>                                  <span class="hljs-string">&quot;blockHandler-sentinel限流,无此流水: blockException &quot;</span><br>                                  +blockException.getMessage(),payment);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>fallback和blockHandler都配置</strong></p><blockquote><p>被限流降级而抛出BlockException时只会进入blockHandler处理逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleBreakerController</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVICE_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span><br>    &#123;<br>        CommonResult&lt;Payment&gt; result = <br>            restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);<br><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//本例是fallback</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">handlerFallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,Throwable e)</span> &#123;<br>        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(id,<span class="hljs-string">&quot;null&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>&lt;&gt;(<span class="hljs-number">444</span>,<span class="hljs-string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);<br>    &#125;<br>    <span class="hljs-comment">//本例是blockHandler</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">blockHandler</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,BlockException blockException)</span> &#123;<br>        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(id,<span class="hljs-string">&quot;null&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>&lt;&gt;(<span class="hljs-number">445</span>,<br>                                  <span class="hljs-string">&quot;blockHandler-sentinel限流,无此流水: blockException &quot;</span><br>                                  +blockException.getMessage(),payment);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>exceptionsToIgnore</strong></p><blockquote><p>忽略指定异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleBreakerController</span>    <br><br>    ...<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span><br><span class="hljs-meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span> <span class="hljs-comment">//&lt;-------------</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title function_">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span><br>    &#123;<br>        CommonResult&lt;Payment&gt; result = <br>            restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);<br><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-comment">//exceptionsToIgnore属性有IllegalArgumentException.class，</span><br>            <span class="hljs-comment">//所以IllegalArgumentException不会跳入指定的兜底程序。</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span> (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h3><blockquote><p>一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化</p></blockquote><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，</p><p>只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。</p><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--持久化用到--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>YML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">datasource:</span> <span class="hljs-comment">#&lt;---------------------------关注点，添加Nacos数据源配置</span><br>        <span class="hljs-attr">ds1:</span><br>          <span class="hljs-attr">nacos:</span><br>            <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>            <span class="hljs-attr">dataId:</span> <span class="hljs-string">cloudalibaba-sentinel-service</span><br>            <span class="hljs-attr">groupId:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>            <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span><br>            <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/08/s4j3Hc6SEXRdrbZ.png" alt="cjh"></p><p><strong>配置限流规则</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rateLimit/byUrl&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;limitApp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;grade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;strategy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;controlBehavior&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clusterMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><ul><li>resource：资源名称</li><li>limitApp：来源应用</li><li>grade：阈值类型，0表示线程数, 1表示QPS</li><li>count：单机阈值</li><li>strategy：流控模式，0表示直接，1表示关联，2表示链路</li><li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待</li><li>clusterMode：是否集群</li></ul><h2 id="三、Seata"><a href="#三、Seata" class="headerlink" title="三、Seata"></a>三、Seata</h2><blockquote><p>分布式事务解决方案</p></blockquote><p><strong>分布式事务</strong></p><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，</p><p>业务操作需要调用三个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证</strong>。</p><p><img src="https://s2.loli.net/2023/11/08/N9rZmgVq1TOCPwK.png" alt="sw"></p><p><strong>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</strong>。</p><p><strong>seata解决方案</strong></p><blockquote><p>我们只需要使用一个 <code>@GlobalTransactional</code> 注解在业务方法上</p></blockquote><p><img src="https://s2.loli.net/2023/11/08/OoqyYLtQlb7PwxB.png" alt="seata"></p><p><strong>Seata的工作流程</strong></p><p>分布式事务处理过程的一ID+三组件模型：</p><ul><li><p>Transaction ID XID 全局唯一的事务ID</p></li><li><p>三组件概念</p><ul><li><strong>TC</strong> (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li><li><strong>TM</strong> (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li><li><strong>RM</strong> (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul></li><li><p>处理过程：</p><ul><li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</li><li>XID在微服务调用链路的上下文中传播；</li><li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；</li><li>TM向TC发起针对XID的全局提交或回滚决议；</li><li>TC调度XID下管辖的全部分支事务完成提交或回滚请求。</li></ul></li></ul><p><img src="https://s2.loli.net/2023/11/08/nT7giZOw1SDsCYA.png" alt="seata"></p><h3 id="1-配置-2"><a href="#1-配置-2" class="headerlink" title="1. 配置"></a>1. 配置</h3><ul><li><p><strong>file.conf</strong></p><ul><li><p>service模块</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">service &#123;<br>    <span class="hljs-comment">##fsp_tx_group是自定义的</span><br>    vgroup_mapping.<span class="hljs-keyword">my</span>.test.tx_group=<span class="hljs-string">&quot;fsp_tx_group&quot;</span> <br>    default.grouplist = <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span><br>    enableDegrade = <span class="hljs-literal">false</span><br>    disable = <span class="hljs-literal">false</span><br>    max.commitretry.<span class="hljs-keyword">timeout</span>= <span class="hljs-string">&quot;-1&quot;</span><br>    max.ollbackretry.<span class="hljs-keyword">timeout</span>= <span class="hljs-string">&quot;-1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>store模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## transaction log store</span><br>store &#123;<br><span class="hljs-comment">## store mode: file, db</span><br><span class="hljs-comment">## 改成db</span><br>mode = <span class="hljs-string">&quot;db&quot;</span><br><br><span class="hljs-comment">## file store</span><br>file &#123;<br><span class="hljs-built_in">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span><br><br><span class="hljs-comment"># branch session size, if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="hljs-built_in">max</span>-branch-session-size = <span class="hljs-number">16384</span><br><span class="hljs-comment"># globe session size, if exceeded throws exceptions</span><br><span class="hljs-built_in">max</span>-<span class="hljs-keyword">global</span>-session-size = <span class="hljs-number">512</span><br><span class="hljs-comment"># file buffer size, if exceeded allocate new buffer</span><br>file-write-buffer-cache-size = <span class="hljs-number">16384</span><br><span class="hljs-comment"># when recover batch read size</span><br>session.reload.read_size= <span class="hljs-number">100</span><br><span class="hljs-comment"># async, sync</span><br>flush-disk-mode = <span class="hljs-keyword">async</span><br>&#125;<br><br><span class="hljs-comment"># database store</span><br>db &#123;<br><span class="hljs-comment">## the implement of javax.sql.DataSource, </span><br><span class="hljs-comment">## such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br>datasource = <span class="hljs-string">&quot;dbcp&quot;</span><br><span class="hljs-comment">## mysql/oracle/h2/oceanbase etc.</span><br><span class="hljs-comment">## 配置数据源</span><br>db-<span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;mysql&quot;</span><br>driver-<span class="hljs-keyword">class</span>-name = <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span><br>url = <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br>user = <span class="hljs-string">&quot;root&quot;</span><br>password = <span class="hljs-string">&quot;你自己密码&quot;</span><br><span class="hljs-built_in">min</span>-conn= <span class="hljs-number">1</span><br><span class="hljs-built_in">max</span>-conn = <span class="hljs-number">3</span><br><span class="hljs-keyword">global</span>.table = <span class="hljs-string">&quot;global_table&quot;</span><br>branch.table = <span class="hljs-string">&quot;branch_table&quot;</span><br>lock-table = <span class="hljs-string">&quot;lock_table&quot;</span><br>query-limit = <span class="hljs-number">100</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>mysql5.7数据库新建库seata，在seata库里建表</p><ul><li>建表db_store.sql在\seata-server-0.9.0\seata\conf目录里面</li></ul></li><li><p><strong>registry.conf</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">registry</span> &#123;<br>  <span class="hljs-comment"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br>  <span class="hljs-comment"># 改用为nacos</span><br>  <span class="hljs-attribute">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><br>  nacos &#123;<br>  <span class="hljs-comment">## 加端口号</span><br>    <span class="hljs-attribute">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br>    namespace = <span class="hljs-string">&quot;&quot;</span><br>    cluster = <span class="hljs-string">&quot;default&quot;</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>YML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">alibaba:</span><br>      <span class="hljs-attr">seata:</span><br>        <span class="hljs-comment">#自定义事务组名称需要与seata-server中的对应</span><br>        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span><br></code></pre></td></tr></table></figure><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p><strong>整体机制</strong></p><p>两阶段提交协议的演变：</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段：<ul><li>提交异步化，非常快速地完成。</li><li>回滚通过一阶段的回滚日志进行反向补偿。</li></ul></li></ul><p><strong>一阶段加载</strong></p><blockquote><p>在一阶段，Seata会拦截“业务SQL” </p></blockquote><ul><li><p>解析SQL语义，找到“业务SQL” 要更新的业务数据，在业务数据被更新前，将其保存成”before image”</p></li><li><p>执行“业务SQL” 更新业务数据，在业务数据更新之后,</p></li><li><p>其保存成”after image”，最后生成行锁。</p></li></ul><p>以上操作全部在一个数据库事务内完成, 这样保证了一阶段操作的原子性。</p><p><img src="https://s2.loli.net/2023/11/08/CYMJWHKskquOF7l.png" alt="styl"></p><p><strong>二阶段提交</strong></p><p>二阶段如果顺利提交的话，因为”业务SQL”在一阶段已经提交至数据库，</p><p>所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p><p><img src="https://s2.loli.net/2023/11/08/4EexJYUvTZKtcm6.png" alt="styl2"></p><p><strong>二阶段回滚</strong></p><p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的 “业务SQL”，还原业务数据。</p><p>回滚方式便是用”before image”还原业务数据；<strong>但在还原前要首先要校验脏写</strong>，对比“数据库当前业务数据”和”after image”。</p><p>如果两份数据完全一致就说明没有脏写， 可以还原业务数据，如果不一致就说明有脏写, 出现脏写就需要<strong>转人工处理。</strong></p><p><img src="https://s2.loli.net/2023/11/08/Q2TZaFCOSjWnp7N.png" alt="styl3"></p><p><strong>总结</strong></p><p><img src="https://s2.loli.net/2023/11/08/XIRVnQpPaksGeYO.png" alt="styl4"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2023/12/11/RabbitMQ/"/>
    <url>/2023/12/11/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>MQ(message queue)，本质是个队列，FIFO 先入先出。是一种跨进程的通信机制，用于上下游传递消息<br>“逻辑解耦+物理解耦” 的消息通信服务</p></blockquote><h2 id="一、MQ的介绍"><a href="#一、MQ的介绍" class="headerlink" title="一、MQ的介绍"></a>一、MQ的介绍</h2><h3 id="1-简单作用"><a href="#1-简单作用" class="headerlink" title="1. 简单作用"></a>1. 简单作用</h3><ul><li><p><strong>流量消峰</strong></p><p>电商系统在高峰期，短时间<strong>大量访问无法处理</strong>，只能限制订单超过规定值后，不允许用户下单。<br>但用消息队列做缓冲，可以<strong>把订单分散</strong>成一段时间来处理， 这时用户可能在下单十几秒后才能收到下单成功通知。</p></li><li><p><strong>应用解耦</strong></p><p>在电商应用中，多系统功能结构如果耦合 ，则任何一个子系统出了故障，都会造成下单操作异常。<br>当转变成基于 消息队列的方式后，如物流系统因为发生故障，需要几分钟来修复。<br>在这时，物流系统要处理的数据<strong>被缓存在消息队列</strong>中，下单操作可以正常完成。<br>当系统恢复后，会继续处理订单信息，提升系统的可用性。</p><p><img src="https://s2.loli.net/2023/12/08/Ise9NAaGWzTpyEP.png" alt="jieo"></p></li><li><p><strong>异步处理</strong></p><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式：</p><ul><li><p>A 过一段时间去调用 B 的查询 api 查询。</p></li><li><p>A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。</p></li></ul><p>如使用消息总线，可以很方便解决这个问题</p><p>​A 调用 B 服务后，<strong>只需要监听</strong> B 处理完成的消息，<br>​当 B 处理完成后，会发送一 条消息给 MQ，MQ 会将此消息转发给 A 服务。<br>​这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。<br>​同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p></li></ul><p><img src="https://s2.loli.net/2023/12/08/I2XUcVuQ8EOyiAf.png" alt="async"></p><h3 id="2-RabbitMQ的特性"><a href="#2-RabbitMQ的特性" class="headerlink" title="2. RabbitMQ的特性"></a>2. RabbitMQ的特性</h3><blockquote><p>是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统</p></blockquote><ul><li><p>由 <strong>erlang</strong> 语言开发，具有高并发特性，性能较好</p></li><li><p>万级吞吐量，MQ 功能比较完备,健壮、稳定、易用、跨平台</p></li><li><p>支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等</p></li><li><p>如果<strong>数据量没有那么大</strong>，优先选择功能比较完备的 RabbitMQ</p></li></ul><p>注：运行RabbitMQ需要有erlang语言环境</p><p><strong><a href="https://www.rabbitmq.com/news.html">RabbitMQ | 官网</a></strong></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><blockquote><p>在 Linux Centos7 环境下进行</p></blockquote><ul><li><p>版本选择</p><ul><li>erlang-21.3.8.21-1.el7.x86_64.rpm</li><li>rabbitmq-server-3.8.8-1.el7.noarch.rpm</li></ul></li><li><p><strong><a href="https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm">下载地址</a></strong></p></li></ul><h3 id="1-部署与启动"><a href="#1-部署与启动" class="headerlink" title="1. 部署与启动"></a>1. 部署与启动</h3><p><strong>安装Erlang</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># -ivh 显示进度安装</span><br>rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p><strong>安装RabbitMQ</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装依赖包</span><br>yum install socat -y<br>rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm<br></code></pre></td></tr></table></figure><p><strong>安装Web端管理插件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><p><strong>启动MQ服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动服务</span><br>systemctl start rabbitmq-server<br><span class="hljs-comment"># 查看服务状态</span><br>systemctl status rabbitmq-server<br><span class="hljs-comment"># 开机自启动</span><br>systemctl <span class="hljs-built_in">enable</span> rabbitmq-server<br><span class="hljs-comment"># 停止服务</span><br>systemctl stop rabbitmq-server<br><span class="hljs-comment"># 重启服务</span><br>systemctl restart rabbitmq-server<br></code></pre></td></tr></table></figure><h3 id="2-使用Web界面"><a href="#2-使用Web界面" class="headerlink" title="2. 使用Web界面"></a>2. 使用Web界面</h3><p><strong>开启防火墙端口</strong></p><ul><li><p>RabbitMQ默认端口</p><ul><li><p><code>5672</code>：</p><p>用于 RabbitMQ 服务器的主要通信。客户端可以使用该端口连接到 RabbitMQ 服务器，<br>并通过 AMQP 协议进行消息发布、消费和管理队列等操作。</p></li><li><p><code>15672</code>：Web端默认端口</p></li><li><p><code>25672</code>：与客户端之间的通信端口，用于建立 AMQP 连接和传输消息</p></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 开启端口</span><br>firewall-cmd --permanent --add-port=5672/tcp<br><span class="hljs-comment"># 重载配置</span><br>firewall-cmd --reload<br><span class="hljs-comment"># 查看开放的端口</span><br>firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><p><strong>添加Web端账号</strong></p><blockquote><p>默认账号只能在本机登录，无法远程登录</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建账号和密码 （如果是云服务器，则密码尽量复杂）</span><br>rabbitmqctl add_user admin 123456<br><br><span class="hljs-comment"># 设置用户角色</span><br>rabbitmqctl set_user_tags admin administrator<br><br><span class="hljs-comment"># 为用户添加资源权限 设置不限ip访问  添加配置、写、读权限</span><br><span class="hljs-comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br>rabbitmqctl set_permissions -p <span class="hljs-string">&quot;/&quot;</span> admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure><p><strong>用户级别</strong></p><ul><li><p><code>administrator</code>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理</p></li><li><p><code>monitoring</code>：监控者 登录控制台，查看所有信息</p></li><li><p><code>policymaker</code>：策略制定者 登录控制台，指定策略</p></li><li><p><code>managment</code>：普通管理员 登录控制台</p></li></ul><p><strong>相关命令</strong></p><ul><li><p>关闭应用：<code>rabbitmqctl stop_app</code></p></li><li><p>重置：<code>rabbitmqctl reset</code></p></li><li><p>重新启动：<code>rabbitmqctl start_app</code></p></li></ul><h2 id="三、入门案例"><a href="#三、入门案例" class="headerlink" title="三、入门案例"></a>三、入门案例</h2><blockquote><p>使用Java编写一个生产者，消费者，使消费者接收生产者的消息</p></blockquote><p><strong>流程图</strong></p><p>图中红色方块为消息队列</p><p><img src="https://s2.loli.net/2023/12/08/XYfbxpijTqZr1Fz.png" alt="lct"></p><h3 id="1-创建POM模块"><a href="#1-创建POM模块" class="headerlink" title="1. 创建POM模块"></a>1. 创建POM模块</h3><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--rabbitmq 依赖客户端--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--操作文件流的一个依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0-alpha5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--指定 jdk 编译版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">provider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//        创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br><br>        factory.setHost(<span class="hljs-string">&quot;服务器IP地址&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;@123@&quot;</span>);<br><br><span class="hljs-comment">//        创建连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br><span class="hljs-comment">//        创建信道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><span class="hljs-comment">//        创建队列</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1.队列名称</span><br><span class="hljs-comment">         * 2.持久化</span><br><span class="hljs-comment">         * 3.是否一个消费者独有</span><br><span class="hljs-comment">         * 4.自动删除</span><br><span class="hljs-comment">         * 5.其他参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//        发送消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello RabbitMQ!&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;服务器IP地址&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;@123@&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br><span class="hljs-comment">//        消费者接收到消息时的回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (String consumerTag, Delivery message) -&gt;<br>                System.out.println(<span class="hljs-string">&quot;消费者接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br><br><span class="hljs-comment">//        消费者取消的回调</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> consumerTag -&gt; System.out.println(<span class="hljs-string">&quot;消费者取消消息 : &quot;</span> + consumerTag);<br><br><span class="hljs-comment">//        接收消息</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 队列名称</span><br><span class="hljs-comment">        2. 成功后是否自动应答</span><br><span class="hljs-comment">        3. 消费者接收到消息时的回调</span><br><span class="hljs-comment">        4. 消费者取消的回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者成功接收</strong></p><p><img src="https://s2.loli.net/2023/12/08/gvCminqLxU2cXfO.png" alt="qd"></p><h3 id="2-轮巡分发"><a href="#2-轮巡分发" class="headerlink" title="2. 轮巡分发"></a>2. 轮巡分发</h3><blockquote><p>RabbitMQ默认为轮巡分发</p></blockquote><p><strong>创建连接工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQUtil</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;服务器IP地址&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;@123@&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-keyword">return</span> connection.createChannel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">provider</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 获取信道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><span class="hljs-comment">// 生成队列</span><br>        channel.queueDeclare(QUEUE_NAME,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 发送消息</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;发送完成&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br>        <span class="hljs-comment">// 消费者接收到消息时的回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (String consumerTag, Delivery message) -&gt;<br>                System.out.println(<span class="hljs-string">&quot;消费者接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br><br>        <span class="hljs-comment">// 消费者取消的回调</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> consumerTag -&gt; System.out.println(<span class="hljs-string">&quot;消费者取消消息 : &quot;</span> + consumerTag);<br><br>        <span class="hljs-comment">// 接收消息</span><br>        System.out.println(<span class="hljs-string">&quot;C1_等待接收消息......&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开启多个消费者</strong></p><p><img src="https://s2.loli.net/2023/12/08/gs7uWPEKQpjnGFZ.png" alt="duokai"></p><p><strong>启动</strong></p><p><img src="https://s2.loli.net/2023/12/08/WH6TYftErJV2ZQM.png" alt="fs"></p><p><img src="https://s2.loli.net/2023/12/08/zonYUgKt9u8JmRh.png" alt="c1"></p><p><img src="https://s2.loli.net/2023/12/08/TVgncL8BaNUQskY.png" alt="c2"></p><h3 id="3-消息应答"><a href="#3-消息应答" class="headerlink" title="3. 消息应答"></a>3. 消息应答</h3><blockquote><p>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 处理完成，mq则将消息删除。防止未处理的消息丢失</p></blockquote><p><strong>自动应答</strong></p><p>消息发送后<strong>立即被认为已经传送成功</strong>，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong><br>这种模式消息在接收到之前，消费者<strong>宕机或关闭</strong>，消息就会丢失，<br>当然这种模式消费者可以接收过载的消息，<strong>没有对传递的消息数量进行限制</strong>，<br>不过这样有可能使得消费者这边，产生来大量不及处理的消息，<strong>导致消息的积压</strong>，使内存耗尽。<br><strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p><p><strong>手动应答</strong></p><p> 手动消息应答的方法</p><ul><li><code>Channel.basicAck</code>：肯定确认</li><li><code>Channel.basicNack</code>：否定确认</li><li><code>Channel.basicReject</code>：否定确认，不处理该消息直接拒绝，<strong>可以丢弃</strong></li></ul><p>手动应答中可以通过批量应答解决网络拥堵</p><p><img src="https://s2.loli.net/2023/12/08/rAkQEf6bHFPqz4W.png" alt="ack"></p><ul><li><code>true</code> 代表批量应答 channel 上未应答的所有消息</li><li><code>false</code> 只会应答当前 tag 的消息</li></ul><p><img src="https://s2.loli.net/2023/12/08/NgjkrtuscJZFXol.png" alt="pl"></p><p><strong>消息自动重新入队</strong></p><p>RabbitMQ 会将未应答的消息重新竟然队列，如果此时其他消费者可以处理，它将会被分发给另一个消费者。<br>这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><strong>代码实现</strong></p><ul><li><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consuemr</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br>        System.out.println(<span class="hljs-string">&quot;C1等待处理时间较长&quot;</span>);<br><br><span class="hljs-comment">// 消费者消息处理</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (tag, msg) -&gt; &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;接收到消息&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8));<br><br>            channel.basicAck(msg.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>      <br><span class="hljs-comment">// 接收消息</span><br>        channel.basicConsume(TASK_QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, System.out::println);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动两个消费者，一个10s 一个3s</p></li><li><p>消费者发送两条消息，默认轮巡</p></li><li><p>如在10s内关闭消费者一，则消费者二会接收到第二条消息</p></li></ul><h3 id="4-队列持久化"><a href="#4-队列持久化" class="headerlink" title="4. 队列持久化"></a>4. 队列持久化</h3><blockquote><p>默认情况下 RabbitMQ 某种原因关闭时，它会忽视队列和消息，造成消息丢失。<br>我们需要将队列和消息都标记为持久化</p></blockquote><p><strong>队列持久化</strong></p><p>之前创建的队列都是非持久化的，当 rabbitmq 重启，队列就会<strong>被删除掉</strong>，<br>要队列实现持久化，需要在声明队列的时候把 <code>durable</code> 参数设置为 <code>true</code></p><p><img src="https://s2.loli.net/2023/12/08/nIcC74KsOPleNtS.png" alt="dru"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 设置队列持久化</span><br>channel.queueDeclare(TASK_QUEUE_NAME,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>注意：修改队列属性后，需要将原来队列先删除</p><p>修改成功后，Web控制台会显示</p><p><img src="https://s2.loli.net/2023/12/08/Xw8Qxd3Wg9G52nD.png" alt="dur"></p><p><strong>消息持久化</strong></p><p>需要在生产者发送消息时，设置消息的属性 <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 设置消息持久化</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,msg.getBytes());<br></code></pre></td></tr></table></figure><h3 id="5-不公平分发"><a href="#5-不公平分发" class="headerlink" title="5. 不公平分发"></a>5. 不公平分发</h3><blockquote><p>能者多劳，高性能服务器应该处理更多消息，保证资源不被浪费</p></blockquote><p><strong>在接收消息之前设置不公平分发</strong></p><p>在当前任务还没完成，或者没有应答，rabbitmq 就会把该任务分配给有空闲的消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 设置不公平分发</span><br><span class="hljs-comment"> 0:轮巡</span><br><span class="hljs-comment"> 1:不公平分发，能者多劳</span><br><span class="hljs-comment"> */</span><br>channel.basicQos(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 接收消息</span><br>channel.basicConsume(TASK_QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, System.out::println);<br></code></pre></td></tr></table></figure><h3 id="6-预取值分发"><a href="#6-预取值分发" class="headerlink" title="6. 预取值分发"></a>6. 预取值分发</h3><blockquote><p>限制信道缓冲区的大小</p></blockquote><p>一般来说，增加预取将<strong>提高</strong>向消费者传递消息的速度。但<strong>已传递未处理</strong>的消息的数量也会增加，从而增加了消费者的内存消耗，所以需要合适的预取值。不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  设置不公平分发</span><br><span class="hljs-comment">  0:轮巡</span><br><span class="hljs-comment">  1:不公平分发，能者多劳</span><br><span class="hljs-comment">  &gt;1:预取值，设置信道能堆积消息的&#x27;最大值&#x27;</span><br><span class="hljs-comment">*/</span><br>channel.basicQos(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 接收消息</span><br>channel.basicConsume(TASK_QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, System.out::println);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/12/08/cSJW2eAH8vqfUla.png" alt="yqz"></p><h2 id="四、发布确认"><a href="#四、发布确认" class="headerlink" title="四、发布确认"></a>四、发布确认</h2><p><strong>原理</strong></p><p>生产者将信道设置成 confirm 模式，所有在该信道上面发布的消息都将会被指派一个<strong>唯一的 ID</strong>(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会<strong>发送一个确认</strong>给生产者(包含消息的唯一 ID)，</p><p>这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息<strong>写入磁盘之后发出</strong>，broker 回传给生产者的确认消息中 <code>delivery-tag</code> 域包含了确认消息的<strong>序列号</strong>，此外 broker 也可以设置 <code>basic.ack</code> 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是<strong>异步</strong>的，一旦发布一条消息，生产者应用程序就可以<strong>在等信道返回确认的同时继续发送下一条消息</strong>，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，<br>如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 <code>nack</code> 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p><strong>开启发布确认</strong></p><p>在生产者开启发布确认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 开启发布确认</span><br>channel.confirmSelect();<br></code></pre></td></tr></table></figure><h3 id="1-单个发布确认"><a href="#1-单个发布确认" class="headerlink" title="1. 单个发布确认"></a>1. 单个发布确认</h3><blockquote><p>它是一种<strong>同步确认发布</strong>的方式，只有前一条消息被确认发布，后续的消息才能继续发布，</p><p><strong>发布速度特别的慢</strong>，前一条没有确认发布就会<strong>阻塞</strong>后续消息发布，最多提供每秒不超过数百条发布消息的吞吐量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Individually</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br><span class="hljs-comment">// 声明对列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">qName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        channel.queueDeclare(qName,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 开启发布确认</span><br>        channel.confirmSelect();<br><br><span class="hljs-comment">// 计算时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><span class="hljs-comment">// 发布消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,qName,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;&quot;</span>+i).getBytes());<br>            <span class="hljs-keyword">if</span> (channel.waitForConfirms())&#123;<br>                System.out.println(<span class="hljs-string">&quot;消息发送成功&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;发布 &quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot; 条消息 ，用时 &quot;</span> + (end-begin) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-批量发布确认"><a href="#2-批量发布确认" class="headerlink" title="2. 批量发布确认"></a>2. 批量发布确认</h3><blockquote><p>先发布一批消息然后一起确认可以极大地提高吞吐量</p><p>当发布出现问题时，不知道是哪个消息出问题了，必须<strong>将整个批处理保存在内存中</strong>，<br>以记录重要的信息而后重新发布消息。这种方案仍然是<strong>同步</strong>的，也一样阻塞消息的发布。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br><span class="hljs-comment">// 声明对列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">qName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        channel.queueDeclare(qName,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 开启发布确认</span><br>        channel.confirmSelect();<br><br><span class="hljs-comment">// 计算时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><span class="hljs-comment">// 批量确认大小</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">batchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 发布消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= MESSAGE_COUNT; i++) &#123;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,qName,<span class="hljs-literal">null</span>,(<span class="hljs-string">&quot;&quot;</span>+i).getBytes());<br><br>            <span class="hljs-keyword">if</span> (i % batchCount == <span class="hljs-number">0</span>)&#123;<br>                channel.waitForConfirms();<br>                System.out.println(<span class="hljs-string">&quot;发送成功&quot;</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;发布 &quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot; 条消息 ，用时 &quot;</span> + (end-begin) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-异步发布确认"><a href="#3-异步发布确认" class="headerlink" title="3. 异步发布确认"></a>3. 异步发布确认</h3><blockquote><p>利用<strong>回调函数</strong>来达到消息可靠性传递，通过函数回调来保证是否投递成功</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">async</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br><span class="hljs-comment">// 声明对列</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">qName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        channel.queueDeclare(qName,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 开启发布确认</span><br>        channel.confirmSelect();<br><br><span class="hljs-comment">// 创建一个线程安全哈希表</span><br>        ConcurrentSkipListMap&lt;Long , String&gt; outConfirms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 计算时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><span class="hljs-comment">// 成功，回调函数</span><br>        <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">ackCallBack</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (multiple)&#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                  删除此tag之前的所有值</span><br><span class="hljs-comment">                  headmap会返回map中比tag小的所有值的视图，将视图清空会随之将map中的对应的值删除</span><br><span class="hljs-comment">                 */</span><br>                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =<br>                        outConfirms.headMap(deliveryTag);<br>                confirmed.clear();<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                outConfirms.remove(deliveryTag);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;确认 &quot;</span>+ deliveryTag);<br>        &#125;;<br><span class="hljs-comment">// 失败，回调函数</span><br>        <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">nackCallBack</span> <span class="hljs-operator">=</span> (deliveryTag, multiple)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;未确认 &quot;</span> + deliveryTag);<br>        &#125;;<br><br><span class="hljs-comment">// 设置消息监听器(异步)</span><br>        channel.addConfirmListener(ackCallBack,nackCallBack);<br><br><span class="hljs-comment">// 发布消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + i;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,qName,<span class="hljs-literal">null</span>, msg.getBytes());<br>            outConfirms.put(channel.getNextPublishSeqNo(), msg);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;发布 &quot;</span> + MESSAGE_COUNT + <span class="hljs-string">&quot; 条消息 ，用时 &quot;</span> + (end-begin) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="五、交换机"><a href="#五、交换机" class="headerlink" title="五、交换机"></a>五、交换机</h2><blockquote><p><strong>生产者只能将消息发送到交换机(exchange)</strong></p><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。<br>实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</p></blockquote><p>交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。<br>交换机必须知道如何处理收到的消息。消息如何发送，就是由交换机的类型来决定。</p><p><img src="https://s2.loli.net/2023/12/08/sQrb3qZul5KGFOt.png" alt="jhj"></p><p><strong>Exchanges的类型：</strong></p><ul><li><p><strong>直接(direct)<strong>：这是最简单的一种类型。根据消息的路由键（routingKey）将消息发送到与指定路由键</strong>完全匹配</strong>的队列。只有完全匹配的队列会接收到消息。</p></li><li><p><strong>主题(topic)<strong>：路由键可以使用</strong>通配符</strong>来指定路由键的匹配规则。例如，路由键为 <code>red.orange.yellow</code> 的消息可以匹配到键为 <code>*.orange.*</code>的队列。</p></li><li><p><strong>标题(headers)<strong>：根据消息的标题（headers）属性来匹配消息，并将其发送到与匹配的规则</strong>完全匹配</strong>的队列。标题属性是一组键值对，并且匹配规则可以使用各种逻辑操作符来定义，例如等于、不等于、存在等。</p></li><li><p><strong>扇出(fanout)<strong>：扇出交换将消息发送到</strong>与之绑定的所有队列</strong>，忽略消息的路由键。这种交换方式<strong>广播消息</strong>给所有绑定的队列，无论它们的数量和位置。</p></li></ul><p><strong>BInding 交换机与队列绑定</strong></p><p><img src="https://s2.loli.net/2023/12/08/1ThVQKr6WJfg9xn.png" alt="binding"></p><h3 id="1-Fanout交换机"><a href="#1-Fanout交换机" class="headerlink" title="1. Fanout交换机"></a>1. Fanout交换机</h3><blockquote><p>它是将接收到的所有消息<strong>广播</strong>到它绑定的所有队列中</p></blockquote><p><img src="https://s2.loli.net/2023/12/08/HFpEz4M5DL1VRIT.png" alt="fanout"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogs01</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br><span class="hljs-comment">// 声明交换机</span><br>        channel.exchangeDeclare(EXCHANGE_NAME,<span class="hljs-string">&quot;fanout&quot;</span>);<br><br><span class="hljs-comment">// 生成临时队列，当与发送者断开连接时会自动删除</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br><br><span class="hljs-comment">// 绑定队列到交换机</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;ReceiveLogs01 正在等待消息。。。。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag,msg)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8));<br><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelBack</span> <span class="hljs-operator">=</span> (consumerTag)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;取消接收 &quot;</span> + consumerTag);<br><br><span class="hljs-comment">// 接收消息</span><br>        channel.basicConsume(queueName,<span class="hljs-literal">true</span>,ackBack,cancelBack);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Direct交换机"><a href="#2-Direct交换机" class="headerlink" title="2. Direct交换机"></a>2. Direct交换机</h3><blockquote><p>消息只去到它绑定的 routingKey 一致的队列中去</p></blockquote><p><strong>单一绑定</strong></p><p><img src="https://s2.loli.net/2023/12/08/OUXqywiYF7R8orn.png" alt="direct"></p><p><strong>多重绑定</strong></p><p><img src="https://s2.loli.net/2023/12/08/76WeJKvoNjs19TE.png" alt="direct"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsDirect01</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br><span class="hljs-comment">// 声明交换机</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br><span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;console&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 绑定队列到交换机</span><br>        channel.queueBind(<span class="hljs-string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(<span class="hljs-string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="hljs-string">&quot;warning&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;ReceiveLogsDirect01 正在等待消息。。。。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag, msg)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8));<br><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelBack</span> <span class="hljs-operator">=</span> (consumerTag)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;取消接收 &quot;</span> + consumerTag);<br><br><span class="hljs-comment">// 接收消息</span><br>        channel.basicConsume(<span class="hljs-string">&quot;console&quot;</span>,<span class="hljs-literal">true</span>,ackBack,cancelBack);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Topic交换机"><a href="#3-Topic交换机" class="headerlink" title="3. Topic交换机"></a>3. Topic交换机</h3><blockquote><p>通过 routingkey 通配符匹配对应的队列</p></blockquote><p> 发送到 topic 交换机的消息的 routing_key 它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>这些单词可以是任意单词</p><p>例如：”lazy.asd.rabbit”, “quasc.orange.rabbit”, “quick.orange.rabbit”.这种类型的。</p><p>当然这个单词列表最多不能超过 255 个字节。</p><p>特殊占位符：</p><ul><li>*<strong>：可以代替一个单词</strong></li><li><strong>#：可以替代零个或多个单词</strong></li></ul><p><img src="https://s2.loli.net/2023/12/08/Z8wmHOf2oj5zU1r.png" alt="topic"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReceiveLogsTopic02</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br><br>        channel.queueDeclare(<span class="hljs-string">&quot;Q2&quot;</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        channel.queueBind(<span class="hljs-string">&quot;Q2&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;*.*.rabbit&quot;</span>);<br>        channel.queueBind(<span class="hljs-string">&quot;Q2&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.#&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;Q2(*.*.rabbit / lazy.#)等待接收。。。。。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag, msg)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8));<br><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelBack</span> <span class="hljs-operator">=</span> (consumerTag)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;取消接收 &quot;</span> + consumerTag);<br><br><span class="hljs-comment">// 接收消息</span><br>        channel.basicConsume(<span class="hljs-string">&quot;Q2&quot;</span>,<span class="hljs-literal">true</span>,ackBack,cancelBack);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、死信队列"><a href="#六、死信队列" class="headerlink" title="六、死信队列"></a>六、死信队列</h2><blockquote><p>由于某些原因<strong>导致 queue 中的某些消息无法被消费</strong>，且没有后续的处理，就变成了死信，有了死信就有了死信队列</p></blockquote><p><strong>应用场景：</strong></p><p>​为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p><p><strong>死信的来源</strong></p><ul><li><p><strong>消息 TTL 过期</strong></p><p>TTL是Time To Live的缩写, 也就是生存时间</p></li><li><p><strong>队列达到最大长度</strong></p><p>队列满了，无法再添加数据到 mq 中</p></li><li><p><strong>消息被拒绝</strong></p><p>(basic.reject 或 basic.nack) 并且 requeue&#x3D;false</p></li></ul><h3 id="1-TTL死信"><a href="#1-TTL死信" class="headerlink" title="1. TTL死信"></a>1. TTL死信</h3><p><img src="https://s2.loli.net/2023/12/08/U3DicKPbvaAzJfR.png" alt="dead"></p><p><strong>消费者C1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br><br><span class="hljs-comment">// 普通交换机</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br><span class="hljs-comment">// 死信交换机</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_queue&quot;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br><span class="hljs-comment">// 声明交换机和队列</span><br>        channel.exchangeDeclare(NORMAL_EXCHANGE, <span class="hljs-string">&quot;direct&quot;</span>, <span class="hljs-literal">true</span>);<br>        channel.exchangeDeclare(DEAD_EXCHANGE, <span class="hljs-string">&quot;direct&quot;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 配置普通队列</span><br>        Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置死信交换机</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);<br>        <span class="hljs-comment">// 设置RoutingKey</span><br>        arguments.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-comment">// 过期时间(一般在发送消息时，设置过期时间)</span><br>        <span class="hljs-comment">//arguments.put(&quot;x-message-ttl&quot;, 10000);</span><br>        channel.queueDeclare(NORMAL_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br><br>        channel.queueDeclare(DEAD_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 绑定交换机与队列</span><br>        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="hljs-string">&quot;lisi&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Consumer01 等待接收消息。。。。。&quot;</span>);<br><br><br><span class="hljs-comment">// 消息处理</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag, msg) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msgs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(),StandardCharsets.UTF_8);<br>                System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ msgs);<br>                channel.basicAck(msg.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>        &#125;;<br><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelBack</span> <span class="hljs-operator">=</span> (consumerTag)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;取消接收 &quot;</span> + consumerTag);<br><br>        <span class="hljs-comment">// 拒绝则要开启手动应答</span><br>        channel.basicConsume(NORMAL_QUEUE, <span class="hljs-literal">false</span>, ackBack, cancelBack);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者C2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer02</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br>        System.out.println(<span class="hljs-string">&quot;Consumer02 等待接收消息。。。。。&quot;</span>);<br><br><br><span class="hljs-comment">// 消息处理</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag, msg)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(), StandardCharsets.UTF_8));<br><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelBack</span> <span class="hljs-operator">=</span> (consumerTag)<br>                -&gt; System.out.println(<span class="hljs-string">&quot;取消接收 &quot;</span> + consumerTag);<br><br>        channel.basicConsume(DEAD_QUEUE, <span class="hljs-literal">true</span>, ackBack, cancelBack);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtil.getChannel();<br>        <span class="hljs-comment">// 发送死信消息</span><br>        <span class="hljs-comment">// 设置TTL (ms)</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties()<br>                        .builder()<br>                        .expiration(<span class="hljs-string">&quot;10000&quot;</span>)<br>                        .build();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;info &quot;</span>+ i;<br>            channel.basicPublish(NORMAL_EXCHANGE,<span class="hljs-string">&quot;zhangsan&quot;</span>,properties,msg.getBytes());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>先启动生产者，和C1，C2,创建队列与交换机</p><ul><li>10后，C1接收到所有消息</li></ul></li><li><p>将C1关闭，重启生产者</p><ul><li>10s后，C2接收到所有消息</li></ul><p><img src="https://s2.loli.net/2023/12/08/4WHQgP9zZfh3oyM.png" alt="ttl"></p></li></ul><h3 id="2-最大长度"><a href="#2-最大长度" class="headerlink" title="2. 最大长度"></a>2. 最大长度</h3><p><strong>添加最大长度属性</strong>，注意，修改属性需先删除原先的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 设置最大长度</span><br>arguments.put(<span class="hljs-string">&quot;x-max-length&quot;</span>, <span class="hljs-number">6</span>);<br>channel.queueDeclare(NORMAL_QUEUE,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br></code></pre></td></tr></table></figure><ul><li><p>启动C1，C2，生产者，创建新队列</p><ul><li>此时，C1还是能接收到全部10条数据，因为处理速度快于堆积速度</li></ul></li><li><p>关闭C1，重启生产者</p><ul><li><p>此时，C2立即收到前四条数据</p><p><img src="https://s2.loli.net/2023/12/08/FI7y1uixfR5PVE3.png" alt="length"></p></li><li><p>10s后，接收到全部10条数据</p></li></ul></li></ul><h3 id="3-拒收消息"><a href="#3-拒收消息" class="headerlink" title="3. 拒收消息"></a>3. 拒收消息</h3><p><strong>在DeliverCallBack中添加拒收操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">ackBack</span> <span class="hljs-operator">=</span> (tag, msg) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msgs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody(),StandardCharsets.UTF_8);<br>    <span class="hljs-keyword">if</span> (msgs.equals(<span class="hljs-string">&quot;info 5&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 拒接消息</span><br>        System.out.println(<span class="hljs-string">&quot;拒接消息 &quot;</span>+msgs);<br>        <span class="hljs-comment">// 不放回原队列</span><br>        channel.basicReject(msg.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到消息 &quot;</span>+ msgs);<br>        channel.basicAck(msg.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>启动C1，C2，生产者<ul><li>拒收的消息被转发到死信队列，被C2接收</li></ul></li></ul><p><img src="https://s2.loli.net/2023/12/08/JEm6Pv8AyZQO9t7.png" alt="juj"></p><h2 id="七、整合SpringBoot"><a href="#七、整合SpringBoot" class="headerlink" title="七、整合SpringBoot"></a>七、整合SpringBoot</h2><p><strong>环境：</strong></p><ul><li>jdk8</li><li>spingboot 2.3.11.RELEASE</li></ul><p><strong>POM</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--RabbitMQ 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置文件YML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">服务器IP地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">&#x27;@123@&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="八、延时队列"><a href="#八、延时队列" class="headerlink" title="八、延时队列"></a>八、延时队列</h2><blockquote><p>延时队列就是用来存放，需要在指定时间被处理的元素的队列。</p></blockquote><p><strong>使用场景：</strong></p><ul><li><p>订单在十分钟之内未支付则自动取消 </p></li><li><p>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </p></li><li><p>用户注册成功后，如果三天内没有登陆则进行短信提醒。 </p></li><li><p>用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </p></li><li><p>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</p></li></ul><p><img src="https://s2.loli.net/2023/12/08/cLQ8SrRpHiDCVb9.png" alt="yans"></p><h3 id="1-TTL属性"><a href="#1-TTL属性" class="headerlink" title="1. TTL属性"></a>1. TTL属性</h3><blockquote><p>TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用。</p></blockquote><p><strong>队列TTL与消息TTL</strong></p><ul><li><p>设置队列的 TTL 属性，一旦消息过期，就会被队列丢弃（如果配置了死信队列被丢到死信队列中）</p></li><li><p>设置消息TTL属性，消息即使过期，也<strong>不一定会被马上丢弃</strong>，<strong>因为消息是否过期是在即将投递到消费者之前判定的</strong>，<br>如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；</p></li><li><p>注意，如果不设置 TTL，表示消息永远不会过期，<br>如果将 TTL 设置为 0，则表示除非此时<strong>可以直接投递</strong>该消息到消费者，否则该消息将会被丢弃</p></li></ul><h3 id="2-TTL队列"><a href="#2-TTL队列" class="headerlink" title="2. TTL队列"></a>2. TTL队列</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，<br>然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是direct，创建一个死信队列 QD</p><p><img src="https://s2.loli.net/2023/12/08/Cv826lGHnFQtZU5.png" alt="ttl2"></p><p><strong>编写配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TtlQueueConfig</span> &#123;<br><br>    <span class="hljs-comment">// 普通交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;X&quot;</span>;<br>    <span class="hljs-comment">// 死信交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br>    <span class="hljs-comment">// 普通队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br><br>    <span class="hljs-comment">// 死信对列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE_D</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><br>    <span class="hljs-comment">// 声明交换机</span><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_DEAD_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明队列</span><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span>&#123;<br><br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置参数</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">10000</span>);<br><br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span>&#123;<br><br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置参数</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">40000</span>);<br><br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(map).build();<br>    &#125;<br><br><br>    <span class="hljs-comment">// 死信队列</span><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DEAD_QUEUE_D).build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ABX</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueABX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params">                            <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;XA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ABY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueABY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params">                            <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * BBX</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBBX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span><br><span class="hljs-params">                            <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="hljs-string">&quot;XB&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * BBY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBBY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span><br><span class="hljs-params">                            <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueB).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * DBY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueDBY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params">                            <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者</strong></p><p>生产者通过接口形式发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/ttl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/sendMsg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String msg)</span> &#123;<br>      log.info(<span class="hljs-string">&quot;当前时间: &#123;&#125; , 发送一条消息给两个TTL队列: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), msg);<br><br>      rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XA&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为10s的队列: &quot;</span> + msg);<br>      rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XB&quot;</span>,<span class="hljs-string">&quot;消息来自ttl为40s的队列: &quot;</span> + msg);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><p>消费者以接口形式接收消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLetterQueueConsumer</span> &#123;<br><br>    <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message , Channel channel)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;, 接收死信队列消息：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>启动后发送Get请求</p><ul><li>消费者在规定的时间收到消息</li></ul><p><img src="https://s2.loli.net/2023/12/08/qXPVgOJzTYIWmv5.png" alt="ttl3"></p></li></ul><h3 id="3-TTL消息"><a href="#3-TTL消息" class="headerlink" title="3. TTL消息"></a>3. TTL消息</h3><blockquote><p>使用户发送自定义TTL属性的消息</p></blockquote><p><strong>增加队列 QC</strong></p><p><img src="https://s2.loli.net/2023/12/08/rStNVfyjuhmAPJF.png" alt="ttl4"></p><p><strong>在配置类中声明队列并绑定交换机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueC</span><span class="hljs-params">()</span>&#123;<br><br>    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 设置参数</span><br>    map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_EXCHANGE);<br>    map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="hljs-string">&quot;YD&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CBX</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueCBX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                        <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;XC&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * CBY</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueCBY</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                        <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(yExchange).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者，添加接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@GetMapping(&quot;/sendMsg/&#123;msg&#125;/&#123;ttl&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String msg , <span class="hljs-meta">@PathVariable(&quot;ttl&quot;)</span> String ttl)</span> &#123;<br>    <br>  log.info(<span class="hljs-string">&quot;当前时间: &#123;&#125; , 发送一条ttl: &#123;&#125; ms 消息给通用TTL队列: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),ttl, msg);<br>  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;XC&quot;</span>,<span class="hljs-string">&quot;消息来自通用ttl队列&quot;</span>,m -&gt; &#123;<br>      <span class="hljs-comment">// 设置消息属性</span><br>      m.getMessageProperties().setExpiration(ttl);<br>      <span class="hljs-keyword">return</span> m;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但此方法有很大的问题</strong></p><p><strong>这就是介绍过的，在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“</strong></p><p>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，<br>如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p><p><img src="https://s2.loli.net/2023/12/08/RjyvF8KIGw2qH7i.png" alt="ttl5"></p><h3 id="4-插件实现延迟队列"><a href="#4-插件实现延迟队列" class="headerlink" title="4. 插件实现延迟队列"></a>4. 插件实现延迟队列</h3><ul><li><a href="https://www.rabbitmq.com/community-plugins.html">官网下载 </a><strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#安装</span><br>rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_delayed_message_exchange<br><span class="hljs-comment">#重启服务</span><br>systemctl restart rabbitmq-server<br></code></pre></td></tr></table></figure><p>安装成功后在Web端可以看到，交换机多了一个属性</p><p><img src="https://s2.loli.net/2023/12/08/ofUgOPHN1xFhQw4.png" alt="cjttl"></p><ul><li>这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并<strong>不会立即投递</strong>到目标队列中，<br>而是存储在 mnesia(一个分布式数据系统)表中，<strong>当达到投递时间时，才投递到目标队列中</strong>。</li></ul><p><strong>创建一个示例</strong></p><p><img src="https://s2.loli.net/2023/12/08/81zoxfGEUhNPq3W.png" alt="dlq"></p><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><br>    <span class="hljs-comment">// 队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br>    <span class="hljs-comment">// 交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br>    <span class="hljs-comment">// routingKey</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingkey&quot;</span>;<br><br>    <span class="hljs-comment">// 声明交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span>&#123;<br><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, map);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(DELAYED_QUEUE_NAME);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayQueueBD</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue ,</span><br><span class="hljs-params">                                   <span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生产者新接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@GetMapping(&quot;/sendDelayMsg/&#123;msg&#125;/&#123;delay&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String msg , <span class="hljs-meta">@PathVariable(&quot;delay&quot;)</span> Integer delay)</span> &#123;<br>  <br>  log.info(<span class="hljs-string">&quot;当前时间: &#123;&#125; , 发送一条ttl: &#123;&#125; ms 消息给TTL队列: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),delay, msg);<br><br>  rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME,DELAYED_ROUTING_KEY,<span class="hljs-string">&quot;消息来自通用ttl队列&quot;</span>,m -&gt; &#123;<br>      <span class="hljs-comment">// 设置消息属性</span><br>      m.getMessageProperties().setDelay(delay);<br>      <span class="hljs-keyword">return</span> m;<br>  &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueConsumer</span> &#123;<br><br>    <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message , Channel channel)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;, 接收延迟队列消息：&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>启动测试</p><p><img src="https://s2.loli.net/2023/12/08/knYe76sEdhaVRBN.png" alt="dlq2"></p><ul><li>第二条消息先消费，延时成功</li></ul></li></ul><h2 id="九、发布确认高级"><a href="#九、发布确认高级" class="headerlink" title="九、发布确认高级"></a>九、发布确认高级</h2><blockquote><p>解决因某原因导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复的问题</p></blockquote><p><strong>方案结构图</strong></p><p><img src="https://s2.loli.net/2023/12/09/ihJgXGnQOUjlco8.png" alt="confirmSB"></p><p><img src="https://s2.loli.net/2023/12/09/yDZCUQ1XfHoWiVu.png" alt="confirmSB2"></p><h3 id="1-整合SpringBoot"><a href="#1-整合SpringBoot" class="headerlink" title="1. 整合SpringBoot"></a>1. 整合SpringBoot</h3><p><strong>添加配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-comment"># 开启发布确认</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br></code></pre></td></tr></table></figure><ul><li><p><code>NONE</code>： 禁用发布确认模式（默认）</p></li><li><p><code>CORRELATED</code> ：发布消息成功到交换器后会触发回调方法</p></li><li><p><code>SIMPLE</code> ：有两种效果</p><ol><li><p>和 <code>CORRELATED</code> 值一样会触发回调方法</p></li><li><p>在发布消息成功后使用 <code>rabbitTemplate</code> 调用 <code>waitForConfirms</code> 或 <code>waitForConfirmsOrDie</code> 方法<br>等待 <code>broker</code> 节点返回发送结果，根据返回结果来判定下一步的逻辑，<br><strong>注意</strong>： <code>waitForConfirmsOrDie</code> 方法如果返回 <code>false</code> 会关闭 <code>channel</code>，接下来无法发送消息到 <code>broker</code></p></li></ol></li></ul><p><strong>新增配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br><br>    <span class="hljs-comment">// 交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_exchange&quot;</span>;<br>    <span class="hljs-comment">// 队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_queue&quot;</span>;<br>    <span class="hljs-comment">// routingKey</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;key1&quot;</span>;<br><br>    <span class="hljs-comment">// 声明确认交换机</span><br>    <span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明确认队列</span><br>    <span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue ,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现生产者回调接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将此类注入到rabbitTemplate中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机确认回调方法</span><br><span class="hljs-comment">     * 1.接收成功，回调</span><br><span class="hljs-comment">     *  1.1 correlationDate 保存了回调消息的信息</span><br><span class="hljs-comment">     *  1.2 交换机接收到消息 ack = true</span><br><span class="hljs-comment">     *  1.3 cause Null</span><br><span class="hljs-comment">     * 2.接收失败，回调</span><br><span class="hljs-comment">     *  2.1 correlationDate 保存了回调消息的信息</span><br><span class="hljs-comment">     *  2.2 交换机接收到消息 ack = false</span><br><span class="hljs-comment">     *  2.3 cause 失败的原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData != <span class="hljs-literal">null</span> ? correlationData.getId() : <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (ack)&#123;<br>            log.info(<span class="hljs-string">&quot;交换机接收到Id为：&#123;&#125; 的消息&quot;</span>,id);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;交换机接收Id为：&#123;&#125; 的消息失败，失败原因：&#123;&#125;&quot;</span>,id,cause);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@PostConstruct</code>：注解的含义与用法</p><ul><li>注解允许在 bean 的构造函数之后和 bean 的属性设置之后执行初始化逻辑。   </li><li>注解可以应用于任何类型的 bean，包括普通 bean、单例 bean 和原型 bean。</li><li>注解不能应用于接口、枚举类型或静态方法。   </li><li>注解的方法必须是 public 方法，并且不能有任何参数。</li><li>注解的方法可以抛出任何异常。</li></ul><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/confirm&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/sendMsg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String message)</span> &#123;<br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,CONFIRM_ROUTING_KEY,message,correlationData);<br>        log.info(<span class="hljs-string">&quot;发送消息: &#123;&#125;&quot;</span>,message);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConsumer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfirmMsg</span><span class="hljs-params">(Message message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;接收到队列confirm.queue的消息：&#123;&#125;&quot;</span>,message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><ul><li>正常情况下消息成功接收</li></ul><p><img src="https://s2.loli.net/2023/12/09/YTDgXoOn8Vhy4ZE.png" alt="confirmMsg"></p><ul><li>修改Key的值，则消息无法匹配到队列，会被直接丢弃</li></ul><p><img src="https://s2.loli.net/2023/12/09/mAyGaoPu2ZEr5Sj.png" alt="confirmMsg2"></p><p><strong>注意</strong>：此时丢弃的消息交换机不知道，需要告诉生产者消息接收失败</p><h3 id="2-回退消息"><a href="#2-回退消息" class="headerlink" title="2. 回退消息"></a>2. 回退消息</h3><blockquote><p>设置回退消息，可以在当消息传递过程中不可达目的地时将消息返回给生产者</p></blockquote><p><strong>增加配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-comment"># 开启回退消息</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><p><strong>在回调方法中实现回退接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将此类注入到rabbitTemplate中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>        rabbitTemplate.setReturnCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机确认回调方法</span><br><span class="hljs-comment">     * 1.接收成功，回调</span><br><span class="hljs-comment">     *  1.1 correlationDate 保存了回调消息的信息</span><br><span class="hljs-comment">     *  1.2 交换机接收到消息 ack = true</span><br><span class="hljs-comment">     *  1.3 cause Null</span><br><span class="hljs-comment">     * 2.接收失败，回调</span><br><span class="hljs-comment">     *  2.1 correlationDate 保存了回调消息的信息</span><br><span class="hljs-comment">     *  2.2 交换机接收到消息 ack = false</span><br><span class="hljs-comment">     *  2.3 cause 失败的原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> correlationData != <span class="hljs-literal">null</span> ? correlationData.getId() : <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (ack)&#123;<br>            log.info(<span class="hljs-string">&quot;交换机接收到Id为：&#123;&#125; 的消息&quot;</span>,id);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;交换机接收Id为：&#123;&#125; 的消息失败，失败原因：&#123;&#125;&quot;</span>,id,cause);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回消息回调</span><br><span class="hljs-comment">     * 只有在消息不可达目的地时 才可进行回退</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message    the 返回的消息。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> replyCode  the 回复代码。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> replyText  the 回复文本。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange   the 交换机</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> routingKey the routing key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, </span><br><span class="hljs-params">                                String replyText, String exchange, String routingKey)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消息：&#123;&#125; 被交换机：&#123;&#125; 退回, 原因：&#123;&#125;，路由键：&#123;&#125;&quot;</span>,<br>                 message.getBody(),replyText,exchange,routingKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><p><img src="https://s2.loli.net/2023/12/09/AhODwc2vXM8BFng.png" alt="confirmMsg3"></p><p>可以看到消息被退回</p><h3 id="3-备份交换机"><a href="#3-备份交换机" class="headerlink" title="3. 备份交换机"></a>3. 备份交换机</h3><blockquote><p>当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理</p></blockquote><p>通常备份交换机的类型为 <code>Fanout</code> ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，<br>所有无法被路由的消息，都进入这个队列，还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><p><strong>简单结构</strong></p><p><img src="https://s2.loli.net/2023/12/09/njlwGQtFiXOIWuH.png" alt="backup"></p><p><strong>修改配置类</strong></p><blockquote><p>注意：修改已存在交换机配置需要将已存在的交换机删除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfirmConfig</span> &#123;<br><br>    <span class="hljs-comment">// 交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_exchange&quot;</span>;<br>    <span class="hljs-comment">// 队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;confirm_queue&quot;</span>;<br>    <span class="hljs-comment">// routingKey</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONFIRM_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;key1&quot;</span>;<br><br>    <span class="hljs-comment">// 备份交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup_exchange&quot;</span>;<br>    <span class="hljs-comment">// 备份队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKUP_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;backup_queue&quot;</span>;<br>    <span class="hljs-comment">// 报警队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WARNING_QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning_queue&quot;</span>;<br><br>    <span class="hljs-comment">// 声明确认交换机</span><br>    <span class="hljs-meta">@Bean(&quot;confirmExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">confirmExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)<br>                .durable(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">// 设置备份交换机</span><br>                .withArgument(<span class="hljs-string">&quot;alternate-exchange&quot;</span>,BACKUP_EXCHANGE_NAME).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明确认队列</span><br>    <span class="hljs-meta">@Bean(&quot;confirmQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">confirmQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue ,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明备份交换机</span><br>    <span class="hljs-meta">@Bean(&quot;backupExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">backupExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明备份队列</span><br>    <span class="hljs-meta">@Bean(&quot;backupQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">backupQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 声明警告队列</span><br>    <span class="hljs-meta">@Bean(&quot;warningQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">warningQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">BBB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue ,</span><br><span class="hljs-params">                       <span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">WBB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue ,</span><br><span class="hljs-params">                       <span class="hljs-meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>报警消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarningConsumer</span> &#123;<br><br>    <span class="hljs-comment">// 接收报警信息</span><br>    <span class="hljs-meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;[WARNING] Unreceived &#x27;&#123;&#125;&#x27;&quot;</span>, message.getBytes(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><p><img src="https://s2.loli.net/2023/12/09/msbpa5Z2CgGQhYS.png" alt="warm"></p><p>消息成功被报警消费者接收</p><p><strong>注意：此处消息没有触发回退</strong></p><ul><li>因为当回退，和备份同时设置时，备份的优先级更高</li></ul><h2 id="十、其他性质"><a href="#十、其他性质" class="headerlink" title="十、其他性质"></a>十、其他性质</h2><h3 id="1-幂等性"><a href="#1-幂等性" class="headerlink" title="1. 幂等性"></a>1. 幂等性</h3><blockquote><p>对于同一操作发起的一次请求或者多次请求的结果是一致的</p></blockquote><p> <strong>例如支付操作：</strong></p><ul><li>用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常</li><li>用户再次点击按钮，此时会进行第二次扣款。</li></ul><p><strong>消息重复消费</strong></p><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><p><strong>解决思路</strong></p><p>MQ 消费者的幂等性的解决一般使用<strong>全局 ID</strong> ，<strong>每次消费消息时用该 id 先判断该消息是否已消费过。</strong></p><p>主流的幂等性有两种操作:</p><ul><li><p>唯一 ID+指纹码机制,利用数据库主键去重</p><p>指纹码：<strong>唯一信息码</strong>,一般都是由我们的业务规则拼接而来，然后利用查询语句进行判断这个 id 是否存在数据库中<br>优势： 实现简单就一个拼接，然后查询判断是否重复；<br>劣势： 在高并发时，增大数据库的压力</p></li><li><p>利用 redis 的原子性去实现</p><p>利用 redis 执行 setnx 命令，天然具有幂等性</p></li></ul><h3 id="2-优先级队列"><a href="#2-优先级队列" class="headerlink" title="2. 优先级队列"></a>2. 优先级队列</h3><blockquote><p>优先处理某些订单</p></blockquote><ul><li><strong>Web控制台添加属性</strong></li></ul><p><img src="https://s2.loli.net/2023/12/09/2tMuDId8KiyTwnx.png" alt="youxain"></p><ul><li><strong>声明队列时添加优先级</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>params.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br></code></pre></td></tr></table></figure><ul><li><strong>发送消息添加优先级</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().priority(<span class="hljs-number">10</span>).build();<br></code></pre></td></tr></table></figure><p><strong>前提条件：</strong></p><ul><li>队列需要设置为优先级队列</li><li>消息需要设置消息的优先级</li><li>消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</li></ul><h3 id="3-惰性队列"><a href="#3-惰性队列" class="headerlink" title="3. 惰性队列"></a>3. 惰性队列</h3><blockquote><p>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中去</p></blockquote><ul><li><strong>背景原因</strong></li></ul><p>它的一个重要的设计目标是能够支持更长的队列，即<strong>支持更多的消息存储</strong>。<br>当消费者由于各种各样的原因而致使长时间内不能消费消息<strong>造成堆积时</strong>，惰性队列就很有必要了</p><p>默认情况下，当生产者发送消息时，队列中的消息存储在内存之中，可以更快的将消息发送给消费者。<br>即使是持久化的消息，被写入磁盘的时也会在内存中留一份备份。<br>当RabbitMQ <strong>需要释放内存时</strong>，会将内存中的消息换页至磁盘中，操作时间较长<strong>会阻塞队列的操作</strong>，导致无法接收新的消息</p><p><strong>队列的两种模式</strong>：<code>default 和 lazy。</code></p><ul><li><p>默认的为<code>default</code> 模式</p></li><li><p><code>lazy</code> 模式即为惰性队列的模式，可以通过调用 <code>channel.queueDeclare</code> 方法的时候在参数中设置，或通过 <code>Policy</code> 的方式设置，<br>如果队列同时使用这两种方式设置，<code>Policy</code> 方式优先级更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>args.put(<span class="hljs-string">&quot;x-queue-mode&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;myqueue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure></li><li><p><strong>占用内存比较</strong></p></li></ul><p><img src="https://s2.loli.net/2023/12/09/O1MVzaZX9Np2HRt.png" alt="lazy"></p><p><strong>在发送 1 百万条消息时，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/12/11/Linux/"/>
    <url>/2023/12/11/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-CentOS"><a href="#Linux-CentOS" class="headerlink" title="Linux-CentOS"></a><u>Linux-CentOS</u></h1><hr><h2 id="一、初识"><a href="#一、初识" class="headerlink" title="一、初识"></a>一、初识</h2><h3 id="1-网络连接的三种模式"><a href="#1-网络连接的三种模式" class="headerlink" title="1.网络连接的三种模式"></a>1.网络连接的三种模式</h3><ol><li><p>桥接模式</p><blockquote><p>虚拟机能和外部网络通信，但是容易造成IP冲突</p><p>因为：桥接模式下，虚拟机生成与主机网络在同一网段下的IP</p></blockquote></li><li><p>NAT模式</p><blockquote><p>网络地址转换模式</p><p>虚拟机能与外部通信</p><p>不会引起IP冲突</p></blockquote><img src="https://s2.loli.net/2023/11/02/3Y7CTpAkERxL1rQ.png" alt="nat" style="zoom: 50%;" /></li><li><p>主机模式</p><blockquote><p>独立的系统</p></blockquote><img src="https://s2.loli.net/2023/11/02/bIl3vr6u7ZXRKse.png" alt="netImg" style="zoom:50%;" /></li></ol><h3 id="2-Linux的目录结构"><a href="#2-Linux的目录结构" class="headerlink" title="2. Linux的目录结构"></a>2. Linux的目录结构</h3><p>Linux目录由  <strong><code>/</code></strong>  开始，向下发展分支</p><p><img src="https://s2.loli.net/2023/11/02/iqMjACp1kFRohEZ.png" alt="linuxMenu"></p><ul><li><strong>&#x2F;bin</strong> 【常用】：（&#x2F;usr&#x2F;bin , &#x2F;user&#x2F;local&#x2F;bin）, 是<strong>Binary</strong>的缩写，用来存放最经常使用的命令</li><li><strong>&#x2F;sbin</strong> ：（&#x2F;usr&#x2F;sbin , &#x2F;usr&#x2F;local&#x2F;sbin）, s 就是 Super User 存放系统管理员使用的系统管理程序</li><li><strong>&#x2F;home</strong> 【常用】: 存放普通用户的主目录，在Linux 中每个用户都有自己的目录</li><li><strong>&#x2F;root</strong> 【常用】：系统管理员的主目录</li><li><strong>&#x2F;lib</strong> :系统所需的最基本的动态连接共享库 ， 其作用类似于Window 里的DLL文件，几乎所有的应用程序都需要使用到</li><li><strong>&#x2F;lost + found</strong> : 这个目录一般是空的，当系统非法关机后，就存放了一些文件</li><li><strong>&#x2F;etc</strong> 【常用】：所有系统管理所需要的配置文件和子目录</li><li><strong>&#x2F;usr</strong> 【常用】：非常重要的目录，用户的很多应用程序和文件都放在此处，类似于win中的program files</li><li><strong>&#x2F;boot</strong> 【常用】：存放启动Linux时使用的核心文件，包括连接和镜像文件</li><li><strong>&#x2F;proc</strong> 【不能动】：是一个虚拟目录。他是系统内存的映射，访问这个目录来获取系统信息</li><li><strong>&#x2F;srv</strong> 【不能动】：service 的缩写，该目录存放一些服务启动之后需要提取的数据</li><li><strong>&#x2F;sys</strong> 【不能动】: 这是Linux 2.6内核的一个很大变化，安装了2.6内核中新出现的一个文件系统sysfs</li><li><strong>&#x2F;tmp</strong> : 存放临时文件</li><li><strong>&#x2F;dev</strong> : 类似于win中的设备管理器，把所有的硬件用文件的形式存储</li><li><strong>&#x2F;media</strong> 【常用】：Linux 系统会自动识别一些设备，例如U盘，识别后会把设备挂载到这个目录下</li><li><strong>&#x2F;mnt</strong> 【常用】：该目录让用户临时挂载别的文件系统，可以将外部存储挂载在&#x2F;mnt&#x2F;上，进入目录就能查看内容，例如共享文件夹</li><li><strong>&#x2F;opt</strong> ：给主机额外安装软件的目录</li><li><strong>&#x2F;usr&#x2F;local</strong> 【常用】：这是另一个给主机安装软件的目录，一般是通过编译源码的方式安装的程序</li><li><strong>&#x2F;var</strong> 【常用】：这个目录存放着在不断扩充的东西 ， 习惯将经常被修改的目录放在这个目录下，包括日志文件</li><li><strong>&#x2F;selinux [security-enhanced linux]</strong> : SE-Linux 是一种安全子系统，能控制程序只能访问特定文件，有三种工作模式可以自行设置</li></ul><h3 id="3-vi与vim"><a href="#3-vi与vim" class="headerlink" title="3. vi与vim"></a>3. vi与vim</h3><p><strong>三种模式</strong>：</p><ul><li><p>正常模式</p><blockquote><p>刚进入vi &#x2F; vim 的状态</p><p>在任何模式下输入esc 将进入正常模式</p></blockquote></li><li><p>插入模式</p><blockquote><p>在正常模式下输入  ，i , o , a , r进入</p></blockquote></li><li><p>命令行模式</p><blockquote><p>正常模式下输入 &#x2F; 或者 :</p></blockquote></li></ul><p><u>常用快捷键</u></p><ol><li><strong><code>yy</code></strong> : 复制当前行，例如 5yy 复制光标以下5行，配合粘贴 <strong><code>p</code></strong> 使用</li><li><strong><code>dd</code></strong> ：删除当前行，5dd 删除光标以下5行</li><li><strong><code>/内容</code></strong> ：查找文件中的对应内容，输入<strong>n</strong> 就是查找下一个</li><li><strong><code>:set nu 与 :set nonu</code></strong> : 显示文件的行号，取消显示</li><li>**<code>G 与 gg</code>**：移动光标到文件末尾，首行</li><li>**<code>u</code>**：撤销上一个操作，类似于win中的CTRL+ Z</li><li><strong><code>行号 + shift + g</code></strong> : 将光标跳转到该行</li></ol><img src="https://s2.loli.net/2023/11/02/oZpHywznP3WeV8E.png" alt="vi&vim" style="zoom: 67%;" /><h3 id="4-关机-重启-运行"><a href="#4-关机-重启-运行" class="headerlink" title="4. 关机 &amp; 重启 &amp; 运行"></a>4. 关机 &amp; 重启 &amp; 运行</h3><p>基本命令：</p><ul><li><code>shutdown -h  now</code>  立刻关机</li><li><code>shutdown -h 1</code>         会给当前访问虚拟机的所有用户发送这一条消息通知一分钟后将关机</li><li><code>shutdown -r now</code>     立即重启</li><li><code>halt </code>                           关机，作用同上</li><li><code>reboot</code>                        立即重启</li><li><code>sync</code>                            把内存的数据同步到磁盘</li></ul><p><strong>注：无论重启或关闭系统，首先要运行sync命令防止数据丢失</strong></p><p><strong>注：目前的shutdown&#x2F;reboot&#x2F;halt 等命令在关机前进行了 sync ，但最好每次都先执行 sync</strong></p><p><strong>运行级别</strong></p><ol><li><p>运行级别种类</p><ul><li>0：关机</li><li>1：单用户【找回密码】</li><li>2：多用户没有网络服务</li><li>3：多用户有网络服务</li><li>4：系统未使用保留给用户</li><li>5：图形界面</li><li>6：系统重启</li></ul><p>可以使用 <code>init[num]</code> 来切换运行级别。</p></li><li><p>设置默认运行级别</p><ul><li><code>systemctl get-default</code>：查看当前默认运行级别</li><li><code>systemctl set-default TARGET.target</code>：设置默认运行级别<ul><li>multi-user.target : 3</li><li>graphical.target ：5</li></ul></li></ul></li></ol><h3 id="5-用户登录与注销"><a href="#5-用户登录与注销" class="headerlink" title="5. 用户登录与注销"></a>5. 用户登录与注销</h3><p><strong>注意事项</strong>：</p><ul><li>登录时尽量少用root账号避免操作失误</li><li>用 <code>su - 用户名</code> 切换账户</li><li>用<code>logout</code>来注销用户</li></ul><h3 id="6-帮助指令"><a href="#6-帮助指令" class="headerlink" title="6. 帮助指令"></a>6. 帮助指令</h3><ul><li><code>main [命令或配置文件]</code>：获取帮助信息，例如：main ls , 查看ls的帮助信息</li><li><code>help [命令]</code>：获取shell内置命令的帮助信息</li></ul><h2 id="二、用户管理"><a href="#二、用户管理" class="headerlink" title="二、用户管理"></a>二、用户管理</h2><h3 id="1-账号增删"><a href="#1-账号增删" class="headerlink" title="1. 账号增删"></a>1. 账号增删</h3><p><strong>添加账户</strong></p><ul><li><code>useradd 用户名</code></li><li><code>useradd -d 指定目录 用户名</code> ： 给新用户指定home目录</li><li><code>passwd 用户名</code>：设置&#x2F;修改 密码</li><li><code>whoami</code>：查看当前用户</li></ul><p><strong>删除用户</strong></p><ul><li><code>userdel 用户名</code> ： 删除用户，保留home目录（建议使用）</li><li><code>userdel -r 用户名</code> ： 删除用户及home目录</li></ul><h3 id="2-用户组"><a href="#2-用户组" class="headerlink" title="2. 用户组"></a>2. 用户组</h3><p><strong>对类似的有共性的多个用户进行同一管理</strong></p><p><u>当用户没有指定的组时，该用户的用户组就是他自己</u></p><ul><li><code>groupadd 组名</code> ：新增组</li><li><code>groupdel 组名</code> ：删除组</li><li><code>useradd -g 用户组 用户名</code>：增加用户时直接加上组</li><li><code>usermod -g 用户组 用户名</code>：修改用户组</li></ul><p><strong>用户组相关文件</strong></p><ul><li><p><code>/etc/passwd</code> ：用户（user）的配置文件，记录各种信息</p><blockquote><p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/8UCfhAmlOJZDo95.png" alt="etcPassword"></p></li><li><p><code>/etc/shadow</code>：口令配置文件</p><blockquote><p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/dxqMtOUyTCKcAsJ.png" alt="etcShadow"></p></li><li><p><code>/etc/group</code>：组的配置文件，记录Linux包含的组的信息</p><blockquote><p>每行的含义：组名：口令：组标识号：组内用户列表</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/xy4Yc1sI98P5WuE.png" alt="etcGroup"></p></li></ul><h3 id="3-找回root密码"><a href="#3-找回root密码" class="headerlink" title="3. 找回root密码"></a>3. 找回root密码</h3><ol><li>启动系统，进入开机界面，按方向键移动高亮条，选中第一个，按 <code>e</code> 进入编辑界面</li></ol><img src="https://s2.loli.net/2023/11/02/RpsGcrwv5t8fIai.png" alt="backpd" style="zoom:50%;" /><ol start="2"><li>将光标移动至 <code>linux16</code>开头的行的结尾，输入 <code>init=/bin/sh</code> 后按 <code>ctrl + x</code> 启动虚拟机，进入单用户模式（1）</li></ol><img src="https://s2.loli.net/2023/11/02/RUim3q8p5OIyb6L.png" alt="back2" style="zoom: 67%;" /><ol start="3"><li><p>在光标处输入：<code>mount -o remount,rw /</code> 后按回车键<code>Enter</code></p></li><li><p>在新的一行输入passwd，回车后输入新密码，再次输入密码确认，密码修改成功！</p></li></ol><p><img src="https://s2.loli.net/2023/11/02/stuNXZmP296Kozb.png" alt="back3"></p><ol start="5"><li>继续输入 <code>touch /.autorelabel</code> 回车后 继续输入 <code>exec /sbin/init</code> 回车后稍等片刻，系统将会自动重启，密码修改生效！</li></ol><p><img src="https://s2.loli.net/2023/11/02/dJhfaWNyVe8qprA.png" alt="back4"></p><h2 id="三、常用指令"><a href="#三、常用指令" class="headerlink" title="三、常用指令"></a>三、常用指令</h2><h3 id="1-文件目录"><a href="#1-文件目录" class="headerlink" title="1. 文件目录"></a>1. 文件目录</h3><ul><li><p><code>pwd</code>：显示前工作目录的绝对路径</p></li><li><p><code>ls[选项][目录或文件]</code> ：选项可以组合使用，例如: -la 顺序不影响。</p><ul><li><code>-a</code>：显示目录所有的文件和目录，包括隐藏的</li><li><code>-l</code>：已列表形式显示信息</li></ul></li><li><p><code>cd [参数]</code>：切换到指定目录，注意参数是 绝对路径 或 相对路径</p><ul><li><code>~ 或 无参</code>：回到自己的家目录</li><li><code>..</code>：回到该目录的上一级目录</li></ul><p><strong>例如：</strong></p><blockquote><p>当前目录为：&#x2F;home&#x2F;user1</p><p>使用相对路径切换到 &#x2F;root 目录</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ../../root<br></code></pre></td></tr></table></figure><ul><li><p><code>mkdir [选项] 要创建的目录</code>：创建目录</p><ul><li><code>-p</code>：创建多级目录</li></ul></li><li><p><code>rmdir [选项] 要删除的空目录</code>：删除空目录</p></li><li><p><code>rm [选项] 要删除的文件或目录</code>：移除文件或目录</p><ul><li><code>-r</code>：递归删除整个文件夹</li><li><code>-f</code>：强制删除不提示</li></ul></li><li><p><code>touch 文件名</code>：创建空文件</p></li><li><p><code>cp [选项] 指定文件 指定目录</code>：将文件复制到指定目录</p><ul><li><code>-r</code>：递归复制整个文件夹</li><li><code>\cp</code>：如指定文件夹有同名文件，此命令则强制覆盖不提示</li></ul></li><li><p><code>mv</code>：移动文件与目录 或 重命名</p><ul><li><code>mv 原文件名 新文件名</code>：重命名文件</li><li><code>mv 原文件路径 指定路径</code>：移动文件</li></ul></li><li><p><code>cat [选项] 文件</code>：查看文件内容</p><ul><li><code>-n</code>：显示行号</li></ul><blockquote><p>cat 可与  <code>|</code> 管道命令组合使用 </p><p>以下表示将管道符前的命令结果交给管道符后的命令处理</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/profile | more<br></code></pre></td></tr></table></figure><p><code>more</code>指令的交互操作：</p><img src="https://s2.loli.net/2023/11/02/Hi74C6NfD8KsjqG.png" alt="管道符" style="zoom:67%;" /></li><li><p><code>less 文件</code>：查看文件内容，但并不是一次性将文件加载后显示，而是根据需要加载的内容</p><img src="https://s2.loli.net/2023/11/02/k2E39XhbPLf5pvJ.png" alt="less" style="zoom:67%;" /></li><li><p><code>echo [选项] [输出内容]</code>：将内容输出到控制台</p></li><li><p><code>head [选项] 文件</code>：显示文件的开头部分内容，默认显示前十行</p><ul><li><code>-n 数字</code>：查看文件前n行</li></ul></li><li><p><code>tail [选项] 文件</code>：显示文件的结尾内容，默认显示后十行</p><ul><li><code>-n 数字</code>：查看文件的后n行</li><li><code>-f</code> ：实时追踪文件的所有更新</li></ul></li><li><p><code>&gt; 与 &gt;&gt;</code>：</p><ul><li><code>内容 &gt; 文件</code>：输出重定向，将内容覆盖写入文件中</li><li><code>内容 &gt;&gt; 文件</code>：追加，将内容追加写入文件末尾</li></ul></li><li><p><code>ln -s 原文件或目录 软连接名</code>：给文件创建一个软连接（类似于win的快捷方式）</p><ul><li>删除软连接则当成文件删除</li></ul></li><li><p><code>history [数字]</code>：查看执行过的指令，输入数字n，则显示最近n条</p><ul><li><code>!n</code>：执行历史中编号为 n 的指令</li></ul></li></ul><h3 id="2-时间日期"><a href="#2-时间日期" class="headerlink" title="2. 时间日期"></a>2. 时间日期</h3><ul><li><code>date [选项]</code>：显示当前日期<ul><li><code>-s &quot;yyyy-MM-dd HH:mm:ss&quot; </code>：设置系统当前时间</li><li><code>+%Y</code>：显示年份</li><li><code>+%m</code>：显示月份</li><li><code>+%d</code>：显示当前一天</li><li><code>&quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月十分秒</li></ul></li><li><code>cal [年份]</code>：显示日历，默认显示当前月份<ul><li><code>cal 2023</code>：显示2023年所有月份的日历</li></ul></li></ul><h3 id="3-搜索查找类"><a href="#3-搜索查找类" class="headerlink" title="3. 搜索查找类"></a>3. 搜索查找类</h3><ul><li><p><code>find [搜索范围] [选项]</code>：该指令将从指定目录向下递归的遍历其各个子目录，将满足条件的文件或目录显示在终端</p><ul><li><p><code>-name</code>：按照指定文件名查找文件</p></li><li><p><code>-user</code>：查找属于指定用户名所有文件</p></li><li><p><code>-size</code>：按照指定文件大小查找文件</p><ul><li><code>+n</code>：大于</li><li><code>-n</code>：小于</li><li><code>n</code>：等于</li></ul><p><strong>例如</strong>：  查找整个系统下大于20k 的文件 单位：k ， M ， G</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">find / -size +<span class="hljs-number">20</span>k <br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>locate 文件</code>：可以快速定位指定文件路径</p><blockquote><p>该指令利用事先建立的系统中所有文件名及路径的locate数据库快速定位文件，无需遍历整个系统速度快</p><p>为了保证定位的准确度，管理员必须定期更新locate时刻</p></blockquote><ul><li><code>updatedb</code>：更新locate数据库，在第一次locate前需要使用updatedb构建locate数据库</li></ul></li><li><p><code>grep [选项] 查找内容 源文件</code>：过滤查找相关内容</p><ul><li><code>-n</code>：显示匹配行及行号</li><li><code>-i</code>：忽略字母大小写</li></ul><p><strong>例如</strong>：在hello.txt中查找”yes“所在行，并显示行号</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -n <span class="hljs-string">&quot;yes&quot;</span> <span class="hljs-regexp">/home/</span>hello.txt<br></code></pre></td></tr></table></figure><p>还能与 <code>|</code> 管道符配合使用，效果同上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /home/hello.txt | grep -n <span class="hljs-string">&quot;yes&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-压缩与解压"><a href="#4-压缩与解压" class="headerlink" title="4. 压缩与解压"></a>4. 压缩与解压</h3><ul><li><p><code>gzip </code> 文件：压缩文件，将文件压缩为*.gz</p></li><li><p><code>gunzip 文件.gz</code>：解压缩文件</p></li><li><p><code>zip [选项] XXX.zip 文件或目录</code>：压缩文件或目录</p><ul><li><code>-r</code>：递归压缩，即压缩目录</li></ul><p><strong>例如</strong>：将home目录压缩为名为myHome.zip的压缩文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span> -r myHome.<span class="hljs-built_in">zip</span> /home/ <br></code></pre></td></tr></table></figure></li><li><p><code>unzip [选项] 要解压的文件</code>：解压缩文件</p><ul><li><code>-d &lt;目录&gt;</code>：将文件解压到指定目录</li></ul><p><strong>例如</strong>：将&#x2F;home下的myHome.zip文件解压到 &#x2F;opt&#x2F;tmp目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">unzip -d <span class="hljs-regexp">/opt/</span>tmp <span class="hljs-regexp">/home/my</span>Home.zip<br></code></pre></td></tr></table></figure></li><li><p><code>tar [选项] XXX.tar.gz 打包的内容</code>：打包目录压缩后格式为tar.gz</p><ul><li><code>-c</code>：产生tar打包文件</li><li><code>-v</code>：显示详细信息</li><li><code>-f</code>：指定压缩后的文件名</li><li><code>-z</code>：同时压缩文件</li><li><code>-x</code>：解包.tar文件</li></ul><p><strong>例如</strong>：</p><ol><li>将多个文件打包压缩成pc.tar.gz</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -zcvf pc<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> /home/pig<span class="hljs-selector-class">.txt</span> /home/tiger.txt<br></code></pre></td></tr></table></figure><ol start="2"><li>将&#x2F;home文件夹压缩成myHome.tar.gz</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -zcvf myHome<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> /home/<br></code></pre></td></tr></table></figure><ol start="3"><li>将myHome.tar.gz  &#x3D;&#x3D;解压到&#x3D;&#x3D;  &#x2F;opt&#x2F;tmp 目录下</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tar -zxvf <span class="hljs-regexp">/home/my</span>Home.tar.gz -C <span class="hljs-regexp">/opt/</span>tmp<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、组管理与权限管理"><a href="#四、组管理与权限管理" class="headerlink" title="四、组管理与权限管理"></a>四、组管理与权限管理</h2><h3 id="1-Linux组"><a href="#1-Linux组" class="headerlink" title="1. Linux组"></a>1. Linux组</h3><p>Linux中每个用户必须属于一个组，在Linux文件中，有所有者，所在组，其他组的概念</p><ul><li><p>所有者：默认为文件的创建者</p><ul><li><code>chown 用户名 文件名</code>：改变文件的所有者</li></ul></li><li><p>所在组：默认为所有者的所在组</p><ul><li><code>chgrp 组名 文件名</code>：修改文件、目录所在组</li></ul><p>同时改变所有者和所属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> user1:group1 abc.txt<br></code></pre></td></tr></table></figure><p>改变目录下所以子目录或文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R user1 abc.txt<br><span class="hljs-built_in">chgrp</span> -R group1 abc.txt<br><span class="hljs-built_in">chown</span> -R user1:group1 abc.txt<br></code></pre></td></tr></table></figure></li><li><p>其他组：所有者所在组之外的组</p><ul><li><p><code>usermod -g 新组名 用户名</code>：改变用户所在组</p></li><li><p><code>usermod -d 目录名 用户名</code>：改变用户登录的初始目录</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：用户需要有进入该目录的权限</p></li></ul></li></ul><h3 id="2-权限"><a href="#2-权限" class="headerlink" title="2. 权限"></a>2. 权限</h3><p><strong>权限的基本介绍</strong></p><p><img src="https://s2.loli.net/2023/11/02/AVhEGrkj9DzQwiB.png" alt="qx"></p><ol><li>图中第一段  **<code>drwxr-xr-x</code>**，由十位字符组成<ol><li>第 <strong>0</strong> 位为文件类型<ul><li><code>-</code>：表示普通文件</li><li><code>d</code>：表示目录</li><li><code>c</code>：表示字符设备文件，例如，鼠标，键盘</li><li><code>b</code>：表示块设备，例如，硬盘</li></ul></li><li>第 <strong>1-3</strong> 位确定所有者对文件拥有的权限</li><li>第 <strong>4-6</strong> 位确定所属组对文件拥有的权限</li><li>第 <strong>7-9</strong> 位确定其他用户对文件拥有的权限</li></ol></li></ol><table><thead><tr><th>权限</th><th>作用到文件</th><th>作用到目录</th></tr></thead><tbody><tr><td>r (read) 4</td><td>读取，查看</td><td>读取，ls查看内容</td></tr><tr><td>w (write) 2</td><td>修改，不能删除<a href="%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E6%98%AF%EF%BC%8C%E5%AF%B9%E8%AF%A5%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95%E6%9C%89%E5%86%99%E6%9D%83%E9%99%90%EF%BC%8C%E6%89%8D%E8%83%BD%E5%88%A0%E9%99%A4%E8%AF%A5%E6%96%87%E4%BB%B6">^注</a></td><td>修改，对目录内创建，删除，重命名目录</td></tr><tr><td>x (execute) 1</td><td>可以被执行</td><td>可以进入该目录</td></tr></tbody></table><ol start="2"><li>图中第二段  <strong><code>2</code></strong> ，表示，文件：硬连接数 ， 目录：子目录数</li><li>图中第三，四段 **<code>root root</code>**，表示所有者和所属组</li><li>图中第五段 <code>4096</code> 表示文件大小（字节），如果是文件夹则显示4096</li><li>图中第六段 **<code>11月 3 22：09</code>**表示最后修改时间</li><li>图中第七段 <strong><code>home</code></strong> 表示文件名</li></ol><p><strong>修改权限</strong></p><ul><li><p><code>chmod &lt;操作语句&gt; 被修改的文件</code>：修改文件或目录的权限</p><ol><li><p><code>+ , - , =</code> 变更权限</p><ul><li><code>+</code>：增加权限</li><li><code>-</code>：取消权限</li><li><code>=</code>：赋予权限</li></ul></li><li><p><code>u , g , o , a</code> 表示角色</p><ul><li><code>u</code>：所有者</li><li><code>g</code>：所属组</li><li><code>o</code>：其他人</li><li><code>a</code>：所有人</li></ul></li></ol><p><strong>例如</strong>：对于&#x2F;home&#x2F;abc文件</p><ol><li>给所有者读写执行，给所属组读执行，给其他人读执行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=rx /home/abc.txt<br></code></pre></td></tr></table></figure><ol start="2"><li>给所有者取消执行，给所属组增加写</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u-x,g+w /home/abc.txt<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>可以使用数字代替字母</p><ul><li><code>r=4 w=2 x=1</code> 所以 <code>rwx = 7</code></li></ul><p><strong>例如</strong>：将文件abc的权限修改为 <code>rwxr-xr-x</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 755 /home/abc.txt<br></code></pre></td></tr></table></figure></li></ol><h2 id="五、任务调度"><a href="#五、任务调度" class="headerlink" title="五、任务调度"></a>五、任务调度</h2><h3 id="1-crond任务调度"><a href="#1-crond任务调度" class="headerlink" title="1. crond任务调度"></a>1. <strong>crond</strong>任务调度</h3><p>是指系统在某个时间执行的特定的命令或程序</p><p>分为：</p><ol><li>系统工作：有些重要的工作必须周而复始的执行，如病毒扫描秒</li><li>个别用户工作：个别用户可能希望执行某些程序，如mysql数据库备份</li></ol><ul><li><p><code>crontab [选项]</code>：进行定时任务的设置</p><ul><li><code>-e</code>：编辑crontab定时任务</li><li><code>-l</code>：查询crontab任务</li><li><code>-r</code>：删除当前用户的所以crontab任务</li></ul><p><strong>例如</strong>：设置个人任务调度</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 指令编辑定时任务，将打开/etc/crontab文件</span><br>crontab -e<br><span class="hljs-comment"># 编写定时任务</span><br>*<span class="hljs-string">/1</span> * * * * <span class="hljs-keyword">ls</span> -l <span class="hljs-string">/etc/</span> &gt; <span class="hljs-string">/tmp/to.txt</span><br></code></pre></td></tr></table></figure></li><li><p><code>*/1 * * * *</code></p><p><img src="https://s2.loli.net/2023/11/02/FPcw8JoN9RDuHge.png" alt="crontab"></p><ul><li><p><code>*</code>：表示时间</p></li><li><p><code>*/n</code>：表示，每隔n个时间单位为周期</p><ul><li><code>*/1 * * * *</code>：表示每分钟都执行</li></ul></li><li><p><code>,</code>：表示不连续的时间</p><ul><li><code>0 8,12,16 * * *</code>：表示每天的8，12，16点都执行命令</li></ul></li><li><p><code>-</code>：表示连续时间范围</p><ul><li><code>0 5 * * 1-6</code>：表示周一到周六的凌晨5点执行</li></ul></li></ul></li><li><p>常见用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 每隔一分钟将时间数据追加到/home/mydate.txt文件中</span><br>*/1 * * * * <span class="hljs-built_in">date</span> &gt;&gt; /home/mydate.txt<br><br><span class="hljs-comment">#每天2点将时间数据覆盖到/home/mydate.txt文件中</span><br>* 2 * * * <span class="hljs-built_in">date</span> &gt; /home/mydate.txt<br></code></pre></td></tr></table></figure><ul><li>编写简单脚本任务,每分钟将日期和时间数据追加写入mydate.txt文件中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建脚本文件mdate.sh</span><br>vim mdate.sh<br><br><span class="hljs-comment"># 写入指令</span><br>cal &gt;&gt; /home/mydate.txt<br><span class="hljs-built_in">date</span> &gt;&gt; /home/mdate.sh<br><br><span class="hljs-comment"># 赋予用户对该脚本文件的执行权力</span><br><span class="hljs-built_in">chmod</span> u+x /home/mdate.sh<br><br><span class="hljs-comment"># 添加任务调度</span><br>crontab -e<br><br><span class="hljs-comment"># 写入</span><br>*/1 * * * * /home/mdate.sh<br><br><span class="hljs-comment"># 用tail监控执行结果</span><br><span class="hljs-built_in">tail</span> -f /home/mydate.txt<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-at定时任务"><a href="#2-at定时任务" class="headerlink" title="2. at定时任务"></a>2. at定时任务</h3><p>​at命令是&#x3D;&#x3D;一次性&#x3D;&#x3D;定时计划任务，at的守护进程atd会已后台任务运行，检查作业队列来运行</p><p>默认是每60s检查队列，如果与任务时间匹配则执行任务</p><p><strong>注意</strong>：<u>在使用at命令时一定要保证atd进程的启动</u> ，一般使用 <code>ps-ef | grep atd</code>指令检查</p><ul><li><p><code>at [选项] 时间</code>：注意输出完成之后，按两次 <code>Ctrl + D</code>结束输入</p><p><img src="https://s2.loli.net/2023/11/02/KctHluiCATyoszw.png" alt="at"></p><ul><li><p>at的时间格式</p><ul><li><p><code>hh:mm</code>：小时分钟，例如，04：00</p></li><li><p>模糊词语:</p><ul><li><code>midnight</code>：深夜</li><li><code>noon</code>：中午</li><li><code>teatime</code>：喝茶时间（一般下午四点）</li><li>等待</li></ul></li><li><p>十二小时制：</p><ul><li><code>am</code>：上午</li><li><code>pm</code>：下午</li></ul></li><li><p>具体日期：</p><ul><li><code>month day</code></li><li><code>mm/dd/yy</code></li><li><code>dd.mm.yy</code></li></ul><p><strong>注意</strong>：指定日期必须在指定时间后，例如 04:00 2023-9-21</p></li><li><p>相对计时：</p><ul><li><code>now + count 时间单位</code>：minutes ,  hours , days ,weeks</li></ul></li><li><p>指定时间：</p><ul><li><code>today</code></li><li><code>tomorrow</code></li></ul></li></ul></li></ul></li><li><p><code>atq</code>：查看任务队列</p></li><li><p><code>atrm 编号</code>：删除已设置任务</p></li></ul><p><strong>案例</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@xxx ~]<span class="hljs-comment"># at 5pm + 2days</span><br>at&gt; /bin/ls /home&lt;EOT&gt; 注：按两次CTRL + D会出现&lt;EOT&gt;表示输出结束<br>job<span class="hljs-number"> 1 </span>at Thu Sep<span class="hljs-number"> 7 </span>16:34:00 2023<br><br>[root@xxx ~]<span class="hljs-comment"># atq</span><br>job<span class="hljs-number"> 1 </span>at Thu Sep<span class="hljs-number"> 7 </span>16:34:00<span class="hljs-number"> 2023 </span>a root<br></code></pre></td></tr></table></figure><p>​    </p><h2 id="六、磁盘相关"><a href="#六、磁盘相关" class="headerlink" title="六、磁盘相关"></a>六、磁盘相关</h2><p>linux磁盘分为，IDE硬盘，SCSI硬盘，目前基本上是SCSI硬盘</p><ul><li><p>IDE硬盘：</p><ul><li><p><code>hdx~</code>：其中hd为设备类型，x为盘号 ， ~表示分区</p><blockquote><p>a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘</p></blockquote></li></ul></li><li><p>SCSI硬盘：</p></li><li><p><code>sdx~</code>：sd为类型，其余同上</p></li><li><p><code>lsblk [选项]</code>：查看分区情况</p><ul><li><code>-f</code>：详细信息</li></ul></li></ul><h3 id="1-分区"><a href="#1-分区" class="headerlink" title="1. 分区"></a>1. 分区</h3><ul><li><p><code>fdisk 磁盘地址</code></p><img src="https://s2.loli.net/2023/11/02/GLd6fS7CQJmpxYK.png" alt="fdisk" style="zoom: 67%;" /><img src="https://s2.loli.net/2023/11/02/3TtcFvIXxGPhC8u.png" alt="fq" style="zoom: 67%;" /><ul><li><code>n</code>：添加分区</li><li><code>w</code>：写入并退出</li></ul><p><img src="https://s2.loli.net/2023/11/02/twszG9m8qhln7xu.png" alt="fqcz"></p><blockquote><p>前两个可自主配置，后面默认即可（回车）</p></blockquote></li><li><p><code>mkfs -t 文件格式 磁盘地址</code>：格式化磁盘</p><img src="https://s2.loli.net/2023/11/02/zg2RA6UKtdFxS4W.png" alt="gsh" style="zoom:67%;" /><p><img src="https://s2.loli.net/2023/11/02/iMJaO1TEgW2nBDv.png" alt="gsh2"></p></li></ul><blockquote><p>如图，格式化成功！</p></blockquote><h3 id="2-挂载"><a href="#2-挂载" class="headerlink" title="2. 挂载"></a>2. 挂载</h3><p>&#x3D;&#x3D;<strong>注意：用命令行挂载磁盘重启后会失效</strong>&#x3D;&#x3D;</p><ul><li><code>mount 磁盘地址 目标目录地址</code>  ：挂载磁盘</li><li><code>umount 磁盘地址 或 目录地址</code>：卸载磁盘</li></ul><p><img src="https://s2.loli.net/2023/11/02/nz2tViRF9KQf1DS.png" alt="gz"></p><p>&#x3D;&#x3D;<strong>永久挂载</strong>&#x3D;&#x3D;</p><p>​通过修改  <code>/etc/fstab</code> 实现，修改后执行  <code>mount -a</code> 即刻生效</p><p><img src="https://s2.loli.net/2023/11/02/KyosYtR6MFS2q1I.png" alt="fstab"></p><h3 id="3-磁盘情况"><a href="#3-磁盘情况" class="headerlink" title="3. 磁盘情况"></a>3. 磁盘情况</h3><p><strong>查询</strong>指定目录的磁盘占用情况</p><ul><li><code>du [选项]</code>：默认为当前用户<ul><li><code>-s</code>：目录占用大小总汇</li><li><code>-h</code>：带计量单位</li><li><code>-a</code>：含文件</li><li><code>--max-depth=n</code>：子目录深度为 <strong>n</strong></li><li><code>-c</code>：列出明细同时增加汇总值</li></ul></li></ul><p><strong>磁盘实用指令</strong></p><ul><li><p>统计&#x2F;opt下文件的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /opt | grep <span class="hljs-string">&quot;^-&quot;</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li><li><p>统计&#x2F;opt下目录的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /opt | grep <span class="hljs-string">&quot;^d&quot;</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li><li><p>统计&#x2F;opt下所以文件的个数（包括所有子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR /opt | gerp <span class="hljs-string">&quot;^-&quot;</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li><li><p>统计&#x2F;opt下所有目录的数量（包括所有子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR /opt | grep <span class="hljs-string">&quot;^d&quot;</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>指令中，grep 后为正则表达式，过滤 ls 的结果中符合首字母合格的数据，wc 为统计数据</p></blockquote><ul><li><p>目录树状显示</p><ul><li><code>tree 目录</code>：<ul><li>如没有 tree 指令，则使用 <code>yum install tree </code>安装</li></ul></li></ul><img src="https://s2.loli.net/2023/11/02/mcor4ONgGECBUQZ.png" alt="tree" style="zoom:67%;" /></li></ul><h2 id="七、网络配置"><a href="#七、网络配置" class="headerlink" title="七、网络配置"></a>七、网络配置</h2><h3 id="1-修改IP地址"><a href="#1-修改IP地址" class="headerlink" title="1. 修改IP地址"></a>1. 修改IP地址</h3><p>  固定NAT模式下的IP地址</p><pre><code class="hljs">1. 修改配置文件</code></pre>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33<br></code></pre></td></tr></table></figure><p>  <img src="https://s2.loli.net/2023/11/02/mJOGZF1iN9YMKD7.png" alt="ipconfig"></p><pre><code class="hljs">2. 注意网关与子网ip在同一网段内</code></pre><img src="https://s2.loli.net/2023/11/02/RsPnDJCLBd1FaZy.png" alt="ip2" style="zoom: 67%;" /><ol start="3"><li>重启网络服务，或重启系统后生效<ol><li><code>service network restart</code>：重启网络服务</li><li><code>reboot</code>：重启系统</li></ol></li></ol><h3 id="2-修改主机名"><a href="#2-修改主机名" class="headerlink" title="2. 修改主机名"></a>2. 修改主机名</h3><p>修改主机名方便记忆，便于区分不同的主机</p><ul><li><code>hostname</code>：查看当前主机名</li><li><code>vim /etc/hostname</code>：在该文件中指定当前主机名</li></ul><p>修改过后，重启生效</p><h3 id="3-host映射"><a href="#3-host映射" class="headerlink" title="3. host映射"></a>3. host映射</h3><p>设置host映射，使用主机名即可访问主机</p><ol><li><p>windows中：</p><ul><li>修改 <code>C:\Windows\System32\drivers\etc\hosts</code>文件，配置映射关系</li></ul></li><li><p>Linux中：</p><ul><li>修改 <code>/etc/hosts</code>文件，配置映射关系</li></ul></li></ol><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4. DNS"></a>4. DNS</h3><p>域名系统，在互联网上映射域名与IP的一个分布式数据库</p><p><strong>windows中</strong></p><ul><li><code>ipconfig /displaydns</code>：查看DNS域名解析缓存</li><li><code>ipconfig /flushdns</code>：手动清理dns缓存<ul><li>防止域名劫持</li></ul></li></ul><p><img src="https://s2.loli.net/2023/11/02/ulfT7gB4RZtNQpi.png" alt="dns"></p><h3 id="5-防火墙"><a href="#5-防火墙" class="headerlink" title="5. 防火墙"></a>5. 防火墙</h3><ul><li><code>firewall-cmd</code>：操作端口<ul><li><code>--permanent</code><ul><li><code>--add-port=端口号/协议</code>：打开端口</li><li><code>--remove-port=端口号/协议</code>：关闭端口</li></ul></li><li><code>--reload</code>：重载端口，更新操作后，重载生效</li><li><code>--query-port</code>&#x3D;端口号&#x2F;协议：查询端口是否开放</li><li><code>--list-ports</code>：查看所有开放的端口</li></ul></li></ul><p><strong>监控网络状态</strong></p><ul><li><p><code>netstat [选项]</code></p><ul><li><code>-an</code>：按一定顺序排列输出</li><li><code>-p</code>：显示哪个进程再调用</li></ul></li><li><p><code>-ntlp</code>：查看正在使用的端口</p><blockquote><p>注意经常查看网络状态，防止木马程序</p></blockquote></li></ul><h2 id="八、进程"><a href="#八、进程" class="headerlink" title="八、进程"></a>八、进程</h2><h3 id="1-查看进程"><a href="#1-查看进程" class="headerlink" title="1.查看进程"></a>1.查看进程</h3><ul><li><code>ps [选项]</code>：<ul><li><code>-a</code>：显示当前终端所有进程</li><li><code>-e</code>：显示所有进程</li><li><code>-u</code>：以用户的格式显示进程</li><li><code>-f</code>：以全格式显示进程</li><li><code>-x</code>：显示后台运行的参数</li></ul></li></ul><p><img src="https://s2.loli.net/2023/11/02/8lRCnpoS5eNmkJ9.png" alt="jc"></p><p><img src="https://s2.loli.net/2023/11/02/zKJ9lPMq1VibLjC.png" alt="gc2"></p><p><strong>如图所示，各列的含义为：</strong></p><ul><li><code>USER</code>：进程执行用户</li><li><code>PID</code>：进程号</li><li><code>PPID</code>：父进程号</li><li><code>%CPU</code>：占用CPU的百分比</li><li><code>%MEM</code>：占用物理内存的百分比</li><li><code>VSZ</code>：占用虚拟内存的情况</li><li><code>RSS</code>：占用物理内存的情况</li><li><code>TTY</code>：终端信息</li><li><code>STAT</code>：运行状态<ul><li><code>S</code>：睡眠，<code>s</code>，表示会话的先导进程</li><li><code>N</code>：表示比普通优先级更低的优先级</li><li><code>R</code>：正在运行</li><li><code>D</code>：短期等待</li><li><code>Z</code>：僵死进程，已经结束但未释放内存</li><li><code>T</code>：被跟踪或被停止</li></ul></li><li><code>START</code>：执行的开始时间</li><li><code>TIME</code>：占用的CPU时间</li><li><code>COMMAND</code>：进程名，执行该进程的指令</li></ul><p><strong>查看进程树</strong></p><ul><li><code>pstree [选项]</code>：以树状形式查看进程<ul><li><code>-p</code>：显示进程的PID</li><li><code>-u</code>：显示进程的所属用户</li></ul></li></ul><h3 id="2-终止进程"><a href="#2-终止进程" class="headerlink" title="2. 终止进程"></a>2. 终止进程</h3><ul><li><code>kill [选项] 进程号</code>：通过进程号终止一个进程<ul><li><code>-9</code>：强制终止</li></ul></li><li><code>killall 进程名称</code>：通过进程名终止所有同类进程</li></ul><p><strong>示例</strong>：</p><ol><li>终止远程登录服务sshd，再重新启动sshd服务</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 首先查看sshd相关所有进程</span><br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-aux</span> | gerp sshd<br><br><span class="hljs-comment">#找到对应进程号（/usr/sbin/sshd - D）</span><br><span class="hljs-built_in">kill</span> 进程号<br><br><span class="hljs-comment">#重启sshd服务</span><br>/bin/systemctl <span class="hljs-built_in">start</span> sshd.service<br></code></pre></td></tr></table></figure><ol start="2"><li>终止多个gedit进程</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">killall gedit</span><br></code></pre></td></tr></table></figure><ol start="3"><li>终止一个终端</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#查询终端进程</span><br><span class="hljs-attribute">ps</span> -aux | grep bash<br><br><span class="hljs-comment">#找到对应进程号，注意此处需要 -9 强制终止，终端会触发进程保护机制</span><br><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">10487</span> <br></code></pre></td></tr></table></figure><p>   <img src="https://s2.loli.net/2023/11/02/HmjyftOM8zPArJu.png" alt="zz"></p><h3 id="3-服务管理"><a href="#3-服务管理" class="headerlink" title="3. 服务管理"></a>3. 服务管理</h3><p>服务本质是进程，但是运行在后台，通常会监听某个端口，等待其他程序的请求，又称之为守护进程</p><ul><li><p><code>service [选项] 服务</code>：管理指令</p><ul><li><code>start</code>：启动</li><li><code>stop</code>：暂停</li><li><code>restart</code>：重启</li><li><code>reload</code>：重载</li><li><code>status</code>：状态</li></ul><p><strong>注意：</strong>在CentOS 7.0之后，很多服务&#x3D;&#x3D;不在使用service，而是systemctl&#x3D;&#x3D;</p><blockquote><p>service管理的服务在 &#x2F;etc&#x2F;init.d&#x2F;中查看</p></blockquote></li><li><p><code>setup</code>：查看所有系统服务</p></li><li><p><code>chkconfig [选项]</code>：设置所管理服务的各个运行级别设置自启动 或关闭</p><ul><li><code>[服务名] --list</code>：查看服务</li><li><code>--level 运行级别 服务名 on或of</code>：设置某服务在该运行级别上的自启动的状态</li></ul><blockquote><p>chkconfig重新设置服务后自启动或关闭，需要重启后生效</p></blockquote></li><li><p><code>systemctl [选项] 服务</code> ：服务管理指令</p><ul><li><code>start |stop | restart | status</code>：作用同上</li></ul><blockquote><p>systemctl指令管理的服务在 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system</p></blockquote><p>设置服务自启动状态</p><ul><li><code>list-unit-files</code>：查看服务开机启动状态</li><li><code>enable 服务名</code>：设置服务开机自启</li><li><code>disable 服务名</code>：关闭服务开机自启</li><li><code>is-enable 服务名</code>：查询某个服务开机自启状态</li></ul></li></ul><h3 id="4-动态监控"><a href="#4-动态监控" class="headerlink" title="4. 动态监控"></a>4. 动态监控</h3><p>top指令实现对进程的动态监控，与ps不同的是执行一段时间后可以更新正在运行的进程</p><ul><li><code>top [选项]</code>：<ul><li><code>-d 秒数</code>：指定top命令每个几秒更新，默认3秒</li><li><code>-i</code>：时top命令不显示闲置或将死的命令</li><li><code>-p id号</code>：通过指定进程ID来监视某个进程的状态</li></ul></li><li>交互操作<ul><li><code>P</code>：以CPU使用率排序，默认选项</li><li><code>M</code>：以内存使用率排序</li><li><code>N</code>：以PID排序</li><li><code>q</code>：退出top</li><li><code>u</code>：再输入用户名，监控该用户的进程</li><li><code>k</code>：再输入进程ID，结束该进程</li></ul></li></ul><h2 id="九、包管理"><a href="#九、包管理" class="headerlink" title="九、包管理"></a>九、包管理</h2><h3 id="1-rpm"><a href="#1-rpm" class="headerlink" title="1. rpm"></a>1. rpm</h3><p>rpm用于互联网下载包的打包及安装工具。生成具有.RPM拓展名的文件</p><ul><li><code>rpm [选项]</code><ul><li><code>-q 包名</code>：查询软件包是否被安装<ul><li><code>-i 包名</code>：查询软件包详细信息</li><li><code>-l 包名</code>：查询软件包中的文件</li><li><code>-f 包名</code>：查询该文件的所属软件包</li><li><code>-a 包名</code>：查询所安装的所有的rpm软件包</li></ul></li><li><code>-e 包名</code>：删除软件包<ul><li>如果删除时报出警告，无法发删除，则可以添加 <code>--nodeps</code> 强制删除（谨慎使用）</li></ul></li><li><code>-ivh 软件包路径全名称</code>：安装软件包<ul><li><code>-i</code>：install 安装</li><li><code>-v</code>：verbose 提示</li><li><code>-h</code>：hash 进度条</li></ul></li></ul></li></ul><h3 id="2-yum"><a href="#2-yum" class="headerlink" title="2. yum"></a>2. yum</h3><p>yum是一个shell前端包管理器，基于rpm包管理，能够从指定服务器自动下载rpm包并安装，自动处理依赖关系并安装</p><ul><li><code>yum [选项]</code><ul><li><code>install 软件名</code>：安装指定包名</li><li><code>list 软件名</code>：在yum服务器上查询是否有该软件</li></ul></li></ul><h2 id="十、搭建JavaEE环境"><a href="#十、搭建JavaEE环境" class="headerlink" title="十、搭建JavaEE环境"></a>十、搭建JavaEE环境</h2><h3 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h3><p><strong>安装步骤</strong></p><ol><li><p><code>mkdir /opt/jdk</code></p></li><li><p>通过xftp6上传到 &#x2F;opt&#x2F;jdk 下 cd &#x2F;opt&#x2F;jdk</p></li><li><p>解压tar -zxvf jdk-8u261-linux-x64.tar.gz</p></li><li><p><code>mkdir /usr/local/java</code></p></li><li><p><code>mv /opt/jdk/jdki.8.0_261 /usr/local/java</code>配置环境变量的配置文件<code>vim /etc/profile</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/java/jdk1.8.0_261<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p><code>source /etc/profile</code>让新的环境变量生效]测试是否安装成功</p></li><li><p>编写一个简单的Hello.java输出”hello,world!”</p></li></ol><h3 id="2-安装tomcat"><a href="#2-安装tomcat" class="headerlink" title="2. 安装tomcat"></a>2. 安装tomcat</h3><p><strong>步骤</strong></p><ol><li><p>上传安装文件，并解压缩到 <code>/opt/tomcat</code></p></li><li><p>进入解压目录<code>/bin</code>，启动<code>tomcat ./startup.sh</code></p></li><li><p>开放端口8080</p></li><li><p>测试是否安装成功</p></li><li><p>在windows、Linux下访问<a href="http://linuxip:8080/">http://linuxip:8080</a><br>·</p></li></ol><h3 id="3-安装MySQL"><a href="#3-安装MySQL" class="headerlink" title="3. 安装MySQL"></a>3. 安装MySQL</h3><p><strong>步骤</strong>：</p><ol><li>新建文件夹<code>/opt/mysql</code>，并cd进去</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://dev.mysql.com/get/mysql-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span>.el7.x86_64.rpm-bundle.tar，下载mysql安装包<br></code></pre></td></tr></table></figure><blockquote><p>PS: centos7.6自带的类MySQL数据库是maria-db，会跟MySQL冲突，要先删除。</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">运行 tar -xvf mysq1-<span class="hljs-number">5.7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span><span class="hljs-selector-class">.e17</span><span class="hljs-selector-class">.x86_64</span><span class="hljs-selector-class">.rpm-bundle</span>.tar<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">运行rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> mari，查询mariadb相关安装包<br><br>运行rpm -<span class="hljs-keyword">e</span> --nodeps mariadb-libs，卸载<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/Pl4r29zoudjBLDH.png" alt="maria"></p><ol start="2"><li>然后开始真正安装mysql，依次运行以下几条</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh mysql-community-common-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span>.el7.x86_64.rpm<br><br><span class="hljs-attribute">rpm</span> -ivh mysql-community-libs-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span>.el7.x86_64.rpm<br><br><span class="hljs-attribute">rpm</span> -ivh mysql-community-client-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span>.el7.x86_64.rpm<br><br><span class="hljs-attribute">rpm</span> -ivh mysql-community-server-<span class="hljs-number">5</span>.<span class="hljs-number">7</span>.<span class="hljs-number">26</span>-<span class="hljs-number">1</span>.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">运行systemctl <span class="hljs-literal">start</span> mysqld.service，启动mysql<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/hvuT8g134Wc5Pt9.png" alt="mysql3"></p><ol start="3"><li><p>然后开始设置root用户密码</p></li><li><p>Mysql自动给root用户设置随机密码，</p></li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">运行 grep <span class="hljs-string">&quot;password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>/mysqld.<span class="hljs-built_in">log</span> 可看到当前密码<br></code></pre></td></tr></table></figure><ol start="5"><li>运行<code>mysql -u root -p</code>，用root用户登录，提示输入密码可用上述的，可以成功登陆进入mysql命令行</li></ol><p><img src="https://s2.loli.net/2023/11/02/6XlyqaUY72WojOE.png" alt="mysqlpd"></p><ol start="6"><li>设置root密码，对于个人开发环境，如果要设比较简单的密码&#x3D;&#x3D;(生产环境服务器要设复杂密码)&#x3D;&#x3D;</li></ol><p><img src="https://s2.loli.net/2023/11/02/ePAcqMhpROuHXyQ.png" alt="mysqlpd3"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">可以运行<span class="hljs-built_in">set</span> global <span class="hljs-attribute">validate_password_policy</span>=0;<br></code></pre></td></tr></table></figure><ol start="7"><li>提示密码设置策略 ( validate_password_policy 默认值1,)</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;root@&#x27;</span>localhost<span class="hljs-string">&#x27;=password(&#x27;</span><span class="hljs-number">12345678</span><span class="hljs-string">&#x27;);</span><br></code></pre></td></tr></table></figure><ol start="8"><li>运行<code>flush privileges;</code>使密码设置生效</li></ol><p><img src="https://s2.loli.net/2023/11/02/jeq4mh7SsvcYzO9.png" alt="mysqlpd2"></p><ul><li><code>mysqldump</code></li></ul><h2 id="十一、Shell编程"><a href="#十一、Shell编程" class="headerlink" title="十一、Shell编程"></a>十一、Shell编程</h2><p>​<strong>Shell</strong>是一个命令行解释器，他为用户提供一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动，挂起，停止和编写一些程序</p><p><strong>简单示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim hello.sh<br><br>写入:<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;nihao~&quot;<br><br>运行：<br>sh hello.sh<br>或<br>./hello.sh<br></code></pre></td></tr></table></figure><h3 id="1-Shell变量"><a href="#1-Shell变量" class="headerlink" title="1. Shell变量"></a>1. Shell变量</h3><p>Shell变量分为<u>系统变量</u>和<u>用户自定义变量</u></p><p>系统变量：$HOME , $PWD , $SHELL ,$USER等</p><p>使用  <code>set</code> 指令可显示当前所有变量</p><p><strong>Shell变量定义</strong></p><ol><li>定义变量：<code>变量名=值</code></li><li>撤销变量：<code>unset 变量名</code></li><li>声明静态变量：<code>readonly 变量名</code></li></ol><p>&#x3D;&#x3D;注&#x3D;&#x3D;：静态变量不能 unset</p><p><strong>输出变量</strong></p><ul><li><code>$变量名</code></li><li><code>$(指令)</code>：可以将指令的结果返回</li><li>&#96;&#96;(指令) <code>\</code>：作用同上</li></ul><p><strong>设置环境变量</strong></p><ul><li><code>export 变量名=变量值</code>：将Shell变量输出为环境变量</li><li><code>source 配置文件</code>：让修改立即生效~</li><li><code>echo $变量名</code>：查看环境变量的值</li></ul><p><strong>多行注释</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;!<br>内容<br>！<br></code></pre></td></tr></table></figure><p><strong>位置参数变量</strong></p><p>当一个shell脚本需要获取命令行的参数信息时，就需要在shell脚本中设置位置参数变量</p><ul><li><code>$n</code>：n表示数字，$0 表示shell指令本身 ，从​$1开始表示传入的参数，1代表第一个参数</li><li><code>$*</code>：代表命令行中传入的所有的参数，但该命令将所有参数视为一个整体</li><li><code>$@</code>：代表命令行中传入的所有的参数，但该命令将参数分为各个个体</li><li><code>$#</code>：代表命令行中传入参数的数量</li></ul><p><strong>预定义变量</strong></p><p>是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p><ul><li><code>$$</code>：当前进程的进程号PID</li><li><code>$!</code>：后台运行的最后一个进程的进程号</li><li><code>$?</code>：最后一次执行的命令的返回状态<ul><li><code>0</code>：表示上一个命令正确执行</li><li><code>非0</code>：表示上一个命令执行不正确</li></ul></li></ul><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h3><ul><li><code>$((运算式))</code>：返回计算值</li><li><code>$[运算式]</code>：返回计算值，&#x3D;&#x3D;推荐&#x3D;&#x3D;</li><li><code>expr m + n</code>：计算运算式，如需返回计算值则要在语句外用 **&#96;&#96;**嵌套<ul><li><code>+ ，- ，\* ，/ ，%</code>：运算符，注意乘号要使用转义字符</li></ul></li></ul><h3 id="3-条件判断"><a href="#3-条件判断" class="headerlink" title="3. 条件判断"></a>3. 条件判断</h3><ul><li><code>=</code>：比较字符串</li><li>整数比较<ul><li><code>-lt</code>：小于</li><li><code>-le</code>：小于等于</li><li><code>-gt</code>：大于</li><li><code>-ge</code>：大于等于</li><li><code>-ne</code>：不等于</li></ul></li><li>文件权限判断<ul><li><code>-r</code>：读权限</li><li><code>-w</code>：写权限</li><li><code>-x</code>：执行权限</li></ul></li><li>文件类型判断<ul><li><code>-f</code>：存在并且是普通文件</li><li><code>-e</code>：存在</li><li><code>-d</code>：存在并且是目录</li></ul></li></ul><h3 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h3><p><strong>if判断</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">第一种</span><br>if [ 23 -ge 22 ]<br>then<br>echo &quot;大于&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">第二种</span><br>if [ $1 -ge 60 ]<br>then<br>echo &quot;及格了&quot;<br>elif [ $1 -lt 60 ]<br>then<br>echo &quot;不及格&quot;<br>fi<br></code></pre></td></tr></table></figure><p>注意：if 后 条件判断式 <code>[ 语句 ]</code>语句&#x3D;&#x3D;与中括号之间要有空格&#x3D;&#x3D;</p><p><strong>case语句</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $1 in<br>&quot;1&quot;)<br>echo &quot;周一&quot;<br>;;<br>&quot;2&quot;)<br>echo &quot;周二&quot;<br>;;<br>&quot;3&quot;)<br>echo &quot;周三&quot;<br>;;<br>*)<br>echo &quot;其他&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><p><strong>for循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">第一种</span><br>for 变量 in 值1 值2 值3等等<br>do<br>程序语句<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">示例(此时<span class="hljs-variable">$@</span>将传入的所有参数视为单个个体)</span><br>for i in $@<br>do<br>echo $i<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">示例(此时$*将传入的所有参数视为一个整体)</span><br>for i in $*<br>do<br>echo $i<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">第二种</span><br>for ((初始值;循环控制条件;变量变化))<br>do<br>程序语句<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">示例(注意此处i不能使用整数运算符)</span><br>SUN=0<br>for (( i=1; i&lt;=$1; i++ ))<br>do<br>SUM=$[$SUM+$i]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 语句 ]<br>do<br>程序语句<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">示例(注意此处条件判断时使用的是[]，语句中不能使用 &gt; , &lt; ,= 。若需要使用，则将[]改为 (()) 即可 )</span><br>SUM=0<br>i=0<br>while [ $i -le $1 ]<br>do<br>SUM=$[$SUM+$i]<br>i=$[$i+1]<br>done<br>echo $SUM<br></code></pre></td></tr></table></figure><h3 id="5-read读取控制台"><a href="#5-read读取控制台" class="headerlink" title="5. read读取控制台"></a>5. read读取控制台</h3><ul><li><code>read [选项] 参数</code><ul><li><code>-p</code>：提示符<ul><li><code>read -p &quot;请输入&quot; NUM</code></li></ul></li><li><code>-t</code>：读取时的等待时间，超时自动往后执行<ul><li><code>read -t 10 -p &quot;请输入&quot; NUM</code></li></ul></li></ul></li></ul><h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h3><p><strong>简单系统函数</strong></p><ul><li><code>basename 路径 [后缀]</code>：获取文件名<ul><li>如果加上了后缀 <code>basename /home/jack/aa.txt .txt</code>,则只返回单纯文件名<code>aa</code></li></ul></li><li><code>dirname 路径</code>：获取目录的最后一个  <code>/</code> 之前的所有路径</li></ul><p><strong>自定义函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">注意返回值，有就写上，没有就不用写</span><br>function 方法名()&#123;<br>方法体<br>[return int;]<br>&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">调用(有参就写在后面，无参不用写)</span><br>方法名 参数1 参数2 <br></code></pre></td></tr></table></figure><h3 id="7-综合案例-备份数据库"><a href="#7-综合案例-备份数据库" class="headerlink" title="7. 综合案例-备份数据库"></a>7. 综合案例-备份数据库</h3><p><strong>完整代码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库备份目录</span><br>BACKUP=/data/backup/db<br><span class="hljs-meta prompt_">#</span><span class="language-bash">获取当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库地址</span><br>HOST=localhost<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库用户名</span><br>DB_USER=root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库密码</span><br>DB_PW=12345678<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库名</span><br>DATABASE=&#x27;test&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1. 创建备份目录，如不存在则创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2. 执行备份操作</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3. 将文件打包为tar.gz</span><br>cd $&#123;BACKUP&#125;<br>tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4. 将对应文件夹删除</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">5. 检查目录中是否存在超过十天的文件，有则删除</span><br>find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br><br>echo &quot;备份数据库 $DATABASE 成功！&quot;<br></code></pre></td></tr></table></figure><p><strong>创建定时任务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">crontab -e<br><br><span class="hljs-comment">#写入</span><br><br>30 2 * * * /usr/sbin/mysql_db_backup.sh<br></code></pre></td></tr></table></figure><h2 id="十二、日志"><a href="#十二、日志" class="headerlink" title="十二、日志"></a>十二、日志</h2><p>日志记录着许多重要系统事件，对于主机安全很重要，可以通过日志来检查错误的原因或攻击者的痕迹</p><p><img src="https://s2.loli.net/2023/11/02/zmteW6vZ1pD9iuP.jpg" alt="log"></p><h3 id="1-日志管理服务rsyslogd"><a href="#1-日志管理服务rsyslogd" class="headerlink" title="1. 日志管理服务rsyslogd"></a>1. 日志管理服务rsyslogd</h3><p><strong>检查Linux中的rsyslogd服务是否启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps aux | grep <span class="hljs-string">&quot;rsyslog&quot;</span> <br></code></pre></td></tr></table></figure><p><strong>查询rsyslogd的自启动自启动状态</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl list-unit-files | grep <span class="hljs-string">&quot;rsyslog&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>配置文件：&#x2F;etc&#x2F;rsyslog.conf</p><ul><li><p>编辑文件时的格式为 *.*  存放日志文件</p><ul><li><p>第一个* 代表日志类型</p><ul><li><code>auth</code>：pam产生的日志</li><li><code>authpriv</code>：SSH，FTP等登录信息的验证信息</li><li><code>cron</code>：时间任务相关</li><li><code>kern</code>：内核</li><li><code>lpr</code>：打印</li><li><code>mail</code>：邮件</li><li><code>mark(syslog)-rsyslog</code>：服务内部信息，时间标识</li><li><code>news</code>：新闻组</li><li><code>user</code>：用户程序产生的相关信息</li><li><code>uucp</code>：UNIX to UNIX copy 主机之间的相互通信 </li><li><code>local 1-7</code>：自定义的日志设备</li></ul></li><li><p>第二个*代表日志级别</p><ul><li><code>debug</code>：有调试信息的，日志通信最多</li><li><code>info</code>：一般信息日志，最常用</li><li><code>notice</code>：最具有重要性的普通条件的信息</li><li><code>warning</code>：警告级别</li><li><code>err</code>：错误级别，阻止整个功能或模块不能正常工作的信息</li><li><code>crit</code>：严重级别，组织整个系统或软件不能正常工作的信息</li><li><code>alert</code>：需要立刻修改的信息</li><li><code>emerg</code>：内核崩溃等重要信息</li><li><code>none</code>：什么都不记录</li></ul><blockquote><p>从上到下，级别从低到高，记录信息越来越少</p></blockquote></li></ul></li></ul></li></ul><p><strong>自定义日志</strong></p><ol><li>进入 <code>rsyslog.conf</code> 配置文件</li><li>添加配置，并指定输出文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/rsyslog.conf<br><br><span class="hljs-comment">#添加配置</span><br><br>*.*                                      /var/log/diylog.log<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/TqUJrE3pbLQHxSY.jpg" alt="diylog"></p><h3 id="2-日志轮替"><a href="#2-日志轮替" class="headerlink" title="2. 日志轮替"></a>2. 日志轮替</h3><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存范围后就会进行删除</p><p><strong>轮替规则管理</strong></p><ul><li><p>编辑 <code>/etc/logrolate.conf</code> 配置文件中 <code>dateext</code> 参数</p><blockquote><p>默认为全局日志轮替规则，也可单独为某个文件配置(如下图最后几行)</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/jPMW5c7xUoFOXgC.png" alt="logrolate"></p></li><li><p>也可将某个日志轮替规则写到<code>/etc/logrolate.d/</code>中</p><blockquote><p>就是上图最后几行</p></blockquote></li><li><p>参数说明</p><ul><li><code>daily</code>：轮替周期为天</li><li><code>weekly</code>：轮替周期为周</li><li><code>monthly</code>：轮替周期为月</li><li><code>rotate 数字</code>：保留日志文件的个数，0指不备份</li><li><code>compress</code>：日志轮替时，旧日志进行压缩</li><li><code>create mode owner group</code>：建立新日志时，同时指定新日志的权限和所有者与所有组</li><li><code>mail address</code>：当日志轮替时，输出内容通过邮件发送至指定邮箱</li><li><code>missingok</code>：如果日志不存在，则忽略该日志的警告信息</li><li><code>notifempty</code>：如果日志为空文件则不进行日志轮替</li><li><code>minsize 大小</code>：日志轮替的最小值，只有当日志达到最小值才会轮替，否则时间到了也不会轮替</li><li><code>size 大小</code>：日志只有大于指定大小才会轮替，而不是按照时间轮替</li><li><code>dateext</code>：使用日期作为日志轮替文件的后缀</li><li><code>sharedscripts</code>：在此关键字之后的脚本只执行一次</li><li><code>prerotate/endscript</code>：在日志轮替之前，执行脚本命令</li><li><code>postrotate/endscript</code>：在日志轮替之后，执行脚本命令</li></ul></li></ul><h3 id="3-查看内存日志"><a href="#3-查看内存日志" class="headerlink" title="3. 查看内存日志"></a>3. 查看内存日志</h3><p>注意内存日志，<strong>重启清空</strong></p><ul><li><code>journalctl</code>：查看全部内存日志<ul><li><code>-n 数字</code>：查看最新n条</li><li><code>--since 19:00 --until 19:10:10 </code>：查看从开始时间到结束时间内的日志</li><li><code>-p err</code>：查看报错日志</li><li><code>-o verbose</code>：日志详细内容</li><li><code>_PID=1234 _COMM=sshd</code>：查看包含这些函数的日志</li></ul></li></ul><h2 id="十三、备份与恢复"><a href="#十三、备份与恢复" class="headerlink" title="十三、备份与恢复"></a>十三、备份与恢复</h2><h3 id="1-dump"><a href="#1-dump" class="headerlink" title="1. dump"></a>1. dump</h3><p>dump支持分卷和增量备份（差异备份）</p><blockquote><p>增量备份支持分区，不支持文件或目录</p></blockquote><ul><li><code>dump [-cu] [数字] [-f 备份后的文件名] [-T 日期] [目录或文件系统]</code><ul><li><code>-c</code>：创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头</li><li><code>-数字</code>：备份的层级 0-9 ，0为完整备份，指定其他层级则为增量备份，到 9 后则再次从 0 开始</li><li><code>-f 备份后的文件名</code>：指定备份后的文件名</li><li><code>-j</code>：调用bzlib库压缩备份文件，压缩后为bz2格式，让文件更小</li><li><code>-T 日期</code> ：开始备份的时间和日期</li><li><code>-u</code>：备份完成之后在 &#x2F;etc&#x2F;dumpdates 中记录备份的文件系统，层级，日期，时间</li><li><code>-t</code>：指定文件名，若该文件已存在备份文件中，则列出姓名</li><li><code>-W</code>：显示需要备份的文件及最后一次备份的层级，时间日期</li><li><code>-w</code>：与-W类似，但仅显示需要备份的文件</li></ul></li></ul><p>例如，将&#x2F;boot分区的所有内容备份到 &#x2F;opt&#x2F;boot.bak0.bz2 文件中，备份层级为 0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">xfsdump -0uj -f /opt/book.bak0.bz2 /boot<br></code></pre></td></tr></table></figure><p><strong>注</strong>：需要用 <code>df -TH</code> 查看分区的类型，并在dump前加上对应的类型</p><h3 id="2-restore"><a href="#2-restore" class="headerlink" title="2. restore"></a>2. restore</h3><p>restore用来回复已备份的文件，可以从dump生成的备份文件中回复原文件</p><ul><li><p><code>restore [模式选项] [选项]</code>：四个选项每次只能指定一种</p><ul><li><p><code>-C</code>：对比模式，将备份文件与已存在文件相互对比</p></li><li><p><code>-i</code>：交互模式，在进行还原操作时，restore指令将依序询问用户</p></li><li><p><code>-r</code>：还原模式</p></li><li><p><code>-t</code>：查看模式，查看备份文件中由哪些文件</p></li><li><p><code>-f 备份文件</code>：从指定文件中读取备份数据，进行还原操作</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2023/12/11/Dubbo/"/>
    <url>/2023/12/11/Dubbo/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><blockquote><p>轻量级 Java RPC框架</p></blockquote><p><strong>RPC简单原理</strong></p><p><img src="https://s2.loli.net/2023/11/02/wqmc4uvfhapKYJj.png" alt="rpc"></p><p><strong>Dubbo简单架构</strong></p><p><img src="https://s2.loli.net/2023/11/02/2pSwDBltfOQPXI7.png" alt="dubbo"></p><h2 id="一、安装与启动"><a href="#一、安装与启动" class="headerlink" title="一、安装与启动"></a>一、安装与启动</h2><h3 id="1-安装注册中心"><a href="#1-安装注册中心" class="headerlink" title="1. 安装注册中心"></a>1. 安装注册中心</h3><p><strong>zookeeper</strong></p><blockquote><p>一个树形目录服务，支持变更推送，适合作为Dubbo的注册中心</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/nCAO1FgZP86EWwa.png" alt="zookeeper"></p><h3 id="2-安装Dubbo管理控制台"><a href="#2-安装Dubbo管理控制台" class="headerlink" title="2. 安装Dubbo管理控制台"></a>2. 安装Dubbo管理控制台</h3><p><strong>进入GitHub下载压缩包</strong></p><p><a href="https://github.com/apache/dubbo-admin">apache&#x2F;dubbo-admin</a></p><p><strong>使用maven打包并运行</strong></p><p><img src="https://s2.loli.net/2023/11/02/slpoiUdnGkVqKIj.png" alt="mvn"></p><ul><li><p>找到 <code>pom</code>文件所在目录</p><ul><li><p>打开终端输入</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">rem</span> 跳过测试打包<br>mvn clean package -Dmaven.test.skip=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>找到 <code>jar</code>包所在目录</p><ul><li><p>打开终端输入</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">rem</span> 启动jar包<br>java -jar xxx.jar<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>ui</code>    则使用  <code> npm</code>打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install dependencies</span><br>npm install<br><br><span class="hljs-comment"># serve with hot reload at localhost:8080</span><br>npm run dev<br><br><span class="hljs-comment"># build for production with minification</span><br>npm run build<br><br><span class="hljs-comment"># build for production and view the bundle analyzer report</span><br>npm run build --report<br></code></pre></td></tr></table></figure></li><li><p>启动完成</p><blockquote><p>默认进入localhost:38082端口访问</p><p>具体则在 ui 包中的 <code>vue.config.js</code> 文件中查找</p></blockquote></li></ul><h3 id="3-编写示例项目"><a href="#3-编写示例项目" class="headerlink" title="3. 编写示例项目"></a>3. 编写示例项目</h3><p><strong>使用XML</strong></p><p>目录结构</p><p>├─<strong>customer</strong><br>│  ├─src<br>│  │  ├─main<br>│  │  │  ├─java<br>│  │  │  │  │  AppC.java<br>│  │  │  │  │<br>│  │  │  │  └─service<br>│  │  │  │          OrderServiceImpl.java<br>│  │  │  │<br>│  │  │  └─resources<br>│  │  │          consumer.xml<br>├─<strong>interface</strong><br>│  ├─src<br>│  │  ├─main<br>│  │  │  ├─java<br>│  │  │  │  ├─bean<br>│  │  │  │  │      User.java<br>│  │  │  │  │<br>│  │  │  │  └─service<br>│  │  │  │          OrderService.java<br>│  │  │  │          UserService.java<br>├─<strong>provider</strong><br>│  ├─src<br>│  │  ├─main<br>│  │  │  ├─java<br>│  │  │  │  │  App.java<br>│  │  │  │  │<br>│  │  │  │  └─service<br>│  │  │  │          UserServiceImpl.java<br>│  │  │  │<br>│  │  │  └─resources<br>│  │  │          provider.xml</p><blockquote><ul><li>接口放在 interface 中单独管理</li><li>实现类各写在 消费者 与 提供者 中</li><li>消费者通过 Dubbo 远程调用提供者的接口实现</li></ul></blockquote><ul><li><p><code>provider.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    指定当前服务的名字--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user-service-provider&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    指定注册中心的位置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;zookeeper&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    指定通信规则 (通信协议 ， 通信端口)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    暴露服务 ref指向实现对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--    服务的实现对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;service.UserServiceImpl&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    配置监控中心--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;registry&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>consumer.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    设置包扫描       --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;service&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order-service-consumer&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    声明需要的接口服务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--    配置监控中心   --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;registry&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>两者都在  <code>pom</code>  文件中导入接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.dutest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>提供者向注册中心 注册（暴露）提供的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">12</span>);<br><br>        List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(aa);<br>        list.add(bb);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;provider.xml&quot;</span>);<br>        ioc.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者向注册中心订阅（调用）提供者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">initOrder</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> userService.getUsers(<span class="hljs-string">&quot;AA&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;consumer.xml&quot;</span>);<br>        <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> ioc.getBean(OrderService.class);<br>        orderService.initOrder(<span class="hljs-string">&quot;AA&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>使用Springboot</strong></p><blockquote><p>Springboot则使用注解与yml配置文件，配置注册中心 与暴露和需要的服务</p></blockquote><ul><li><p><code>yml</code>  </p><ul><li>provider</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user-service-provider</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:2181</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">zookeeper</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">20880</span><br>  <span class="hljs-attr">monitor:</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><ul><li>consumer</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-service-consumer</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2181</span><br>  <span class="hljs-attr">monitor:</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">registry</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure></li><li><p>同样在pom文件中导入接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.dutest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>提供者向注册中心 注册（暴露）提供的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-comment">// 暴露服务</span><br><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">12</span>);<br><br>        List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(aa);<br>        list.add(bb);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableDubbo</span> <span class="hljs-comment">// 启用Dubbo</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderssApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ProviderssApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者向注册中心订阅（调用）提供者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-comment">// 从注册中心远程引用</span><br>    <span class="hljs-meta">@DubboReference</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">initOrder</span><span class="hljs-params">(String name)</span> &#123;<br>        List&lt;User&gt; list = userService.getUsers(<span class="hljs-string">&quot;AA&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    OrderService orderService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/init&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">initOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> orderService.initOrder(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p><strong>配置关系</strong></p><p><img src="https://s2.loli.net/2023/11/02/ewDPxYU2JlNOy84.jpg" alt="conf"></p><h3 id="1-启动检测"><a href="#1-启动检测" class="headerlink" title="1. 启动检测"></a>1. 启动检测</h3><blockquote><p>spring 启动后会根据配置文件默认检查注册中心是否存在需要的服务，没有则报错</p></blockquote><ul><li><p>通过xml设置启动不检查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>全局配置所有消费者</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置注册中心启动不检查</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-超时与重试"><a href="#2-超时与重试" class="headerlink" title="2. 超时与重试"></a>2. 超时与重试</h3><blockquote><p>防止，由于网络或其他原因，使消费者请求长时间没有回应，造成线程阻塞</p><ul><li>默认值为 <code>1000ms</code></li></ul><p>优先级</p><ul><li>精确优先</li><li>消费者优先</li></ul></blockquote><p><img src="https://s2.loli.net/2023/11/02/1HziMgd3Rk6nFw7.png" alt="timeout"></p><p><strong>重试</strong></p><blockquote><p>超时失败后重试次数</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>注：</strong>&#x3D;&#x3D;</p><ul><li><strong>幂等</strong>操作<strong>能</strong>设置重试次数<ul><li>多次操作产生的结果一致<ul><li>查询</li><li>删除</li><li>修改</li></ul></li></ul></li><li><strong>非幂等</strong>操作<strong>不能</strong>设置重试次数<ul><li>多次操作产生的结果不一致<ul><li>新增</li></ul></li></ul></li></ul><h3 id="3-多版本"><a href="#3-多版本" class="headerlink" title="3. 多版本"></a>3. 多版本</h3><blockquote><p>一个接口的实现的不同版本</p></blockquote><ul><li><p>provider</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  v1--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--    服务的实现对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;service.UserServiceImpl&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--   v2  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService2&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.0&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--    服务的实现对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;service.UserServiceImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>consumer</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    指定需要的版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>随机版本（灰度发布）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    指定需要的版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;*&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-本地存根"><a href="#4-本地存根" class="headerlink" title="4. 本地存根"></a>4. 本地存根</h3><blockquote><p>消费者在调用远程接口前</p><p>存根可以先进行一些校验</p></blockquote><ul><li><p>在接口模块中新建存根类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceStub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br><span class="hljs-comment">//    构造器输入UserService</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传入的的是userService远程代理对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userService 用户服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceStub</span><span class="hljs-params">(UserService userService)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(name)) &#123;<br>            <span class="hljs-keyword">return</span> userService.getUsers(name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在  <code>consumer.xml</code>中配置指定使用的存根</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;service.UserService&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">stub</span>=<span class="hljs-string">&quot;service.UserServiceStub&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h2><h3 id="1-Zookeeper宕机与Dubbo直连"><a href="#1-Zookeeper宕机与Dubbo直连" class="headerlink" title="1. Zookeeper宕机与Dubbo直连"></a>1. Zookeeper宕机与Dubbo直连</h3><p><strong>Zookeeper宕机</strong></p><p><img src="https://s2.loli.net/2023/11/02/IhZDl37r6mG4t29.png" alt="dj"></p><p><strong>Dubbo直连</strong></p><ul><li><p>绕过注册中心，直接连接远程服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br><span class="hljs-comment">// 从注册中心远程引用</span><br><span class="hljs-comment">//    @DubboReference</span><br>  <span class="hljs-comment">// Dubbo 直连  </span><br>    <span class="hljs-meta">@DubboReference(url = &quot;127.0.0.1:20880&quot;)</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">initOrder</span><span class="hljs-params">(String name)</span> &#123;<br>        List&lt;User&gt; list = userService.getUsers(<span class="hljs-string">&quot;AA&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-集群模式下的负载均衡"><a href="#2-集群模式下的负载均衡" class="headerlink" title="2. 集群模式下的负载均衡"></a>2. 集群模式下的负载均衡</h3><p><strong>Random LoadBalance</strong></p><p><img src="https://s2.loli.net/2023/11/02/NSLYuIabrPJyMiW.png" alt="rlb"></p><p><strong>RandomRobin LoadBalance</strong></p><p><img src="https://s2.loli.net/2023/11/02/GSQRj5bovgN9JPA.png" alt="rrlb"></p><p><strong>LeastActive LoadBalance</strong></p><p><img src="https://s2.loli.net/2023/11/02/SiZAmBdcnQarPbJ.png" alt="lalb"></p><p><strong>ConsistentHash LoadBalance</strong></p><p><img src="https://s2.loli.net/2023/11/02/aQI5pidTjOlwSHy.png" alt="chlb"></p><p><strong>服务端服务级别</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">loadbalance</span>=<span class="hljs-string">&quot;roundrobin&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>客户端服务级别</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">loadbalance</span>=<span class="hljs-string">&quot;roundrobin&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>服务端方法级别</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">loadbalance</span>=<span class="hljs-string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>客户端方法级别</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">loadbalance</span>=<span class="hljs-string">&quot;roundrobin&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-服务降级"><a href="#3-服务降级" class="headerlink" title="3. 服务降级"></a>3. 服务降级</h3><blockquote><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，</p><p>从而释放服务器资源以保证核心交易正常运作或高效运作。</p></blockquote><p><strong>配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mock=&quot;[fail|force]return|throw xxx&quot;<br></code></pre></td></tr></table></figure><ul><li>fail 或 force 关键字可选，表示调用失败或不调用强制执行 mock 方法，如果不指定关键字默认为 fail</li><li>return 表示指定返回结果，throw 表示抛出指定异常</li><li>xxx 根据接口的返回类型解析，可以指定返回值或抛出自定义的异常</li></ul><p><strong>例：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;return&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;return null&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;fail:return aaa&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;force:return true&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;fail:throw&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.xxx.service.DemoService&quot;</span> </span><br><span class="hljs-tag">                 <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;force:throw java.lang.NullPointException&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配合 dubbo-admin 使用</strong></p><ul><li>应用消费端引入 <a href="https://github.com/apache/dubbo-spi-extensions/tree/master/dubbo-mock-extensions"><code>dubbo-mock-admin</code></a>依赖</li><li>应用消费端启动时设置 JVM 参数，<code>-Denable.dubbo.admin.mock=true</code></li><li>启动 dubbo-admin，在服务 Mock-&gt; 规则配置菜单下设置 Mock 规则</li></ul><blockquote><p>以服务方法的维度设置规则，设置返回模拟数据，动态启用&#x2F;禁用规则</p></blockquote><p><strong>注意事项</strong></p><blockquote><p> Dubbo 启动时会<strong>检查配置</strong>，当 mock 属性值配置有误时会启动失败，可根据错误提示信息进行排查</p></blockquote><ul><li><strong>配置格式错误</strong>，如 <code>return+null</code> 会报错，被当做 mock 类型处理，<code>return</code> 后面可省略不写或者跟空格后再跟返回值</li><li><strong>类型找不到错误</strong>，如自定义 mock 类、throw 自定义异常，请检查类型是否存在或是否有拼写错误</li></ul><h3 id="4-集群容错"><a href="#4-集群容错" class="headerlink" title="4. 集群容错"></a>4. 集群容错</h3><p><strong>整合Hystrix</strong></p><ul><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactld</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在启动类激活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableDubbo(scanBasePackages = &quot;com.example.providerss&quot;)</span> <span class="hljs-comment">// 启用Dubbo</span><br><span class="hljs-meta">@EnableHystrix</span> <span class="hljs-comment">// 启用容错</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderssApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ProviderssApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-meta">@EnableHystrix</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在指定方法上加入Hystrix管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service</span><br><span class="hljs-comment">// 暴露服务</span><br><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;hello&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">12</span>);<br><br>        List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(aa);<br>        list.add(bb);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出错时调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-number">12</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;DD&quot;</span>, <span class="hljs-number">12</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><h3 id="1-RPC与Netty原理"><a href="#1-RPC与Netty原理" class="headerlink" title="1. RPC与Netty原理"></a>1. RPC与Netty原理</h3><p><strong>RPC</strong></p><p><img src="https://s2.loli.net/2023/11/02/wqmc4uvfhapKYJj.png" alt="rpc"></p><p><strong>Netty</strong></p><blockquote><p>Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p><p>它极大地简化并简化了TCP和 UDP套接字服务器等网络编程。</p></blockquote><ul><li><p><strong>NIO</strong></p><p><img src="https://s2.loli.net/2023/11/02/Bj5vWaTx4KQze6g.png" alt="nio"></p></li><li><p>netty则是基于nio框架</p><p><img src="https://s2.loli.net/2023/11/02/m5U3ZBSQCqYdzAs.png" alt="netty"></p></li></ul><h3 id="2-Dubbo框架"><a href="#2-Dubbo框架" class="headerlink" title="2. Dubbo框架"></a>2. Dubbo框架</h3><p><img src="https://s2.loli.net/2023/11/02/cCtzSHhNbUIsy7d.png" alt="kj"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/12/10/Docker/"/>
    <url>/2023/12/10/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><u>Docker</u></h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h3><p><strong>进入官方文档</strong>：<a href="https://docs.docker.com/engine/install/centos/">Docker Install</a></p><ul><li>安装之前卸载已有文件</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure><ul><li>设置存储库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y yum-utils<br><br><span class="hljs-comment">#注意这里使用国内源</span><br>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><ul><li><p>安装最新版docker引擎</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure></li><li><p>启动并验证</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start docker<br><br>docker version<br><br><span class="hljs-comment">#测试运行hello-world镜像</span><br>sudo docker run hello-world<br><br><span class="hljs-comment">#查看已有镜像</span><br>docker images<br></code></pre></td></tr></table></figure><h3 id="2-配置阿里云镜像加速器"><a href="#2-配置阿里云镜像加速器" class="headerlink" title="2. 配置阿里云镜像加速器"></a>2. 配置阿里云镜像加速器</h3><p>首先登录阿里云，找到镜像服务 -&gt; 镜像加速器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /etc/docker<br><br><span class="hljs-comment">#注意此处镜像地址用自己阿里云当中的</span><br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://zwx0tf4k.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br><br>systemctl daemon-reload<br><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><p><strong>详细信息参阅官方文档</strong>：<a href="https://docs.docker.com/reference/">Reference documentation | Docker Docs</a></p><h3 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1. 帮助命令"></a>1. 帮助命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看版本信息</span><br>docker version<br><br><span class="hljs-comment">#显示系统信息</span><br>docker info<br><br><span class="hljs-comment">#帮助命令</span><br>docker --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h3 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h3><ul><li><p><code>docker images [选项]</code>：查看本机镜像</p><ul><li><code>-a</code>：列出所有镜像</li><li><code>-q</code>：只显示镜像id</li></ul></li><li><p><code>docker search [选项] 镜像名</code>：搜索镜像</p><ul><li><code>--filter=[条件]</code>：过滤查询</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#搜索收藏量大于300的mysql镜像</span><br>docker search mysql --filter=STARS=300<br></code></pre></td></tr></table></figure><ul><li><code>docker pull 镜像名:标签</code>：下载镜像</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#下载mysql镜像</span><br><span class="hljs-comment">#默认下载最新版</span><br>docker pull mysql<br><br><span class="hljs-comment">#下载5.7版本（注：这里的版本需要在镜像仓库中存在）</span><br>docker pull mysql:5.7<br></code></pre></td></tr></table></figure><p>镜像仓库：<a href="https://hub.docker.com/search?q=mysql">Docker Hub | MySQL</a></p><ul><li><code>docker rmi -f [镜像id][][]...</code>：删除指定镜像<ul><li><code>-f $&#123;docker images -q&#125;</code>：删除所有镜像</li></ul></li></ul><h3 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h3><p>有了镜像才能创建容器</p><p>&#x3D;&#x3D;容器相当于在现有镜像上在加一层可写层在镜像顶部&#x3D;&#x3D;</p><ul><li><p><code>docker run [选项] 镜像名</code>：新建容器并启动</p><ul><li><p><code>--name=&quot;名称&quot;</code>：设置容器名称</p></li><li><p><code>-d</code>：后台方式运行</p></li><li><p><code>-it</code>：使用交互方式运行</p></li><li><p><code>-p </code>：指定容器端口</p><ul><li><code>-p ip:主机端口:容器端口</code></li><li><code>-p 主机端口:容器端口</code>：常用</li><li><code>-p 容器端口</code></li><li><code>容器端口</code></li></ul></li><li><p><code>-P</code>：随机指定端口</p></li><li><p><code>-v </code>：容器数据卷挂载目录，数据同步</p><ul><li><p><code>-v 容器内路径</code>：匿名挂载</p></li><li><p><code>-v 卷名:容器内路径</code>：具名挂载</p><blockquote><p>docker中卷都在 <strong><code>/var/lib/docker/volumes</code></strong> 目录中</p><p>可以通过 <strong><code>docker volumes inspect 卷名</code></strong> 查看卷的详细信息</p></blockquote></li><li><p><code>-v 宿主机目录:容器内目录</code>：指定路径挂载</p></li></ul><blockquote><p>容器的持久化和同步操作，将容器内的目录挂载到容器外，使数据同步，容器之间也可以数据共享</p></blockquote></li><li><p><code>--volumes-from 容器id</code>：实现数据同步，链式结构头容器为父容器与宿主机挂载，保证数据不丢失</p></li></ul></li><li><p>限制容器内存</p><p><img src="https://s2.loli.net/2023/12/01/35ZaMPcA1gKDtm7.png" alt="memory"></p><ul><li><p>未启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -m 4g --memory-swap -1  <br></code></pre></td></tr></table></figure></li><li><p>已启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker stop containerId<br>docker update containerId -m 4g  --memory-swap -1<br>docker start containerId<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">--memory  或  -m  限制容器的内存使用量（如10m,200m等）<br>--memory-swap <span class="hljs-comment"># 限制内存和 Swap 的总和，不设置的话默认为--memory的两倍</span><br><br>如果只指定了 --memory 则 --memory-swap 默认为 --memory 的两倍<br>如果 --memory-swap 和 --memory 设置了相同值，则表示不使用 Swap<br>如果 --memory-swap 设置为 -1 则表示不对容器使用的 Swap 进行限制<br>如果设置了 --memory-swap 参数，则必须设置 --memory 参数<br><br>后期 update --memory 时数值不能超过 --memory-swap 的值，<br>否则会报错 Memory <span class="hljs-built_in">limit</span> should be smaller than already <span class="hljs-built_in">set</span> memoryswap <span class="hljs-built_in">limit</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 终端交互模式</span><br>docker run -it centos<br><br><span class="hljs-comment"># 后台运行模式</span><br>docker run -d centos <br><br><span class="hljs-comment"># 在挂载卷后加  ro 或 rw 表示指定容器内的目录的权限，ro为只读则容器内该目录只读，默认为rw读写</span><br>docker run -d -v /home/dkh:/home:ro centos<br><br><span class="hljs-comment">#退出容器</span><br><span class="hljs-built_in">exit</span><br><br><span class="hljs-comment">#退出并后台运行</span><br>Ctrl + P + Q<br></code></pre></td></tr></table></figure><ul><li><p><code>docker ps [选项]</code>：查看当前运行的容器</p><ul><li><code>-a</code>：列出所有运行过的容器</li><li><code>-q</code>：只显示容器id</li></ul></li><li><p><code>docker rm [选项] 容器id</code>：删除容器</p><ul><li><code>-f</code>：强制删除</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$&#123;docker ps -aq&#125;</span><br><br>docker ps -aq | xargs docker <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker start 容器id</code>：启动容器</p></li><li><p><code>docker restart 容器id</code>：重启容器</p></li><li><p><code>docker stop 容器id</code>：停止容器</p></li><li><p><code>docker kill 容器id</code>：强制停止容器</p></li><li><p><code>docker commit [选项] 容器id 新镜像名:TAG</code></p><ul><li><code>-a=&quot;作者&quot;</code></li><li><code>-m=&quot;提交信息&quot;</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker commit -a=<span class="hljs-string">&quot;kongke&quot;</span> -m=<span class="hljs-string">&quot;设置tomcat主页&quot;</span> tomcat01 tomcat02:1.0<br></code></pre></td></tr></table></figure><blockquote><p>commit指令可以保存当前容器的状态，类似于虚拟机快照，提交变成新的镜像</p></blockquote></li></ul><h3 id="4-其他常用命令"><a href="#4-其他常用命令" class="headerlink" title="4. 其他常用命令"></a>4. 其他常用命令</h3><ul><li><p><code>docker logs [选项] 容器id</code>：查看日志</p><ul><li><code>-tf</code>：显示日志并带上时间戳</li><li><code>--tail 数字</code>：显示日志条数</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看该容器的最后5条日志，并监控最新日志</span><br>docker logs -tf --<span class="hljs-built_in">tail</span> 5 aas12sdas<br></code></pre></td></tr></table></figure></li><li><p><code>docker top</code>：查看容器内进程</p></li><li><p><code>docker inspect 容器id</code>：查看容器所有信息(元数据)</p></li><li><p><code>docker exec -it 容器id bashShell</code>：进入正在运行的容器(在容器中开启一个新的终端)</p></li><li><p><code>docker attach 容器id</code>：进入容器正在执行的终端</p></li><li><p><code>docker cp 容器id:容器内路径 目的主机路径</code>：从容器中复制文件到主机上</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">cp</span> 8150473976e6:/home/test.txt /home<br></code></pre></td></tr></table></figure><h2 id="三、常用镜像安装"><a href="#三、常用镜像安装" class="headerlink" title="三、常用镜像安装"></a>三、常用镜像安装</h2><h3 id="1-Nginx安装"><a href="#1-Nginx安装" class="headerlink" title="1. Nginx安装"></a>1. Nginx安装</h3><ul><li><p>搜索nginx镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker search nginx<br></code></pre></td></tr></table></figure></li><li><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull nginx<br></code></pre></td></tr></table></figure></li><li><p>启动nginx容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 给镜像命名为nginx01 ，设置端口映射</span><br>docker run -d --name nginx01 -p 3344:80 nginx<br></code></pre></td></tr></table></figure><blockquote><p>注意此处需要打开防火墙3344端口</p></blockquote></li><li><p>查看启动情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker ps<br></code></pre></td></tr></table></figure></li><li><p>访问nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl localhost:3344<br></code></pre></td></tr></table></figure></li><li><p>进入容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it nginx01 /bin/bash<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Tomcat安装"><a href="#2-Tomcat安装" class="headerlink" title="2. Tomcat安装"></a>2. Tomcat安装</h3><ul><li><p>查找并下载tomcat镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull tomcat:9.0<br></code></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name tomcat01 -p 3355:8080 tomcat:9.0<br></code></pre></td></tr></table></figure></li><li><p>进入容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#因为镜像为精简版，运行成功后没有主页，但主页相关文件在webapps.dist中，将其复制到webapps中则可访问</span><br>docker <span class="hljs-built_in">exec</span> tomcat01 /bin/bash<br><br><span class="hljs-built_in">cp</span> -r webapps.dist/* webapps/<br></code></pre></td></tr></table></figure></li><li><p>访问</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">curl</span> localhost:<span class="hljs-number">3355</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-ElasticSearch安装"><a href="#3-ElasticSearch安装" class="headerlink" title="3. ElasticSearch安装"></a>3. ElasticSearch安装</h3><ul><li><p>查找并下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull elasticsearch:7.6.2<br></code></pre></td></tr></table></figure></li><li><p>配置容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name es01 -p 9200:9200 -p 9300:9300 \<br><span class="hljs-comment"># 设置集群模式</span><br>-e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br><span class="hljs-comment"># 限制内存</span><br>-e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms64 -Xmx512m&quot;</span> \<br>elasticsearch:7.6.2<br></code></pre></td></tr></table></figure></li><li><p>访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl localhost:9200<br></code></pre></td></tr></table></figure></li><li><p>查看内存占用情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker stats<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-Mysql安装"><a href="#4-Mysql安装" class="headerlink" title="4. Mysql安装"></a>4. Mysql安装</h3><blockquote><p>mysql安装需要保证数据同步</p></blockquote><ul><li><p>查找并下载镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull mysql:5.7<br></code></pre></td></tr></table></figure></li><li><p>启动并配置镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>-p 3307:3306 \<br><span class="hljs-comment"># 此处为数据卷挂载</span><br>-v /home/dkmysql/conf:/etc/mysql/conf.d \<br>-v /home/dkmysql/data:/var/lib/mysql \<br><span class="hljs-comment"># 设置mysql的密码</span><br>-e MYSQL_ROOT_PASSWORD=123456 \<br>--name mysql01 \<br>mysql:5.7<br></code></pre></td></tr></table></figure></li><li><p>利用三方软件登录测试</p></li></ul><h2 id="四、DockerFile"><a href="#四、DockerFile" class="headerlink" title="四、DockerFile"></a>四、DockerFile</h2><blockquote><p>DockerFile 就是用来构建 docker 镜像的<strong>命令脚本</strong></p></blockquote><h3 id="1-DockerFile指令"><a href="#1-DockerFile指令" class="headerlink" title="1. DockerFile指令"></a>1. DockerFile指令</h3><p><strong>常用指令</strong>：</p><ul><li><code>FROM</code>：指定基础镜像</li><li><code>MAINTAINER</code>：备注镜像作者 姓名+邮箱</li><li><code>RUN</code>：构建是需要执行的命令</li><li><code>ADD</code>：添加文件到镜像内，例如：压缩包</li><li><code>WORKDIR</code>：镜像的工作目录</li><li><code>VOLUME</code>：挂载的目录</li><li><code>EXPOSE</code>：暴露的端口</li><li><code>CMD</code>：容器启动时需要运行的命令，只有最后一个会生效，会被覆盖</li><li><code>ENTRYPOINT</code>：容器启动时需要运行的命令，命令可以追加</li><li><code>ONBUILD</code>：当构建一个被继承 DockerFile 时 会触发onbuild的指令</li><li><code>COPY</code>：类似ADD 将文件复制到镜像中</li><li><code>ENV</code>：构建时配置环境变量</li></ul><blockquote><p>CMD 与 ENTRYPOINT 的区别对比</p></blockquote><p><strong>测试CMD</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 在cmd中，执行构建好的镜像时，不能追加命令，只能覆盖命令</span><br>] vim dkfile-cmd<br><br>FROM centos:7<br>CMD [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>]<br><br>] docker build -f dkfile-cmd -t cmdtest .<br><span class="hljs-comment"># 此时如果在指令后追加指令例如入下想达到 ls -al的功能则会报错</span><br>] docker run cmdtest -l<br><span class="hljs-comment">#此处报错称 -l 不是命令，因为此处 -l 会覆盖掉dkfile-cmd中最后一个cmd的命令 【ls -a】</span><br><br><span class="hljs-comment">#但如果将命令写为</span><br>] docker run cmdtest <span class="hljs-built_in">ls</span> -al<br><span class="hljs-comment">#则会正确执行ls -al，因为ls -al 覆盖掉了dkfile-cmd中的【ls -a】</span><br></code></pre></td></tr></table></figure><p><strong>测试ENTRYPOINT</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 与上述环境相同</span><br><span class="hljs-comment"># 在ent中，执行构建好的镜像时,能追加命令</span><br>] vim dkfile-ent<br><br>FROM centos:7<br>ENTRYPOINT [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>]<br><br>] docker build -f dkfile-ent -t enttest .<br><span class="hljs-comment"># 此时如果在指令后追加指令 【-l】</span><br>] docker run enttest -l<br><span class="hljs-comment">#此处会正确运行 【ls -al】指令，【-l】成功追加到 【ls -a】后</span><br></code></pre></td></tr></table></figure><h3 id="2-编写简单文件"><a href="#2-编写简单文件" class="headerlink" title="2. 编写简单文件"></a>2. 编写简单文件</h3><ul><li><p>构建自定义centos</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 注意此处需要指定版本，因为默认centos8  不再维护，官方镜像源中已移除</span><br><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> kongke&lt;<span class="hljs-number">2843732083</span>@qq.com&gt;<br><br><span class="hljs-keyword">ENV</span> MYPATH /usr/local<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;----end----&quot;</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br><br></code></pre></td></tr></table></figure></li><li><p>构建文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 注意最后的点表示在当前目录的上下文关系</span><br>docker build -f mydkfile-ct -t mycentos:0.1 .<br></code></pre></td></tr></table></figure></li><li><p>查看构建过程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">history</span> mycentos:0.1<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-编写Tomcat镜像"><a href="#3-编写Tomcat镜像" class="headerlink" title="3. 编写Tomcat镜像"></a>3. 编写Tomcat镜像</h3><p>创建镜像目录，结构为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attr">--dkbuild</span><br><span class="hljs-attr">--dktomcat</span><br><span class="hljs-attr">--Dockerfile</span><br><span class="hljs-attr">--readme</span><span class="hljs-selector-class">.txt</span><br><span class="hljs-attr">--test</span><br><span class="hljs-attr">--dklogs</span><br></code></pre></td></tr></table></figure><ul><li><p>编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> kongke&lt;<span class="hljs-number">2843732083</span>@qq.com&gt;<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> readme.txt /usr/local/readme.txt</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> jdk-8u202-linux-x64.tar.gz /usr/local</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.80.tar.gz /usr/local</span><br><br><br><span class="hljs-keyword">ENV</span> MYPATH /usr/local<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_202<br><span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br><span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">80</span><br><span class="hljs-keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">80</span><br><span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$CATALINA_HOME/lib<br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.80/bin/startup.sh</span><br><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 此处因为文件名为Dockerfile且在当前目录，所以不用指定文件</span><br>] docker build -t mytomcat .<br></code></pre></td></tr></table></figure></li><li><p>运行镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker run -it -p 9090:8080 --name mytomcat01 \<br><span class="hljs-comment"># 此处将项目目录挂载</span><br>-v /home/dkbuild/dktomcat/test:/usr/local/apache-tomcat-9.0.80/webapps/test \<br><span class="hljs-comment"># 将日志目录挂载</span><br>-v /home/dkbuild/dktomcat/dklogs:/usr/local/apache-tomcat-9.0.80/logs \<br>mytomcat /bin/bash<br></code></pre></td></tr></table></figure></li></ul><h2 id="五、发布镜像到远程仓库"><a href="#五、发布镜像到远程仓库" class="headerlink" title="五、发布镜像到远程仓库"></a>五、发布镜像到远程仓库</h2><h3 id="1-发布到DockerHub"><a href="#1-发布到DockerHub" class="headerlink" title="1. 发布到DockerHub"></a>1. 发布到DockerHub</h3><ul><li><p>登录DockerHub账号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker login -u kongke7<br>password: <span class="hljs-comment">#输入密码</span><br>登录成功！<br></code></pre></td></tr></table></figure></li><li><p>更改镜像命名</p><blockquote><p>因为发布镜像的规范为 用户名&#x2F;镜像名:版本号 例如 -&gt; kongke7&#x2F;mytomcat:1.0</p><p>否则无法推送</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker tag 42c1543f639b kongke7/mytomcat:1.0 <br></code></pre></td></tr></table></figure></li><li><p>推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker push kongke7/mytomcat:1.0<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-发布到阿里云镜像仓库"><a href="#2-发布到阿里云镜像仓库" class="headerlink" title="2. 发布到阿里云镜像仓库"></a>2. 发布到阿里云镜像仓库</h3><ul><li>登录阿里云Docker Registry</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker login --username=kongke registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><blockquote><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p><p>您可以在访问凭证页面修改凭证密码。</p></blockquote><ul><li>从Registry中拉取镜像</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker pull registry.cn-hangzhou.aliyuncs.com/kongke7/kongke7-<span class="hljs-built_in">test</span>:[镜像版本号]<br></code></pre></td></tr></table></figure><ul><li>将镜像推送到Registry</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker login --username=kongke registry.cn-hangzhou.aliyuncs.com<br>$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/kongke7/kongke7-<span class="hljs-built_in">test</span>:[镜像版本号]<br>$ docker push registry.cn-hangzhou.aliyuncs.com/kongke7/kongke7-<span class="hljs-built_in">test</span>:[镜像版本号]<br></code></pre></td></tr></table></figure><blockquote><p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p></blockquote><ul><li>选择合适的镜像仓库地址</li></ul><blockquote><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。</p></blockquote><ul><li>示例</li></ul><blockquote><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/kongke7/kongke7-<span class="hljs-built_in">test</span>:[镜像版本号]<br></code></pre></td></tr></table></figure><blockquote><p>使用 “docker push” 命令将该镜像推送至远程。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816<br></code></pre></td></tr></table></figure><h2 id="六、Docker网络"><a href="#六、Docker网络" class="headerlink" title="六、Docker网络"></a>六、Docker网络</h2><blockquote><p>当我们安装了Docker，就会多一个<strong>Docker0</strong>网卡，使用<strong>桥接模式</strong>连接网络</p><p>Docker每启动一个容器，都会为容器分配一个ip地址</p></blockquote><h3 id="1-Docker0"><a href="#1-Docker0" class="headerlink" title="1. Docker0"></a>1. Docker0</h3><blockquote><p>Docker0使用的<strong>veth-pair</strong>技术为容器间通信</p></blockquote><ul><li>使用  <code>ip addr</code>  命令查看地址，当启动了一个容器则会出现下图的网卡（75: veth2f50f93@if74）</li></ul><p><img src="https://s2.loli.net/2023/11/02/rMhz57yaNFJSgCe.png" alt="ipaddr"></p><ul><li>每当增加一个容器，则会对应多一对网卡（77: veth407b0c8@if76）</li></ul><p><img src="https://s2.loli.net/2023/11/02/8UsuB9qpiIKc7gC.png" alt="ipaddr2"></p><blockquote><p>则一对一对的网卡，就是veth-pair技术</p><p>veth-pair就是一对虚拟设备接口，一端连接协议，一端彼此相连</p><p>正因如此，veth-pair 充当一座桥梁，连接各种虚拟设备</p></blockquote><ul><li>如图所示，veth-pair连接的原理</li></ul><p><img src="https://s2.loli.net/2023/11/02/1tjQLpTMIv29rXH.png" alt="vethpair"></p><h3 id="2-自定义网路"><a href="#2-自定义网路" class="headerlink" title="2.自定义网路"></a>2.自定义网路</h3><ul><li><p><strong>网络模式</strong></p><table><thead><tr><th>模式</th><th>介绍</th></tr></thead><tbody><tr><td>bridge</td><td>桥接模式，docker默认</td></tr><tr><td>host</td><td>主机模式，与宿主机共享网路</td></tr><tr><td>none</td><td>不配置网络</td></tr><tr><td>container</td><td>容器网络连通（不常用，局限性大）</td></tr></tbody></table></li><li><p><strong>查看docker网络信息</strong></p><ul><li><p><code>docker network ls</code>：查看网络信息 （其中bridge为Docker0）</p><p><img src="https://s2.loli.net/2023/11/02/rJ3XF8b1EHfz94p.png" alt="network"></p></li><li><p><code>docker network inspect 网络id </code>：查看某个网络的具体信息</p></li></ul></li><li><p><strong>创建自定义网络</strong></p><ul><li><code>--driver</code>：网络模式，默认bridge</li><li><code>--subnet</code>：子网（划分网段）</li><li><code>--gateway</code>：网关（通常为当前网段的第一个ip）</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]  docker network create \<br>--driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet<br><br>4a17ecbfac448947ed9c0711ed291b3a63049832f8d23c3722e238bae15accc9<br>[root@localhost ~]  docker network <span class="hljs-built_in">ls</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>f26af714313b   bridge    bridge    <span class="hljs-built_in">local</span><br>50828ab4f805   host      host      <span class="hljs-built_in">local</span><br>4a17ecbfac44   mynet     bridge    <span class="hljs-built_in">local</span><br>e412b2fb7593   none      null      <span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure></li><li><p><strong>将容器运行到指定网络</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~] docker run -d -name tomcat-net-01 --net mynet tomcat<br></code></pre></td></tr></table></figure></li><li><p>此时自定义网络内的容器可以通过容器名相互访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~] docker <span class="hljs-built_in">exec</span> -it tomcat-net-01 ping tomcat-net-02<br></code></pre></td></tr></table></figure></li><li><p><strong>网络连通</strong></p><blockquote><p>因为网络之间相互隔离，正常情况下一个网络中的容器无法连通另一网络中的容器，</p><p>但是，通过将容器与另一网络相连则可实现网络连通</p><p>即，一个容器两个ip</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker network connect mynet tomcat01<br></code></pre></td></tr></table></figure></li></ul><h2 id="七、实战部署"><a href="#七、实战部署" class="headerlink" title="七、实战部署"></a>七、实战部署</h2><h3 id="1-Redis集群部署"><a href="#1-Redis集群部署" class="headerlink" title="1. Redis集群部署"></a>1. Redis集群部署</h3><ul><li><p>创建redis节点并启动各节点容器</p><p><strong>编写shell脚本执行任务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>for port in $(seq 1 6);<br>do<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建节点</span><br><br>        mkdir -p /mydata/dkredis/node-$&#123;port&#125;/conf<br>        touch /mydata/dkredis/node-$&#123;port&#125;/conf/redis.conf<br>        cat &lt;&lt; EOF &gt;/mydata/dkredis/node-$&#123;port&#125;/conf/redis.conf<br>port 6379<br>bind 0.0.0.0<br>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout 5000<br>cluster-announce-ip 172.38.0.1$&#123;port&#125;<br>cluster-announce-port 6379<br>cluster-announce-bus-port 16379<br>appendonly yes<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动节点容器</span><br>docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \<br>-v /mydata/dkredis/node-$&#123;port&#125;/data:/data \<br>-v /mydata/dkredis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \<br>-d --net redis-net --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf;<br><br>done<br><br></code></pre></td></tr></table></figure></li><li><p>创建redis集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis-1节点容器</span><br><span class="hljs-comment"># 创建redis集群</span><br>] redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 \<br>172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/TWvGdbUDK3C6OYk.png" alt="redis-jq"></p></li><li><p>进入redis-1节点查看集群信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入节点</span><br>/data ] redis-cli -c<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看集群信息</span><br>127.0.0.1:6379&gt; cluster info<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/11/02/KDZoRQU4PInavCW.png" alt="info" style="zoom:67%;" /><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看节点信息</span><br>127.0.0.1:6379&gt; cluster nodes<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/SxQhXfvFdaiwN24.png" alt="nodes"></p></li><li><p><strong>部署成功</strong></p></li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">       _ _                /\/|<span class="hljs-string"></span><br><span class="hljs-string">      (_) </span>|<span class="hljs-string">              </span>|<span class="hljs-string">/\/ </span><br><span class="hljs-string"> _ __  _</span>|<span class="hljs-string"> </span>|<span class="hljs-string">__   __ _  ___     </span><br><span class="hljs-string"></span>|<span class="hljs-string"> &#x27;_ \</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> &#x27;_ \ / _` </span>|<span class="hljs-string">/ _ \    </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> (_</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> (_) </span>|<span class="hljs-string">   </span><br><span class="hljs-string"></span>|<span class="hljs-string">_</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_</span>|<span class="hljs-string">_</span>|<span class="hljs-string">_</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_</span>|<span class="hljs-string">\__,_</span>|<span class="hljs-string">\___/    </span><br><span class="hljs-string">                              </span><br><span class="hljs-string">                              </span><br></code></pre></td></tr></table></figure><h3 id="2-部署Springboot项目"><a href="#2-部署Springboot项目" class="headerlink" title="2. 部署Springboot项目"></a>2. 部署Springboot项目</h3><ul><li><p>编写简单springboot项目，并打成  <code>jar包</code> </p></li><li><p>编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><br><span class="hljs-keyword">MAINTAINER</span> kongke&lt;<span class="hljs-number">2843732083</span>@qq.com&gt;<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> *.jar /app.jar</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>将<code>jar包</code>和<code>Dockerfile</code>上传至虚拟机</p></li><li><p>构建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker build -t javawebtest:1.0 .<br></code></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] docker run -d -p 8080:8080 --name javaweb javawebtest:1.0<br></code></pre></td></tr></table></figure></li><li><p>测试接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">] curl localhost:8080/hello<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/02/VuQXjskAnGywmE4.png" alt="res"></p></li><li><p><strong>部署成功！</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8-新特性</title>
    <link href="/2023/12/10/Java8/"/>
    <url>/2023/12/10/Java8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><blockquote><p>Java 8   的新特性</p></blockquote><h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><ul><li><code>(参数) -&gt; &#123;方法体&#125;</code></li><li><code>参数 -&gt; &#123;方法体&#125;</code>：当只有一个参数时，可以省略小括号</li><li><code>(参数) -&gt; 方法体</code>：当方法体只有一条语句时，可以省略大括号</li></ul><blockquote><ol><li>无参无返回值</li></ol></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正常写法          </span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">run1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                  System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>              &#125;<br>          &#125;;<br>          <span class="hljs-comment">// lambda</span><br>          <span class="hljs-type">Runnable</span> <span class="hljs-variable">run2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>一个参数 ， 无返回值</li></ol></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正常写法             </span><br>Consumer&lt;String&gt; con1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>                  System.out.println(s);<br>              &#125;<br>          &#125;;<br>          <span class="hljs-comment">// lambda</span><br>          Consumer&lt;String&gt; con2 = (String s) -&gt; &#123;<br>              System.out.println(s);<br>          &#125;;<br>          <span class="hljs-comment">// 当方法体只有一条语句时，大括号可以省略，（有无返回值都一样）</span><br>          Consumer&lt;String&gt; con3 = (String s) -&gt; System.out.println(s);<br>          <span class="hljs-comment">// 参数类型可以省略   (类型推断)</span><br>          Consumer&lt;String&gt; con4 = (s) -&gt; System.out.println(s);<br>          <span class="hljs-comment">// 一个参数可以省略括号</span><br>          Consumer&lt;String&gt; con5 = s -&gt; System.out.println(s);<br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>有两个以上接口，并且有返回值，有多条语句</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正常写法        </span><br>Comparator&lt;Integer&gt; com1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                  System.out.println(<span class="hljs-string">&quot;两数比较&quot;</span>);<br>                  <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>              &#125;<br>          &#125;;<br>          <span class="hljs-comment">// lambda</span><br>          <span class="hljs-comment">// 单条语句</span><br>          Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);<br>          <span class="hljs-comment">// 多条语句</span><br>          Comparator&lt;Integer&gt; com3 = (o1, o2) -&gt; &#123;<br>              System.out.println(<span class="hljs-string">&quot;HHH&quot;</span>);<br>              <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>          &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h3><ul><li><p><strong>Java四个基本函数式接口</strong></p><table><thead><tr><th>名称</th><th>抽象方法</th></tr></thead><tbody><tr><td>Consumer<T>  消费型</td><td>void accept(T t)</td></tr><tr><td>Predicate<T>    判定型</td><td>boolean test(T t)</td></tr><tr><td>Supplier<T>      供给型</td><td>T get()</td></tr><tr><td>Function&lt;T,R&gt;   函数型</td><td>R apply(T t)</td></tr></tbody></table></li><li><p>示例</p><ul><li><p><code>Consumer&lt;T&gt;</code> 消费型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">functionInterCons</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 正常写法</span><br>        cons(<span class="hljs-number">500.0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Double&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Double aDouble)</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;消费%.2f元\n&quot;</span>, aDouble);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//lambda</span><br>        cons(<span class="hljs-number">500.0</span>, money -&gt; System.out.printf(<span class="hljs-string">&quot;消费%.2f元\n&quot;</span>, money));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cons</span><span class="hljs-params">(Double money, Consumer&lt;Double&gt; con)</span> &#123;<br>        con.accept(money);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Predicate&lt;T&gt;</code> 判定型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">functionInterPre</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;AB&quot;</span>, <span class="hljs-string">&quot;AC&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>);<br>        <span class="hljs-comment">// 正常写法</span><br>    List&lt;String&gt; res = pres(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 判定条件</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>                <span class="hljs-keyword">return</span> s.contains(<span class="hljs-string">&quot;A&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// lambda</span><br>        System.out.println(pres(list, s -&gt; s.contains(<span class="hljs-string">&quot;A&quot;</span>)));<br><br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">pres</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span>&#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            <span class="hljs-comment">// pre中只有一个方法</span><br>            <span class="hljs-keyword">if</span> (pre.test(s)) &#123;<br>                res.add(s);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Supplier&lt;T&gt;</code> 供给型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">functionInterSup</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 正常写法</span><br>    supp(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;str&quot;</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// lambda</span><br>        supp(() -&gt; <span class="hljs-string">&quot;str&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">supp</span><span class="hljs-params">(Supplier&lt;String&gt; sup)</span> &#123;<br>        System.out.println(sup.get());<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Function&lt;T,R&gt;</code> 函数型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">functionInterFunc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 正常写法</span><br>    func((<span class="hljs-type">byte</span>) <span class="hljs-number">127</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Byte, Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Byte aByte)</span> &#123;<br>                <span class="hljs-keyword">return</span> aByte + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// lambda</span><br>        func((<span class="hljs-type">byte</span>) -<span class="hljs-number">128</span>, b -&gt; b - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(Byte bytes, Function&lt;Byte, Integer&gt; func)</span> &#123;<br>        System.out.println(func.apply(bytes));<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h3><blockquote><p>实现的方法需要与抽象方法参数类型及返回值类型一致</p></blockquote><ul><li><p>使用格式：<code>类(或对象) :: 方法名</code></p><ul><li><p><code>类 :: 静态方法名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">Supplier&lt;Long&gt; sup2 = System::currentTimeMillis;<br>      System.out.println(sup2.get());<br>      <span class="hljs-comment">// Comparator&lt;T&gt; int compare(T t1 , T t2)</span><br>      Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; Integer.compare(o1, o2);<br>      Comparator&lt;Integer&gt; com2 = Integer::compare;<br>com1.compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>类 :: 非静态方法名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// BiPredicate&lt;T,T&gt; boolean test(T t1, T t2)</span><br>      BiPredicate&lt;String, String&gt; bip = (s1, s2) -&gt; s1.equals(s2);<br>      <span class="hljs-comment">// String boolean s1.equals(s2)</span><br>      BiPredicate&lt;String, String&gt; bip2 = String::equals;<br>bip.test(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>对象 :: 非静态方法名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Consumer&lt;String&gt; cons = s -&gt; System.out.println(s);<br>      <span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> System.out;<br>      cons = ps::println;<br>cons.accept(<span class="hljs-string">&quot;str&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4. 构造器引用"></a>4. 构造器引用</h3><blockquote><p>需要与抽象方法参数类型及返回值类型一致<br>需要实体类中存在对应的有参构造器</p></blockquote><ul><li><p><strong>无参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Supplier&lt;Book&gt; sup = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>Supplier&lt;Book&gt; sup2 = Book::<span class="hljs-keyword">new</span>;<br><br><span class="hljs-type">Book</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sup.get();<br></code></pre></td></tr></table></figure></li><li><p><strong>有参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Function&lt;String, Book&gt; func1 = s -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(s);<br>Function&lt;String, Book&gt; func2 = Book::<span class="hljs-keyword">new</span>;<br><br><span class="hljs-type">Book</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> func1.apply(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-type">Book</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> func2.apply(<span class="hljs-string">&quot;B&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>多参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">BiFunction&lt;String, Integer, Book&gt; bf1 = (s, i) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(s, i);<br>BiFunction&lt;String, Integer, Book&gt; bf2 = Book::<span class="hljs-keyword">new</span>;<br><br><span class="hljs-type">Book</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> bf1.apply(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">Book</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> bf2.apply(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5. 数组引用"></a>5. 数组引用</h3><blockquote><p>将数组看成一个对象 ， 与构造器引用类似</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Function&lt;Integer, String[]&gt; fun1 = len -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[len];<br>Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="hljs-keyword">new</span>;<br><br>String[] arr = fun1.apply(<span class="hljs-number">5</span>);<br>String[] arr1 = fun2.apply(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h2 id="二、Stream-API"><a href="#二、Stream-API" class="headerlink" title="二、Stream API"></a>二、Stream API</h2><blockquote><p>Stream流获取操作对象，不改变原对象的值</p></blockquote><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td>顺序流</td><td>Stream<T>  stream()</td></tr><tr><td>并行流</td><td>Stream<T>  parallelStream()</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">        List&lt;Book&gt; books = Book.getBooks(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//        default Stream&lt;T&gt; stream() 顺序流</span><br>        Stream&lt;Book&gt; stream = books.stream();<br><span class="hljs-comment">//        default Stream&lt;T&gt; parallelStream() 并行流</span><br>        Stream&lt;Book&gt; praStream = books.parallelStream();<br></code></pre></td></tr></table></figure><h3 id="1-获取流"><a href="#1-获取流" class="headerlink" title="1. 获取流"></a>1. 获取流</h3><ul><li><p>集合获取流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">        List&lt;Book&gt; books = Book.getBooks(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//        default Stream&lt;T&gt; stream() 顺序流</span><br>        Stream&lt;Book&gt; stream = books.stream();<br></code></pre></td></tr></table></figure></li><li><p>数组获取流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> Arrays.stream(arr);<br><span class="hljs-comment">//      支持泛型</span><br>        Book[] bookArr = &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;a&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;b&quot;</span>)&#125;;<br>        Stream&lt;Book&gt; bookStream = Arrays.stream(bookArr);<br></code></pre></td></tr></table></figure></li><li><p>Stream.of() 创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;Book&gt; bookStream1 = Stream.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>());<br></code></pre></td></tr></table></figure></li><li><p>无限流</p><ul><li><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//  public static&lt;T&gt; Stream&lt;T&gt; </span><br><span class="hljs-comment">//iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span><br>Stream.iterate(<span class="hljs-number">0</span>, t -&gt; t + <span class="hljs-number">2</span>)<br>    .limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p>生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; S)     </span><br>Stream.generate(Math::random)<br>    .limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2. 中间操作"></a>2. 中间操作</h3><ul><li><p><strong>过滤</strong>   <code>filter&lt;P&gt;</code></p><blockquote><p>根据过滤器中的 Predicate 过滤</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br>Stream&lt;Book&gt; bookStream = books.stream();<br><span class="hljs-comment">// filter 过滤价格大于50的书📕</span><br>bookStream.filter(b -&gt; b.getPrice() &gt; <span class="hljs-number">50</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p><strong>截断</strong>   <code>limit(n)</code></p><blockquote><p>截取流中前 n 个数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">books.stream().limit(<span class="hljs-number">5</span>).forEach(books1::add);<br></code></pre></td></tr></table></figure></li><li><p><strong>跳过</strong>   <code>skip(n)</code></p><blockquote><p>跳过前 n 个数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">books.stream().skip(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p><strong>筛选</strong>   <code>distinct()</code></p><blockquote><p>通过流产生的 hashCode 和 equals 去除重复元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">books.stream().distinct().forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul><p><strong>Map映射操作</strong></p><ul><li><p><code>map(Function f)</code></p><blockquote><p>接收一个函数作为参数，这个函数会作用到每一个元素上，并映射成为一个新的元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将小写字母映射为大写返回</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br>String[] arr = &#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>&#125;;<br><span class="hljs-comment">// 列表</span><br>list.stream().map(String::toUpperCase).forEach(System.out::println);<br><span class="hljs-comment">// 数组</span><br>Arrays.stream(arr).map(String::toUpperCase).forEach(System.out::println);<br></code></pre></td></tr></table></figure><ul><li><p>获取Books中价格大于30的书</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">books.stream()<br>    .map(Book::getPrice)<br>    .filter(s -&gt; s &gt; <span class="hljs-number">30</span>)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>flatMap(Function f)</code></p><blockquote><p>接收一个函数作为参数，将流中的每一个值都转换成一个流，最后将所有的流合成一个流</p></blockquote><ul><li><p>将 <code>[[a,a],[b,b],[c,c]] </code>  变成  <code> [a,a,b,b,c,c]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 本类为 StreamA</span><br><span class="hljs-comment">// list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将字符串转化为流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title function_">strToStream</span><span class="hljs-params">(String str)</span> &#123;<br>   List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <span class="hljs-keyword">for</span> (Character c : str.toCharArray()) &#123;<br>       list.add(c);<br>   &#125;<br>   <span class="hljs-keyword">return</span> list.stream();<br>&#125;<br><br><span class="hljs-comment">// 使用普通map 返回值类型为流的集合</span><br>Stream&lt;Stream&lt;Character&gt;&gt; streamStream = <br>    list.stream().map(StreamA::strToStream);<br>    <span class="hljs-comment">// 遍历每个流中的每一个元素</span><br>streamStream.forEach(s -&gt; &#123;<br>   s.forEach(System.out::println);<br>&#125;);<br><br><span class="hljs-comment">//使用flatMap 返回的类型为一个流</span><br>Stream&lt;Character&gt; characterStream = <br>    list.stream().flatMap(StreamA::strToStream);<br><br>characterStream.forEach(System.out::println);<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>Sorted排序操作</strong></p><ul><li><p><code>sorted()</code>  自然排序 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">12</span>, <span class="hljs-number">43</span>, <span class="hljs-number">65</span>, <span class="hljs-number">34</span>, <span class="hljs-number">87</span>, <span class="hljs-number">99</span>, <span class="hljs-number">23</span>, <span class="hljs-number">11</span>);<br><span class="hljs-comment">// (默认从小到大)</span><br>list.stream().sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p><code>sorted(Comparator com)</code>   自定义排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Book&gt; books = Book.getBooks(<span class="hljs-number">10</span>);<br>books.stream()<br>    .sorted(Comparator.comparingInt(Book::getPrice))<br>    .forEach(System.out::println);<br><span class="hljs-comment">// 加上 - 号 表示改变顺序</span><br>books.stream()<br>    .sorted((b1,b2) -&gt; - Integer.compare(b1.getPrice(), b2.getPrice()))<br>    .forEach(System.out::println);<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-终止操作"><a href="#3-终止操作" class="headerlink" title="3. 终止操作"></a>3. 终止操作</h3><blockquote><p>操作结束后会关闭流</p></blockquote><p><strong>基本常见操作</strong></p><ul><li><p><code>forEach(Consumer con)</code>  将元素遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p><code>allMatch(Predicate p)</code>   检查是否匹配所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">books.stream().allMatch(b -&gt; b.getPrice() &lt; <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>anyMatch(Predicate p)</code>   检查是否至少匹配一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">books.stream().anyMatch(b -&gt; b.getPrice() &gt; <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>noneMatch(Predicate p)</code> 检查是否 没有匹配的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">books.stream().noneMatch(b -&gt; b.getName().startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br></code></pre></td></tr></table></figure></li><li><p><code>findFirst()</code>  取流中的第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Book&gt; first = books.stream().findFirst();<br></code></pre></td></tr></table></figure></li><li><p><code>findAny()</code>   取流中的任意一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Optional&lt;Book&gt; any = books.parallelStream().findAny();<br></code></pre></td></tr></table></figure></li></ul><p><strong>计数操作</strong></p><ul><li><p><code>count()</code>    返回流中集合个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> books.stream().filter(b -&gt; b.getPrice() &gt; <span class="hljs-number">50</span>).count();<br></code></pre></td></tr></table></figure></li><li><p><code>max(Comparator c)</code>   返回流中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Stream&lt;Integer&gt; priceStream = books.stream().map(Book::getPrice);<br>Optional&lt;Integer&gt; max = priceStream.max(Integer::compare);<br></code></pre></td></tr></table></figure></li><li><p><code>min(Comparator c)</code>   返回流中的最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Optional&lt;Integer&gt; min = books.stream()<br>    .map(Book::getPrice).min(Integer::compareTo);<br></code></pre></td></tr></table></figure></li></ul><p><strong>归约操作</strong></p><blockquote><p>将流中的集合反复结合起来，得到一个值</p></blockquote><ul><li><p><code>reduce(T identity , BinaryOperator bo)</code>  得到一个值，返回 <code>T</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span>, (i, j) -&gt; i + j);<br><span class="hljs-comment">// 或</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure></li><li><p><code>reduce(BinaryOperator bo)</code>  得到一个值，返回 <code>Optional&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Optional&lt;Integer&gt; sumPrice = books.stream()<br>    .map(Book::getPrice).reduce(Integer::sum);<br></code></pre></td></tr></table></figure></li></ul><p><strong>收集操作</strong></p><blockquote><p>将流中的元素转化为其他形式，接收一个Collector接口的实现，用于对流中的对象进行汇总</p></blockquote><ul><li><p><code>collect(Collector c)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Book&gt; collect = <br>    books.stream()<br>    .filter(b -&gt; b.getPrice() &gt; <span class="hljs-number">50</span>)<br>    .collect(Collectors.toList());<br><span class="hljs-comment">// 或</span><br>List&lt;Book&gt; collect2 = <br>    books.stream()<br>    .filter(b -&gt; b.getPrice() &gt; <span class="hljs-number">50</span>)<br>    .collect(Collectors.toCollection(ArrayList&lt;Book&gt;::<span class="hljs-keyword">new</span>));<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常见：</span><br>Collectors.toList() <br>Collectors.toSet() <br>Collectors.toCollection(Supplier s)<br></code></pre></td></tr></table></figure><h2 id="三、Optional-类"><a href="#三、Optional-类" class="headerlink" title="三、Optional 类"></a>三、Optional 类</h2><blockquote><p>用来预防空指针</p><p>就能不用显示进行空指针检测</p></blockquote><h3 id="1-创建实例"><a href="#1-创建实例" class="headerlink" title="1. 创建实例"></a>1. 创建实例</h3><ul><li><p><code>Optional.of(T t)</code>   创建一个 Optional实例 ， t  必须非空</p></li><li><p><code>Optional.empty()</code>  创建一个空的Optional 实例</p></li><li><p><code>Optional.ofNullable(T t)</code>  创建一个 Optional实例 ， t 可以为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOptional</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">Library</span> <span class="hljs-variable">lib</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Library</span>();<br><span class="hljs-comment">// lib = null;</span><br><span class="hljs-comment">// 如 lib = null 会报错 空指针 因为of中的示例不能为空</span><br>   Optional&lt;Library&gt; olib = Optional.of(lib);<br><br><span class="hljs-comment">// empty() 创建一个空的Optional 实例</span><br>   Optional&lt;Object&gt; empty = Optional.empty();<br>   System.out.println(empty);<br><br><span class="hljs-comment">//  ofNullable(T t) 创建一个 Optional实例 ， t可以为空</span><br>    Optional&lt;Library&gt; olib1 = Optional.ofNullable(lib);<br><br>    System.out.println(olib1);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-获取容器中的对象"><a href="#2-获取容器中的对象" class="headerlink" title="2. 获取容器中的对象"></a>2. 获取容器中的对象</h3><ul><li><code>T get()</code> 调用的容器中有对象，不能为空</li><li><code>T orElse(T other)</code> 如果容器中有对象则返回 ， 没有则返回指定的 other对象</li><li><code>boolean isPresent()</code> 是否包含对象</li></ul><h3 id="3-预防空指针"><a href="#3-预防空指针" class="headerlink" title="3. 预防空指针"></a>3. 预防空指针</h3><p><strong>例 ：获取书名预防空指针异常</strong></p><ul><li><p>在 <code>Optional </code>以前防止空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取书籍名称</span><br><span class="hljs-comment"> * 在Optional以前防止空指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBookName</span><span class="hljs-params">(Library lib)</span>&#123;<br>    <span class="hljs-keyword">if</span> (lib != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">if</span> (lib.getBook() != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> lib.getBook().getName();<br>    &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Optional </code>防止空指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBookNameOp</span><span class="hljs-params">(Library lib)</span>&#123;<br><br>    Optional&lt;Library&gt; libo = Optional.ofNullable(lib);<br>    <span class="hljs-comment">// 这里解决 lib == null</span><br>    <span class="hljs-comment">// 如果 lib == null 则返回书名为 AA</span><br>    <span class="hljs-type">Library</span> <span class="hljs-variable">lib1</span> <span class="hljs-operator">=</span> libo.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Library</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;AA&quot;</span>)));<br><br><span class="hljs-comment">//  此时lib1不为空</span><br><br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> lib1.getBook();<br><br>    Optional&lt;Book&gt; booko = Optional.ofNullable(book1);<br>    <span class="hljs-comment">// 这里解决 lib.getBook() == null</span><br>    <span class="hljs-comment">// 如果 lib != null 且 lib.book == null 则返回书名为 BB</span><br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> booko.orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;BB&quot;</span>));<br><br><span class="hljs-comment">//  此时book不为空</span><br>    <span class="hljs-keyword">return</span> book.getName();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/12/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/12/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="一、语法与元字符"><a href="#一、语法与元字符" class="headerlink" title="一、语法与元字符"></a>一、语法与元字符</h2><h3 id="1-基本语法与元字符"><a href="#1-基本语法与元字符" class="headerlink" title="1. 基本语法与元字符"></a>1. 基本语法与元字符</h3><ul><li><p>基本语法与元字符</p><p><img src="https://s2.loli.net/2023/11/02/fopEa5KnHdjAe9D.png" alt="yufa1"></p><p><img src="https://s2.loli.net/2023/11/02/3UCb2DxnqPF4hsN.png" alt="yufa2"></p></li><li><p><code>\\s</code>：匹配空白字符</p></li><li><p><code>\\S</code>：与<code>\\s</code>取反，匹配任意非空白字符</p></li><li><p><code>.</code>：匹配除换行符外的所有字符（Java中换行符为 <code>\n</code>）</p></li><li><p><code>(?i)</code> 忽略大小写</p><ul><li><code>a(?i)bc</code> 对bc忽略大小写</li><li><code>a((?i)b)c</code> 对b忽略大小写</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 在Java中 加上Pattern.CASE_INSENSITIVE 也表示忽略大小写</span><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex , Pattern.CASE_INSENSITIVE);<br></code></pre></td></tr></table></figure><ul><li><p><code>|</code> ：选择匹配符</p><ul><li><code>ab|cd</code>：匹配 <code>ab</code> 或者 <code>cd</code></li></ul></li></ul><h3 id="2-限定符"><a href="#2-限定符" class="headerlink" title="2. 限定符"></a>2. 限定符</h3><blockquote><p>用于指定其之前的字符或组合连续出现的次数</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/AucSWZJjmPVqUI4.png" alt="yufa3"></p><p><img src="https://s2.loli.net/2023/11/02/Oxi9W41HkvMhwCq.png" alt="yufa4"></p><h3 id="3-定位符"><a href="#3-定位符" class="headerlink" title="3. 定位符"></a>3. 定位符</h3><blockquote><p>规定字符在字符串中的位置</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/oB5vE4R7wOiLhaK.png" alt="dw"></p><ul><li><code>\\b</code>：这里边界指一个单词的结尾 若字符串中有空格，则空格作为分隔符分隔单词</li><li><code>\\B</code>：指每个单词的开头或中间</li></ul><h3 id="4-捕获分组"><a href="#4-捕获分组" class="headerlink" title="4. 捕获分组"></a>4. 捕获分组</h3><p><img src="https://s2.loli.net/2023/11/02/vTNwWRPfGpgxFCd.png" alt="fz"></p><ul><li><p><code>(pattern)</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;([0-9]&#123;2&#125;)(\\d)(\\d)&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>(?&lt;name&gt;pattern)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(?&lt;g1&gt;[0-9]&#123;2&#125;)(?&lt;g2&gt;\\d)(?&lt;g3&gt;\\d)&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-非捕获分组"><a href="#5-非捕获分组" class="headerlink" title="5.非捕获分组"></a>5.非捕获分组</h3><p><img src="https://s2.loli.net/2023/11/02/c7vGm5Nj9oOACwM.png" alt="fz2"></p><ul><li><p><code>(?:pattern)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack=10 bob=19 tom=10&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\w*=(?:10)&quot;</span>;<br><span class="hljs-comment">//得到 jack=10 tom=10</span><br></code></pre></td></tr></table></figure></li><li><p><code>(?=pattern)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\w*=(?=10)&quot;</span>;<br><span class="hljs-comment">//得到 jack= tom=</span><br></code></pre></td></tr></table></figure></li><li><p><code>(?!pattern)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\w*=(?!10)&quot;</span>;<br><span class="hljs-comment">//得到 bob=</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-反向引用"><a href="#6-反向引用" class="headerlink" title="6.反向引用"></a>6.反向引用</h3><blockquote><p>内部：在正则表达式中引用</p><p>外部：在其他方法中引用</p></blockquote><ul><li><code>\\n</code> 内部反向引用<ul><li>表示正则式中第n组匹配的值</li><li>**n **  表示一个捕获分组，在group中的组序号</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12312-111222333&quot;</span>;<br><span class="hljs-comment">// 匹配如 15237-333444555 的编号</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\d&#123;5&#125;-(\\d)\\1&#123;2&#125;(\\d)\\2&#123;2&#125;(\\d)\\3&#123;2&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>$n</code> 外部反向引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern1</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(.)\\1+&quot;</span>);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher1</span> <span class="hljs-operator">=</span> pattern1.matcher(s);<br><span class="hljs-comment">// 使用外部反向引用，$1 表示正则式中的第一个分组捕获的值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> matcher1.replaceAll(<span class="hljs-string">&quot;$1&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-贪婪匹配与懒惰匹配"><a href="#7-贪婪匹配与懒惰匹配" class="headerlink" title="7. 贪婪匹配与懒惰匹配"></a>7. 贪婪匹配与懒惰匹配</h3><blockquote><p>正则表达式中默认为贪婪匹配</p><p>懒惰匹配  -&gt; 尽可能少的匹配</p><p>默认为贪婪匹配  -&gt; 尽可能多的匹配</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/qkhG4mK7vg1B5oC.png" alt="lazzy"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asd123123ds&quot;</span>;<br><span class="hljs-comment">// 默认贪婪匹配</span><br><span class="hljs-comment">// String regex = &quot;\\d+&quot;;</span><br><span class="hljs-comment">// 得到123123</span><br><br><span class="hljs-comment">// 懒惰匹配</span><br><span class="hljs-comment">// tring regex = &quot;\\d+?&quot;;</span><br><span class="hljs-comment">// 得到 1 2 3 1 2 3</span><br><br><span class="hljs-comment">// String regex = &quot;&lt;\\w.+&gt;&quot;;</span><br><span class="hljs-comment">// 得到 &lt;b name=123/&gt;&lt;b name=321/&gt;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;b name=123/&gt;&lt;b name=321/&gt;&quot;</span>;<br><span class="hljs-comment">// 懒惰匹配</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;\\w.+?&gt;&quot;</span>;<br><span class="hljs-comment">// 得到 &lt;b name=123/&gt;和&lt;b name=321/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三、Java中常用的三个类"><a href="#三、Java中常用的三个类" class="headerlink" title="三、Java中常用的三个类"></a>三、Java中常用的三个类</h2><h3 id="1-Pattern"><a href="#1-Pattern" class="headerlink" title="1. Pattern"></a>1. Pattern</h3><ul><li><p><code>matches(regex , url)</code> 整体匹配，只能返回Boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">isMatch</span> <span class="hljs-operator">=</span> Pattern.matches(regex, url);<br></code></pre></td></tr></table></figure></li><li><p><code>compile(regex)</code> 返回正则表达式对象 能用于生成匹配器对象 传入匹配器的字符串中只要有符合的就能匹配，能输出结果值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(str);<br><br><span class="hljs-keyword">while</span> (matcher.find())&#123;<br>    System.out.println(matcher.group(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Matcher"><a href="#2-Matcher" class="headerlink" title="2. Matcher"></a>2. Matcher</h3><blockquote><p>matcher 是一个匹配对象</p></blockquote><p><img src="https://s2.loli.net/2023/11/02/7H1lKGa4LRvJIiu.png" alt="matcher"></p><p><img src="https://s2.loli.net/2023/11/02/vxWUclC8OnhNA2D.png" alt="matcher2"></p><h3 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h3><ul><li><p><code>replaceAll(regex , s)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdk1.3dadasdasdjdk1.4asdas3423dfsjdk1.5&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> str.replaceAll(<span class="hljs-string">&quot;jdk\\d+\\.\\d+&quot;</span>, <span class="hljs-string">&quot;JDK&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>matches(regex)</code> 整体匹配</p></li><li><p><code>split(regex)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AAA#CCC&amp;AAA~CCC12GGG&quot;</span>;<br><span class="hljs-comment">//用#~&amp;数字分割字符串</span><br>str2.split(<span class="hljs-string">&quot;[#&amp;~]|\\d+&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h2><h3 id="1-判断汉字"><a href="#1-判断汉字" class="headerlink" title="1. 判断汉字"></a>1. 判断汉字</h3><blockquote><p>注意汉字的编码范围在    <strong><code>\u0391-\uffe5</code></strong> ，**<code>\u4e00-\u9fa5</code>**</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好你好你好&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^[\u4e00-\u9fa5]+$&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-判断邮编"><a href="#2-判断邮编" class="headerlink" title="2. 判断邮编"></a>2. 判断邮编</h3><blockquote><p>以1开头的六位数字</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;110203&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^[1-9]\\d&#123;5&#125;$&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="3-判断URL"><a href="#3-判断URL" class="headerlink" title="3. 判断URL"></a>3. 判断URL</h3><p><code>^((http)s?://)?([\\w-]+\\.)+[a-zA-Z0-9]+((/[\\w-#]+)+\\?([\\w-]+=[\\w-]+&amp;?)*)?$</code></p><ul><li><p>&#96;&#96;^((http)s?:&#x2F;&#x2F;)?&#96;</p><ul><li>s 可有可无</li><li>https:&#x2F;&#x2F; 可有可无</li></ul></li><li><p><code>([\\w-]+\\.)+</code> </p><ul><li>可能存在多级域名<ul><li>abc.dc.aaa.com.cn</li></ul></li></ul></li><li><p><code>[a-zA-Z0-9]+</code> </p><ul><li>域名结尾</li></ul></li><li><p><code>((/[\\w-#]+)+\\?([\\w-]+=[\\w-]+&amp;?)*)?$</code></p><ul><li><p><code>(/[\\w-#]+)+</code></p><ul><li>可能存在所层路径<ul><li>&#x2F;video&#x2F;aa&#x2F;bb</li></ul></li></ul></li><li><p><code>\\?</code> </p><ul><li>路径结尾带有参数</li></ul></li><li><p><code>([\\w-]+=[\\w-]+&amp;?)*</code></p><ul><li><code>[\\w-]+</code> 参数名由这些字符组成</li><li><code>=</code> 名与值之间用 &#x3D; 相连</li><li><code>[\\w-]+</code> 参数值由这些字符组成</li><li><code>&amp;?</code> 每对参数之间用 &amp; 相连，若只有一对参数则无需&amp;</li><li><code>*</code> 参数可能有一对或多对</li></ul></li><li><p><code>?$</code> 整个域名后的路径或值都可有可无 并都已存在的元素作为整个URL结尾</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断URL是否合法</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isUrl</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span> +<br>            <span class="hljs-string">&quot;/video/BV1Eq4y1E79W?p=17&amp;spm_id_from=pageDriver&quot;</span> +<br>            <span class="hljs-string">&quot;&amp;vd_source=1515d4ece87146a640eebb6175354668&quot;</span>;<br>    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^((http)s?://)?([\\w-]+\\.)+[a-zA-Z0-9]+((/[\\w-#]+)+\\?([\\w-]+=[\\w-]+&amp;?)*)?$&quot;</span>;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isMatch</span> <span class="hljs-operator">=</span> Pattern.matches(regex, url);<br>    <span class="hljs-keyword">if</span> (isMatch) &#123;<br>        System.out.println(<span class="hljs-string">&quot;符合！&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;不符合！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-结巴问题"><a href="#4-结巴问题" class="headerlink" title="4. 结巴问题"></a>4. 结巴问题</h3><blockquote><p>将 ‘’我我我….要要….吃吃吃吃..饭‘’ 变成 ”我要吃饭“</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spla</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;我我我....要要....吃吃吃吃..饭&quot;</span>;<br>    <br>    <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(str);<br><span class="hljs-comment">//    将所有 . 替换成 空白</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> matcher.replaceAll(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern1</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;(.)\\1+&quot;</span>);<br>    <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher1</span> <span class="hljs-operator">=</span> pattern1.matcher(s);<br><span class="hljs-comment">//    使用外部反向引用，$1 表示正则式中的第一个分组捕获的值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> matcher1.replaceAll(<span class="hljs-string">&quot;$1&quot;</span>);<br>    System.out.println(res);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-验证数字规范性"><a href="#5-验证数字规范性" class="headerlink" title="5. 验证数字规范性"></a>5. 验证数字规范性</h3><blockquote><p>识别整数 ， 小数，负数等</p></blockquote><ul><li><code>^[-+]?([1-9]\\d*|0)(\\.\\d+)?$</code><ul><li><code>[-+]?</code><ul><li>数字符号不一定存在</li></ul></li><li><code>([1-9\\d*|0])</code><ul><li>数字以 1 开头 </li><li>或以 0 开头的小数且只能由一个 0</li></ul></li><li><code>(\\.\\d+)?</code><ul><li>数字的小数部分不一定存在</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
